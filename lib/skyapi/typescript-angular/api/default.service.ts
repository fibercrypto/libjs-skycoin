/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.25.1
 * Contact: skycoin.doe@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { InlineObject } from '../model/inlineObject';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InlineResponse2003 } from '../model/inlineResponse2003';
import { InlineResponse2004 } from '../model/inlineResponse2004';
import { InlineResponse2005 } from '../model/inlineResponse2005';
import { InlineResponse2006 } from '../model/inlineResponse2006';
import { InlineResponse2007 } from '../model/inlineResponse2007';
import { InlineResponseDefault } from '../model/inlineResponseDefault';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'http://127.0.0.1:6420';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath || basePath || this.basePath;

        } else {
            this.configuration.basePath = basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Returns the total number of unique address that have coins.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addressCount(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addressCount(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addressCount(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addressCount(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/addresscount`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns the historical, spent outputs associated with an address
     * @param address address to filter by
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addressUxouts(address: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse200>>;
    public addressUxouts(address: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse200>>>;
    public addressUxouts(address: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse200>>>;
    public addressUxouts(address: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressUxouts.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (address !== undefined && address !== null) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InlineResponse200>>(`${this.configuration.basePath}/api/v1/address_uxouts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param addrs command separated list of addresses
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public balanceGet(addrs: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public balanceGet(addrs: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public balanceGet(addrs: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public balanceGet(addrs: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addrs === null || addrs === undefined) {
            throw new Error('Required parameter addrs was null or undefined when calling balanceGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addrs !== undefined && addrs !== null) {
            queryParameters = queryParameters.set('addrs', <any>addrs);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/balance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param addrs command separated list of addresses
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public balancePost(addrs: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public balancePost(addrs: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public balancePost(addrs: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public balancePost(addrs: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addrs === null || addrs === undefined) {
            throw new Error('Required parameter addrs was null or undefined when calling balancePost.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addrs !== undefined && addrs !== null) {
            queryParameters = queryParameters.set('addrs', <any>addrs);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/balance`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns a block by hash or seq. Note: only one of hash or seq is allowed
     * @param hash 
     * @param seq 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public block(hash?: string, seq?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public block(hash?: string, seq?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public block(hash?: string, seq?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public block(hash?: string, seq?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (hash !== undefined && hash !== null) {
            queryParameters = queryParameters.set('hash', <any>hash);
        }
        if (seq !== undefined && seq !== null) {
            queryParameters = queryParameters.set('seq', <any>seq);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/block`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the blockchain metadata.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public blockchainMetadata(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public blockchainMetadata(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public blockchainMetadata(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public blockchainMetadata(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/blockchain/metadata`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the blockchain sync progress.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public blockchainProgress(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public blockchainProgress(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public blockchainProgress(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public blockchainProgress(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/blockchain/progress`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * blocksHandler returns blocks between a start and end point,
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
     * @param start 
     * @param end 
     * @param seqs 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public blocksGet(start?: number, end?: number, seqs?: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public blocksGet(start?: number, end?: number, seqs?: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public blocksGet(start?: number, end?: number, seqs?: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public blocksGet(start?: number, end?: number, seqs?: Array<number>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (start !== undefined && start !== null) {
            queryParameters = queryParameters.set('start', <any>start);
        }
        if (end !== undefined && end !== null) {
            queryParameters = queryParameters.set('end', <any>end);
        }
        if (seqs) {
            queryParameters = queryParameters.set('seqs', seqs.join(COLLECTION_FORMATS['csv']));
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/blocks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * blocksHandler returns blocks between a start and end point,
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
     * @param start 
     * @param end 
     * @param seqs 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public blocksPost(start?: number, end?: number, seqs?: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public blocksPost(start?: number, end?: number, seqs?: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public blocksPost(start?: number, end?: number, seqs?: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public blocksPost(start?: number, end?: number, seqs?: Array<number>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (start !== undefined && start !== null) {
            queryParameters = queryParameters.set('start', <any>start);
        }
        if (end !== undefined && end !== null) {
            queryParameters = queryParameters.set('end', <any>end);
        }
        if (seqs) {
            queryParameters = queryParameters.set('seqs', seqs.join(COLLECTION_FORMATS['csv']));
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/blocks`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * coinSupplyHandler returns coin distribution supply stats
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public coinSupply(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public coinSupply(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public coinSupply(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public coinSupply(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/coinSupply`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public csrf(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public csrf(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public csrf(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public csrf(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse2001>(`${this.configuration.basePath}/api/v1/csrf`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public defaultConnections(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public defaultConnections(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public defaultConnections(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public defaultConnections(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<string>>(`${this.configuration.basePath}/api/v1/network/defaultConnections`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns all transactions (confirmed and unconfirmed) for an address
     * @param address tags to filter by
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public explorerAddress(address?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2002>>;
    public explorerAddress(address?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2002>>>;
    public explorerAddress(address?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2002>>>;
    public explorerAddress(address?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (address !== undefined && address !== null) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InlineResponse2002>>(`${this.configuration.basePath}/api/v1/explorer/address`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns node health data.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public health(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public health(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public health(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public health(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/health`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns the most recent N blocks on the blockchain
     * @param num 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public lastBlocks(num: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public lastBlocks(num: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public lastBlocks(num: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public lastBlocks(num: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (num === null || num === undefined) {
            throw new Error('Required parameter num was null or undefined when calling lastBlocks.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (num !== undefined && num !== null) {
            queryParameters = queryParameters.set('num', <any>num);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/last_blocks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This endpoint returns a specific connection.
     * 
     * @param addr Address port
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public networkConnection(addr: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2003>;
    public networkConnection(addr: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2003>>;
    public networkConnection(addr: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2003>>;
    public networkConnection(addr: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addr === null || addr === undefined) {
            throw new Error('Required parameter addr was null or undefined when calling networkConnection.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addr !== undefined && addr !== null) {
            queryParameters = queryParameters.set('addr', <any>addr);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse2003>(`${this.configuration.basePath}/api/v1/network/connection`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This endpoint returns all outgoings connections.
     * 
     * @param states Connection status.
     * @param direction Direction of the connection.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2003>>;
    public networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2003>>>;
    public networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2003>>>;
    public networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (states !== undefined && states !== null) {
            queryParameters = queryParameters.set('states', <any>states);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters = queryParameters.set('direction', <any>direction);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InlineResponse2003>>(`${this.configuration.basePath}/api/v1/network/connections`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * This endpoint disconnects a connection by ID or address
     * @param id Address id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public networkConnectionsDisconnect(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public networkConnectionsDisconnect(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public networkConnectionsDisconnect(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public networkConnectionsDisconnect(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling networkConnectionsDisconnect.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/network/connection/disconnect`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * This endpoint returns all connections found through peer exchange
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public networkConnectionsExchange(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public networkConnectionsExchange(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public networkConnectionsExchange(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public networkConnectionsExchange(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<string>>(`${this.configuration.basePath}/api/v1/network/connections/exchange`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public networkConnectionsTrust(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public networkConnectionsTrust(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public networkConnectionsTrust(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public networkConnectionsTrust(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<string>>(`${this.configuration.basePath}/api/v1/network/connections/trust`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * 
     * @param address 
     * @param hash 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public outputsGet(address?: Array<string>, hash?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public outputsGet(address?: Array<string>, hash?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public outputsGet(address?: Array<string>, hash?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public outputsGet(address?: Array<string>, hash?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (address) {
            queryParameters = queryParameters.set('address', address.join(COLLECTION_FORMATS['csv']));
        }
        if (hash) {
            queryParameters = queryParameters.set('hash', hash.join(COLLECTION_FORMATS['csv']));
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/outputs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * 
     * @param address 
     * @param hash 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public outputsPost(address?: string, hash?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public outputsPost(address?: string, hash?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public outputsPost(address?: string, hash?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public outputsPost(address?: string, hash?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (address !== undefined && address !== null) {
            queryParameters = queryParameters.set('address', <any>address);
        }
        if (hash !== undefined && hash !== null) {
            queryParameters = queryParameters.set('hash', <any>hash);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/outputs`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns pending (unconfirmed) transactions without verbose
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pendingTxs(observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2004>>;
    public pendingTxs(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2004>>>;
    public pendingTxs(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2004>>>;
    public pendingTxs(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InlineResponse2004>>(`${this.configuration.basePath}/api/v1/pendingTxs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public resendUnconfirmedTxns(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public resendUnconfirmedTxns(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public resendUnconfirmedTxns(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public resendUnconfirmedTxns(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/resendUnconfirmedTxns`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the top skycoin holders.
     * 
     * @param includeDistribution include distribution addresses or not, default value false
     * @param n include distribution addresses or not, default value false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public richlist(includeDistribution?: boolean, n?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public richlist(includeDistribution?: boolean, n?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public richlist(includeDistribution?: boolean, n?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public richlist(includeDistribution?: boolean, n?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (includeDistribution !== undefined && includeDistribution !== null) {
            queryParameters = queryParameters.set('include-distribution', <any>includeDistribution);
        }
        if (n !== undefined && n !== null) {
            queryParameters = queryParameters.set('n', <any>n);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/richlist`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns a transaction identified by its txid hash with just id
     * @param txid transaction hash
     * @param encoded return as a raw encoded transaction.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transaction(txid: string, encoded?: boolean, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public transaction(txid: string, encoded?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public transaction(txid: string, encoded?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public transaction(txid: string, encoded?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling transaction.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (txid !== undefined && txid !== null) {
            queryParameters = queryParameters.set('txid', <any>txid);
        }
        if (encoded !== undefined && encoded !== null) {
            queryParameters = queryParameters.set('encoded', <any>encoded);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/transaction`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Broadcast a hex-encoded, serialized transaction to the network.
     * 
     * @param rawtx hex-encoded serialized transaction string.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transactionInject(rawtx: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public transactionInject(rawtx: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public transactionInject(rawtx: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public transactionInject(rawtx: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (rawtx === null || rawtx === undefined) {
            throw new Error('Required parameter rawtx was null or undefined when calling transactionInject.');
        }

        let headers = this.defaultHeaders;
        if (rawtx !== undefined && rawtx !== null) {
            headers = headers.set('rawtx', String(rawtx));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v2/transaction/inject`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * 
     * @param txid Transaction id hash
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transactionRaw(txid?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public transactionRaw(txid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public transactionRaw(txid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public transactionRaw(txid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (txid !== undefined && txid !== null) {
            queryParameters = queryParameters.set('txid', <any>txid);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v2/transaction/raw`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Decode and verify an encoded transaction
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transactionVerify(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public transactionVerify(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public transactionVerify(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public transactionVerify(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v2/transaction/verify`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns transactions that match the filters.
     * 
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transactionsGet(addrs?: string, confirmed?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public transactionsGet(addrs?: string, confirmed?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public transactionsGet(addrs?: string, confirmed?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public transactionsGet(addrs?: string, confirmed?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addrs !== undefined && addrs !== null) {
            queryParameters = queryParameters.set('addrs', <any>addrs);
        }
        if (confirmed !== undefined && confirmed !== null) {
            queryParameters = queryParameters.set('confirmed', <any>confirmed);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns transactions that match the filters.
     * 
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transactionsPost(addrs?: string, confirmed?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public transactionsPost(addrs?: string, confirmed?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public transactionsPost(addrs?: string, confirmed?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public transactionsPost(addrs?: string, confirmed?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addrs !== undefined && addrs !== null) {
            queryParameters = queryParameters.set('addrs', <any>addrs);
        }
        if (confirmed !== undefined && confirmed !== null) {
            queryParameters = queryParameters.set('confirmed', <any>confirmed);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/transactions`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns an unspent output by ID.
     * 
     * @param uxid uxid to filter by
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uxout(uxid?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public uxout(uxid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public uxout(uxid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public uxout(uxid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (uxid !== undefined && uxid !== null) {
            queryParameters = queryParameters.set('uxid', <any>uxid);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/uxout`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Verifies a Skycoin address.
     * 
     * @param address Address id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public verifyAddress(address: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2007>;
    public verifyAddress(address: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2007>>;
    public verifyAddress(address: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2007>>;
    public verifyAddress(address: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling verifyAddress.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (address !== undefined && address !== null) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<InlineResponse2007>(`${this.configuration.basePath}/api/v2/address/verify`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * versionHandler returns the application version info
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public version(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public version(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public version(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public version(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/version`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a wallet by id.
     * 
     * @param id tags to filter by
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public wallet(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public wallet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public wallet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public wallet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling wallet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/wallet`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the wallet&#39;s balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param id tags to filter by
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletBalance(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletBalance(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletBalance(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletBalance(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletBalance.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/wallet/balance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
     * @param seed Wallet seed.
     * @param label Wallet label.
     * @param scan The number of addresses to scan ahead for balances.
     * @param encrypt Encrypt wallet.
     * @param password Wallet Password
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (seed === null || seed === undefined) {
            throw new Error('Required parameter seed was null or undefined when calling walletCreate.');
        }
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling walletCreate.');
        }

        let headers = this.defaultHeaders;
        if (seed !== undefined && seed !== null) {
            headers = headers.set('seed', String(seed));
        }
        if (label !== undefined && label !== null) {
            headers = headers.set('label', String(label));
        }
        if (scan !== undefined && scan !== null) {
            headers = headers.set('scan', String(scan));
        }
        if (encrypt !== undefined && encrypt !== null) {
            headers = headers.set('encrypt', String(encrypt));
        }
        if (password !== undefined && password !== null) {
            headers = headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/create`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Decrypts wallet.
     * 
     * @param id Wallet id.
     * @param password Wallet password.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletDecrypt(id: string, password: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletDecrypt(id: string, password: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletDecrypt(id: string, password: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletDecrypt(id: string, password: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletDecrypt.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletDecrypt.');
        }

        let headers = this.defaultHeaders;
        if (id !== undefined && id !== null) {
            headers = headers.set('id', String(id));
        }
        if (password !== undefined && password !== null) {
            headers = headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/decrypt`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Encrypt wallet.
     * 
     * @param id Wallet id.
     * @param password Wallet password.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletEncrypt(id: string, password: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletEncrypt(id: string, password: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletEncrypt(id: string, password: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletEncrypt(id: string, password: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletEncrypt.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletEncrypt.');
        }

        let headers = this.defaultHeaders;
        if (id !== undefined && id !== null) {
            headers = headers.set('id', String(id));
        }
        if (password !== undefined && password !== null) {
            headers = headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/encrypt`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns the wallet directory path
     * @param addr Address port
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletFolder(addr: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2006>;
    public walletFolder(addr: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2006>>;
    public walletFolder(addr: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2006>>;
    public walletFolder(addr: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addr === null || addr === undefined) {
            throw new Error('Required parameter addr was null or undefined when calling walletFolder.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (addr !== undefined && addr !== null) {
            queryParameters = queryParameters.set('addr', <any>addr);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InlineResponse2006>(`${this.configuration.basePath}/api/v1/wallets/folderName`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Generates new addresses
     * @param id Wallet Id
     * @param num The number you want to generate
     * @param password Wallet Password
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletNewAddress(id: string, num?: string, password?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletNewAddress(id: string, num?: string, password?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletNewAddress(id: string, num?: string, password?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletNewAddress(id: string, num?: string, password?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletNewAddress.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }
        if (num !== undefined && num !== null) {
            queryParameters = queryParameters.set('num', <any>num);
        }
        if (password !== undefined && password !== null) {
            queryParameters = queryParameters.set('password', <any>password);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/newAddress`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns the wallet directory path
     * @param entropy Entropy bitSize.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletNewSeed(entropy?: '128' | '256', observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletNewSeed(entropy?: '128' | '256', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletNewSeed(entropy?: '128' | '256', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletNewSeed(entropy?: '128' | '256', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (entropy !== undefined && entropy !== null) {
            queryParameters = queryParameters.set('entropy', <any>entropy);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/wallet/newSeed`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * 
     * @param id Wallet id.
     * @param seed Wallet seed.
     * @param password Wallet password.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletRecover(id: string, seed: string, password?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletRecover(id: string, seed: string, password?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletRecover(id: string, seed: string, password?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletRecover(id: string, seed: string, password?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletRecover.');
        }
        if (seed === null || seed === undefined) {
            throw new Error('Required parameter seed was null or undefined when calling walletRecover.');
        }

        let headers = this.defaultHeaders;
        if (id !== undefined && id !== null) {
            headers = headers.set('id', String(id));
        }
        if (seed !== undefined && seed !== null) {
            headers = headers.set('seed', String(seed));
        }
        if (password !== undefined && password !== null) {
            headers = headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v2/wallet/recover`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * 
     * @param id Wallet Id.
     * @param password Wallet password.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletSeed(id: string, password: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletSeed(id: string, password: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletSeed(id: string, password: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletSeed(id: string, password: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletSeed.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletSeed.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }
        if (password !== undefined && password !== null) {
            queryParameters = queryParameters.set('password', <any>password);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/seed`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Verifies a wallet seed.
     * 
     * @param seed Seed to be verified.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletSeedVerify(seed?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletSeedVerify(seed?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletSeedVerify(seed?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletSeedVerify(seed?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;
        if (seed !== undefined && seed !== null) {
            headers = headers.set('seed', String(seed));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v2/wallet/seed/verify`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
     * @param id Wallet id
     * @param dst Recipient address
     * @param coins Number of coins to spend, in droplets. 1 coin equals 1e6 droplets.
     * @param password Wallet password.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletSpent(id: string, dst: string, coins: string, password: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletSpent(id: string, dst: string, coins: string, password: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletSpent(id: string, dst: string, coins: string, password: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletSpent(id: string, dst: string, coins: string, password: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletSpent.');
        }
        if (dst === null || dst === undefined) {
            throw new Error('Required parameter dst was null or undefined when calling walletSpent.');
        }
        if (coins === null || coins === undefined) {
            throw new Error('Required parameter coins was null or undefined when calling walletSpent.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletSpent.');
        }

        let headers = this.defaultHeaders;
        if (id !== undefined && id !== null) {
            headers = headers.set('id', String(id));
        }
        if (dst !== undefined && dst !== null) {
            headers = headers.set('dst', String(dst));
        }
        if (coins !== undefined && coins !== null) {
            headers = headers.set('coins', String(coins));
        }
        if (password !== undefined && password !== null) {
            headers = headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/spend`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Creates a signed transaction
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletTransaction(body: InlineObject, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletTransaction(body: InlineObject, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletTransaction(body: InlineObject, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletTransaction(body: InlineObject, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling walletTransaction.');
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/transaction`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
     * @param id Wallet id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletTransactions(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletTransactions(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletTransactions(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletTransactions(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletTransactions.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.configuration.basePath}/api/v1/wallet/transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Unloads wallet from the wallet service.
     * 
     * @param id Wallet Id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletUnload(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletUnload(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletUnload(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletUnload(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletUnload.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/unload`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the wallet.
     * 
     * @param id Wallet Id.
     * @param label The label the wallet will be updated to.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public walletUpdate(id: string, label: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public walletUpdate(id: string, label: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public walletUpdate(id: string, label: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public walletUpdate(id: string, label: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletUpdate.');
        }
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling walletUpdate.');
        }

        let headers = this.defaultHeaders;
        if (id !== undefined && id !== null) {
            headers = headers.set('id', String(id));
        }
        if (label !== undefined && label !== null) {
            headers = headers.set('label', String(label));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers = headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.configuration.basePath}/api/v1/wallet/update`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Returns all loaded wallets
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public wallets(observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2005>>;
    public wallets(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2005>>>;
    public wallets(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2005>>>;
    public wallets(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InlineResponse2005>>(`${this.configuration.basePath}/api/v1/wallets`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
