/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * The version of the OpenAPI document: 0.27.0
 * Contact: contact@skycoin.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';
import { CustomQueryEncoderHelper }                          from '../encoder';

import { Observable }                                        from 'rxjs/Observable';
import '../rxjs-operators';

import { BlockSchema } from '../model/blockSchema';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse20010 } from '../model/inlineResponse20010';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InlineResponse2003 } from '../model/inlineResponse2003';
import { InlineResponse2004 } from '../model/inlineResponse2004';
import { InlineResponse2005 } from '../model/inlineResponse2005';
import { InlineResponse2006 } from '../model/inlineResponse2006';
import { InlineResponse2007 } from '../model/inlineResponse2007';
import { InlineResponse2008 } from '../model/inlineResponse2008';
import { InlineResponse2009 } from '../model/inlineResponse2009';
import { InlineResponseDefault } from '../model/inlineResponseDefault';
import { NetworkConnectionSchema } from '../model/networkConnectionSchema';
import { Transaction } from '../model/transaction';
import { TransactionV2ParamsAddress } from '../model/transactionV2ParamsAddress';
import { TransactionV2ParamsUnspent } from '../model/transactionV2ParamsUnspent';
import { TransactionVerifyRequest } from '../model/transactionVerifyRequest';
import { WalletTransactionRequest } from '../model/walletTransactionRequest';
import { WalletTransactionSignRequest } from '../model/walletTransactionSignRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'http://127.0.0.1:6420';
    public defaultHeaders = new Headers();
    public configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath || basePath || this.basePath;

        } else {
            this.configuration.basePath = basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @summary Returns the total number of unique address that have coins.
     */
    public addressCount(extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse200> {
        return this.addressCountWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Returns the historical, spent outputs associated with an address
     * @param address address to filter by
     */
    public addressUxouts(address: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Array<object>> {
        return this.addressUxoutsWithHttpInfo(address, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     */
    public apiV1RawtxGet(extraHttpRequestParams?: RequestOptionsArgs): Observable<string> {
        return this.apiV1RawtxGetWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     */
    public apiV2MetricsGet(extraHttpRequestParams?: RequestOptionsArgs): Observable<string> {
        return this.apiV2MetricsGetWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param addrs command separated list of addresses
     */
    public balanceGet(addrs: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.balanceGetWithHttpInfo(addrs, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param addrs command separated list of addresses
     */
    public balancePost(addrs: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.balancePostWithHttpInfo(addrs, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param hash get block by hash
     * @param seq get block by sequence number
     */
    public block(hash?: string, seq?: number, extraHttpRequestParams?: RequestOptionsArgs): Observable<Array<BlockSchema>> {
        return this.blockWithHttpInfo(hash, seq, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the blockchain metadata.
     */
    public blockchainMetadata(extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.blockchainMetadataWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the blockchain sync progress.
     */
    public blockchainProgress(extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.blockchainProgressWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param start start seq
     * @param end end seq
     * @param seq comma-separated list of block seqs
     */
    public blocks(start?: number, end?: number, seq?: Array<number>, extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2001> {
        return this.blocksWithHttpInfo(start, end, seq, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * coinSupplyHandler returns coin distribution supply stats
     */
    public coinSupply(extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2002> {
        return this.coinSupplyWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     */
    public csrf(extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2003> {
        return this.csrfWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param type storage type.
     * @param key key of the specific value to get.
     */
    public dataDELETE(type?: string, key?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<{}> {
        return this.dataDELETEWithHttpInfo(type, key, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param type storage type.
     * @param key key of the specific value to get.
     */
    public dataGET(type?: string, key?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.dataGETWithHttpInfo(type, key, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param type storage type.
     * @param key key of the specific value to get.
     * @param val additional value.
     */
    public dataPOST(type?: string, key?: string, val?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<{}> {
        return this.dataPOSTWithHttpInfo(type, key, val, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     */
    public defaultConnections(extraHttpRequestParams?: RequestOptionsArgs): Observable<Array<string>> {
        return this.defaultConnectionsWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns node health data.
     */
    public health(extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.healthWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Returns the most recent N blocks on the blockchain
     * @param num Num of blockss
     */
    public lastBlocks(num: number, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.lastBlocksWithHttpInfo(num, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary This endpoint returns a specific connection.
     * @param addr Address port
     */
    public networkConnection(addr: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<NetworkConnectionSchema> {
        return this.networkConnectionWithHttpInfo(addr, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary This endpoint returns all outgoings connections.
     * @param states Connection status.
     * @param direction Direction of the connection.
     */
    public networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2004> {
        return this.networkConnectionsWithHttpInfo(states, direction, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * This endpoint disconnects a connection by ID or address
     * @param id Address id.
     */
    public networkConnectionsDisconnect(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<{}> {
        return this.networkConnectionsDisconnectWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * This endpoint returns all connections found through peer exchange
     */
    public networkConnectionsExchange(extraHttpRequestParams?: RequestOptionsArgs): Observable<Array<string>> {
        return this.networkConnectionsExchangeWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     */
    public networkConnectionsTrust(extraHttpRequestParams?: RequestOptionsArgs): Observable<Array<string>> {
        return this.networkConnectionsTrustWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param address 
     * @param hash 
     */
    public outputsGet(address?: Array<string>, hash?: Array<string>, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.outputsGetWithHttpInfo(address, hash, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param address 
     * @param hash 
     */
    public outputsPost(address?: string, hash?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.outputsPostWithHttpInfo(address, hash, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     */
    public pendingTxs(extraHttpRequestParams?: RequestOptionsArgs): Observable<Array<InlineResponse20010>> {
        return this.pendingTxsWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     */
    public resendUnconfirmedTxns(extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.resendUnconfirmedTxnsWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the top skycoin holders.
     * @param includeDistribution include distribution addresses or not, default value false
     * @param n include distribution addresses or not, default value false
     */
    public richlist(includeDistribution?: boolean, n?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.richlistWithHttpInfo(includeDistribution, n, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Returns a transaction identified by its txid hash with just id
     * @param txid transaction Id
     */
    public transaction(txid: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Transaction> {
        return this.transactionWithHttpInfo(txid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Broadcast a hex-encoded, serialized transaction to the network.
     * @param rawtx hex-encoded serialized transaction string.
     * @param noBroadcast Disable the network broadcast
     */
    public transactionInject(rawtx: string, noBroadcast?: boolean, extraHttpRequestParams?: RequestOptionsArgs): Observable<string> {
        return this.transactionInjectWithHttpInfo(rawtx, noBroadcast, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param transactionV2ParamsAddress 
     */
    public transactionPost(transactionV2ParamsAddress?: TransactionV2ParamsAddress, extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2008> {
        return this.transactionPostWithHttpInfo(transactionV2ParamsAddress, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param transactionV2ParamsUnspent Unspent parameters
     */
    public transactionPostUnspent(transactionV2ParamsUnspent: TransactionV2ParamsUnspent, extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2008> {
        return this.transactionPostUnspentWithHttpInfo(transactionV2ParamsUnspent, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * @param txid Transaction id hash
     */
    public transactionRaw(txid?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.transactionRawWithHttpInfo(txid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Decode and verify an encoded transaction
     * @param transactionVerifyRequest 
     */
    public transactionVerify(transactionVerifyRequest: TransactionVerifyRequest, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.transactionVerifyWithHttpInfo(transactionVerifyRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     */
    public transactionsGet(addrs?: string, confirmed?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.transactionsGetWithHttpInfo(addrs, confirmed, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     */
    public transactionsPost(addrs?: string, confirmed?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.transactionsPostWithHttpInfo(addrs, confirmed, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns an unspent output by ID.
     * @param uxid uxid to filter by
     */
    public uxout(uxid?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.uxoutWithHttpInfo(uxid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Verifies a Skycoin address.
     * @param address Address id.
     */
    public verifyAddress(address: object, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.verifyAddressWithHttpInfo(address, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * versionHandler returns the application version info
     */
    public version(extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2005> {
        return this.versionWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns a wallet by id.
     * @param id tags to filter by
     */
    public wallet(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Returns the wallet\'s balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * @param id tags to filter by
     */
    public walletBalance(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletBalanceWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Create a wallet
     * @param type wallet seed passphrase [optional, bip44 type wallet only]
     * @param seed Wallet seed.
     * @param label Wallet label.
     * @param seedPassphrase wallet seed passphrase [optional, bip44 type wallet only]
     * @param bip44Coin BIP44 coin type [optional, defaults to 8000 (skycoin\&#39;s coin type), only valid if type is \&quot;bip44\&quot;]
     * @param xpub xpub key [required for xpub wallets]
     * @param scan The number of addresses to scan ahead for balances.
     * @param encrypt Encrypt wallet.
     * @param password Wallet Password
     */
    public walletCreate(type: string, seed: string, label: string, seedPassphrase?: string, bip44Coin?: string, xpub?: string, scan?: number, encrypt?: boolean, password?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletCreateWithHttpInfo(type, seed, label, seedPassphrase, bip44Coin, xpub, scan, encrypt, password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Decrypts wallet.
     * @param id Wallet id.
     * @param password Wallet password.
     */
    public walletDecrypt(id: string, password: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletDecryptWithHttpInfo(id, password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Encrypt wallet.
     * @param id Wallet id.
     * @param password Wallet password.
     */
    public walletEncrypt(id: string, password: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletEncryptWithHttpInfo(id, password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Returns the wallet directory path
     * @param addr Address port
     */
    public walletFolder(addr: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2007> {
        return this.walletFolderWithHttpInfo(addr, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Generates new addresses
     * @param id Wallet Id
     * @param num The number you want to generate
     * @param password Wallet Password
     */
    public walletNewAddress(id: string, num?: string, password?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletNewAddressWithHttpInfo(id, num, password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Returns the wallet directory path
     * @param entropy Entropy bitSize.
     */
    public walletNewSeed(entropy?: '128' | '256', extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletNewSeedWithHttpInfo(entropy, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Recovers an encrypted wallet by providing the wallet seed and optional seed passphrase
     * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * @param id Wallet id.
     * @param seed Wallet seed.
     * @param seedPassphrase Wallet seed-passphrase.
     * @param password Wallet password.
     */
    public walletRecover(id: string, seed: string, seedPassphrase?: string, password?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletRecoverWithHttpInfo(id, seed, seedPassphrase, password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * @param id Wallet Id.
     * @param password Wallet password.
     */
    public walletSeed(id: string, password: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletSeedWithHttpInfo(id, password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Verifies a wallet seed.
     * @param seed Seed to be verified.
     */
    public walletSeedVerify(seed?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletSeedVerifyWithHttpInfo(seed, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Creates a signed transaction
     * @param walletTransactionRequest 
     */
    public walletTransaction(walletTransactionRequest: WalletTransactionRequest, extraHttpRequestParams?: RequestOptionsArgs): Observable<object> {
        return this.walletTransactionWithHttpInfo(walletTransactionRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Creates a signed transaction
     * @param walletTransactionSignRequest 
     */
    public walletTransactionSign(walletTransactionSignRequest: WalletTransactionSignRequest, extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2009> {
        return this.walletTransactionSignWithHttpInfo(walletTransactionSignRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param id Wallet Id.
     */
    public walletTransactions(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<InlineResponse2006> {
        return this.walletTransactionsWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Unloads wallet from the wallet service.
     * @param id Wallet Id.
     */
    public walletUnload(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<{}> {
        return this.walletUnloadWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Update the wallet.
     * @param id Wallet Id.
     * @param label The label the wallet will be updated to.
     */
    public walletUpdate(id: string, label: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<string> {
        return this.walletUpdateWithHttpInfo(id, label, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Returns all loaded wallets
     */
    public wallets(extraHttpRequestParams?: RequestOptionsArgs): Observable<Array<object>> {
        return this.walletsWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Returns the total number of unique address that have coins.
     * 
     
     */
    public addressCountWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/addresscount`, requestOptions);
    }

    /**
     * 
     * Returns the historical, spent outputs associated with an address
     * @param address address to filter by
     
     */
    public addressUxoutsWithHttpInfo(address: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressUxouts.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (address !== undefined && address !== null) {
            queryParameters.set('address', <any>address);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/address_uxouts`, requestOptions);
    }

    /**
     * 
     * 
     
     */
    public apiV1RawtxGetWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/rawtx`, requestOptions);
    }

    /**
     * 
     * 
     
     */
    public apiV2MetricsGetWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/metrics`, requestOptions);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param addrs command separated list of addresses
     
     */
    public balanceGetWithHttpInfo(addrs: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (addrs === null || addrs === undefined) {
            throw new Error('Required parameter addrs was null or undefined when calling balanceGet.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (addrs !== undefined && addrs !== null) {
            queryParameters.set('addrs', <any>addrs);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/balance`, requestOptions);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param addrs command separated list of addresses
     
     */
    public balancePostWithHttpInfo(addrs: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (addrs === null || addrs === undefined) {
            throw new Error('Required parameter addrs was null or undefined when calling balancePost.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (addrs !== undefined && addrs !== null) {
            queryParameters.set('addrs', <any>addrs);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/balance`, requestOptions);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param hash get block by hash
     * @param seq get block by sequence number
     
     */
    public blockWithHttpInfo(hash?: string, seq?: number, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (hash !== undefined && hash !== null) {
            queryParameters.set('hash', <any>hash);
        }
        if (seq !== undefined && seq !== null) {
            queryParameters.set('seq', <any>seq);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/block`, requestOptions);
    }

    /**
     * Returns the blockchain metadata.
     * 
     
     */
    public blockchainMetadataWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/blockchain/metadata`, requestOptions);
    }

    /**
     * Returns the blockchain sync progress.
     * 
     
     */
    public blockchainProgressWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/blockchain/progress`, requestOptions);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param start start seq
     * @param end end seq
     * @param seq comma-separated list of block seqs
     
     */
    public blocksWithHttpInfo(start?: number, end?: number, seq?: Array<number>, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (start !== undefined && start !== null) {
            queryParameters.set('start', <any>start);
        }
        if (end !== undefined && end !== null) {
            queryParameters.set('end', <any>end);
        }
        if (seq) {
            seq.forEach((element) => {
                queryParameters.append('seq', <any>element);
            })
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/blocks`, requestOptions);
    }

    /**
     * 
     * coinSupplyHandler returns coin distribution supply stats
     
     */
    public coinSupplyWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/coinSupply`, requestOptions);
    }

    /**
     * Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     * 
     
     */
    public csrfWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/csrf`, requestOptions);
    }

    /**
     * 
     * 
     * @param type storage type.
     * @param key key of the specific value to get.
     
     */
    public dataDELETEWithHttpInfo(type?: string, key?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (type !== undefined && type !== null) {
            headers.set('type', String(type));
        }
        if (key !== undefined && key !== null) {
            headers.set('key', String(key));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/data`, requestOptions);
    }

    /**
     * 
     * 
     * @param type storage type.
     * @param key key of the specific value to get.
     
     */
    public dataGETWithHttpInfo(type?: string, key?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (type !== undefined && type !== null) {
            headers.set('type', String(type));
        }
        if (key !== undefined && key !== null) {
            headers.set('key', String(key));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/data`, requestOptions);
    }

    /**
     * 
     * 
     * @param type storage type.
     * @param key key of the specific value to get.
     * @param val additional value.
     
     */
    public dataPOSTWithHttpInfo(type?: string, key?: string, val?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (type !== undefined && type !== null) {
            headers.set('type', String(type));
        }
        if (key !== undefined && key !== null) {
            headers.set('key', String(key));
        }
        if (val !== undefined && val !== null) {
            headers.set('val', String(val));
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/data`, requestOptions);
    }

    /**
     * defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     * 
     
     */
    public defaultConnectionsWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/network/defaultConnections`, requestOptions);
    }

    /**
     * Returns node health data.
     * 
     
     */
    public healthWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/health`, requestOptions);
    }

    /**
     * 
     * Returns the most recent N blocks on the blockchain
     * @param num Num of blockss
     
     */
    public lastBlocksWithHttpInfo(num: number, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (num === null || num === undefined) {
            throw new Error('Required parameter num was null or undefined when calling lastBlocks.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (num !== undefined && num !== null) {
            queryParameters.set('num', <any>num);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/last_blocks`, requestOptions);
    }

    /**
     * This endpoint returns a specific connection.
     * 
     * @param addr Address port
     
     */
    public networkConnectionWithHttpInfo(addr: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (addr === null || addr === undefined) {
            throw new Error('Required parameter addr was null or undefined when calling networkConnection.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (addr !== undefined && addr !== null) {
            queryParameters.set('addr', <any>addr);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/network/connection`, requestOptions);
    }

    /**
     * This endpoint returns all outgoings connections.
     * 
     * @param states Connection status.
     * @param direction Direction of the connection.
     
     */
    public networkConnectionsWithHttpInfo(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (states !== undefined && states !== null) {
            queryParameters.set('states', <any>states);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters.set('direction', <any>direction);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/network/connections`, requestOptions);
    }

    /**
     * 
     * This endpoint disconnects a connection by ID or address
     * @param id Address id.
     
     */
    public networkConnectionsDisconnectWithHttpInfo(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling networkConnectionsDisconnect.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (id !== undefined && id !== null) {
            queryParameters.set('id', <any>id);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/network/connection/disconnect`, requestOptions);
    }

    /**
     * 
     * This endpoint returns all connections found through peer exchange
     
     */
    public networkConnectionsExchangeWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/network/connections/exchange`, requestOptions);
    }

    /**
     * trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     * 
     
     */
    public networkConnectionsTrustWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/network/connections/trust`, requestOptions);
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * 
     * @param address 
     * @param hash 
     
     */
    public outputsGetWithHttpInfo(address?: Array<string>, hash?: Array<string>, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (address) {
            address.forEach((element) => {
                queryParameters.append('address', <any>element);
            })
        }
        if (hash) {
            hash.forEach((element) => {
                queryParameters.append('hash', <any>element);
            })
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/outputs`, requestOptions);
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * 
     * @param address 
     * @param hash 
     
     */
    public outputsPostWithHttpInfo(address?: string, hash?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (address !== undefined && address !== null) {
            queryParameters.set('address', <any>address);
        }
        if (hash !== undefined && hash !== null) {
            queryParameters.set('hash', <any>hash);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/outputs`, requestOptions);
    }

    /**
     * 
     * 
     
     */
    public pendingTxsWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/pendingTxs`, requestOptions);
    }

    /**
     * 
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     
     */
    public resendUnconfirmedTxnsWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application-json',
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/resendUnconfirmedTxns`, requestOptions);
    }

    /**
     * Returns the top skycoin holders.
     * 
     * @param includeDistribution include distribution addresses or not, default value false
     * @param n include distribution addresses or not, default value false
     
     */
    public richlistWithHttpInfo(includeDistribution?: boolean, n?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (includeDistribution !== undefined && includeDistribution !== null) {
            queryParameters.set('include-distribution', <any>includeDistribution);
        }
        if (n !== undefined && n !== null) {
            queryParameters.set('n', <any>n);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/richlist`, requestOptions);
    }

    /**
     * 
     * Returns a transaction identified by its txid hash with just id
     * @param txid transaction Id
     
     */
    public transactionWithHttpInfo(txid: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling transaction.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (txid !== undefined && txid !== null) {
            queryParameters.set('txid', <any>txid);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/transaction`, requestOptions);
    }

    /**
     * Broadcast a hex-encoded, serialized transaction to the network.
     * 
     * @param rawtx hex-encoded serialized transaction string.
     * @param noBroadcast Disable the network broadcast
     
     */
    public transactionInjectWithHttpInfo(rawtx: string, noBroadcast?: boolean, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (rawtx === null || rawtx === undefined) {
            throw new Error('Required parameter rawtx was null or undefined when calling transactionInject.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (rawtx !== undefined && rawtx !== null) {
            headers.set('rawtx', String(rawtx));
        }
        if (noBroadcast !== undefined && noBroadcast !== null) {
            headers.set('no_broadcast', String(noBroadcast));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/injectTransaction`, requestOptions);
    }

    /**
     * 
     * 
     * @param transactionV2ParamsAddress 
     
     */
    public transactionPostWithHttpInfo(transactionV2ParamsAddress?: TransactionV2ParamsAddress, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers.set('Content-Type', httpContentTypeSelected);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: transactionV2ParamsAddress == null ? '' : JSON.stringify(transactionV2ParamsAddress), // https://github.com/angular/angular/issues/10612
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/transaction`, requestOptions);
    }

    /**
     * 
     * 
     * @param transactionV2ParamsUnspent Unspent parameters
     
     */
    public transactionPostUnspentWithHttpInfo(transactionV2ParamsUnspent: TransactionV2ParamsUnspent, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (transactionV2ParamsUnspent === null || transactionV2ParamsUnspent === undefined) {
            throw new Error('Required parameter transactionV2ParamsUnspent was null or undefined when calling transactionPostUnspent.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers.set('Content-Type', httpContentTypeSelected);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: transactionV2ParamsUnspent == null ? '' : JSON.stringify(transactionV2ParamsUnspent), // https://github.com/angular/angular/issues/10612
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/transaction/unspent`, requestOptions);
    }

    /**
     * Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * 
     * @param txid Transaction id hash
     
     */
    public transactionRawWithHttpInfo(txid?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (txid !== undefined && txid !== null) {
            queryParameters.set('txid', <any>txid);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/transaction/raw`, requestOptions);
    }

    /**
     * 
     * Decode and verify an encoded transaction
     * @param transactionVerifyRequest 
     
     */
    public transactionVerifyWithHttpInfo(transactionVerifyRequest: TransactionVerifyRequest, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (transactionVerifyRequest === null || transactionVerifyRequest === undefined) {
            throw new Error('Required parameter transactionVerifyRequest was null or undefined when calling transactionVerify.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers.set('Content-Type', httpContentTypeSelected);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: transactionVerifyRequest == null ? '' : JSON.stringify(transactionVerifyRequest), // https://github.com/angular/angular/issues/10612
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/transaction/verify`, requestOptions);
    }

    /**
     * Returns transactions that match the filters.
     * 
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     
     */
    public transactionsGetWithHttpInfo(addrs?: string, confirmed?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (addrs !== undefined && addrs !== null) {
            queryParameters.set('addrs', <any>addrs);
        }
        if (confirmed !== undefined && confirmed !== null) {
            queryParameters.set('confirmed', <any>confirmed);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/transactions`, requestOptions);
    }

    /**
     * Returns transactions that match the filters.
     * 
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     
     */
    public transactionsPostWithHttpInfo(addrs?: string, confirmed?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (addrs !== undefined && addrs !== null) {
            queryParameters.set('addrs', <any>addrs);
        }
        if (confirmed !== undefined && confirmed !== null) {
            queryParameters.set('confirmed', <any>confirmed);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/transactions`, requestOptions);
    }

    /**
     * Returns an unspent output by ID.
     * 
     * @param uxid uxid to filter by
     
     */
    public uxoutWithHttpInfo(uxid?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (uxid !== undefined && uxid !== null) {
            queryParameters.set('uxid', <any>uxid);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/uxout`, requestOptions);
    }

    /**
     * Verifies a Skycoin address.
     * 
     * @param address Address id.
     
     */
    public verifyAddressWithHttpInfo(address: object, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling verifyAddress.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (address !== undefined && address !== null) {
            queryParameters.set('address', <any>address);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/address/verify`, requestOptions);
    }

    /**
     * 
     * versionHandler returns the application version info
     
     */
    public versionWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/version`, requestOptions);
    }

    /**
     * Returns a wallet by id.
     * 
     * @param id tags to filter by
     
     */
    public walletWithHttpInfo(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling wallet.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (id !== undefined && id !== null) {
            queryParameters.set('id', <any>id);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet`, requestOptions);
    }

    /**
     * Returns the wallet\&#39;s balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * 
     * @param id tags to filter by
     
     */
    public walletBalanceWithHttpInfo(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletBalance.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (id !== undefined && id !== null) {
            queryParameters.set('id', <any>id);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/balance`, requestOptions);
    }

    /**
     * 
     * Create a wallet
     * @param type wallet seed passphrase [optional, bip44 type wallet only]
     * @param seed Wallet seed.
     * @param label Wallet label.
     * @param seedPassphrase wallet seed passphrase [optional, bip44 type wallet only]
     * @param bip44Coin BIP44 coin type [optional, defaults to 8000 (skycoin\&#39;s coin type), only valid if type is \&quot;bip44\&quot;]
     * @param xpub xpub key [required for xpub wallets]
     * @param scan The number of addresses to scan ahead for balances.
     * @param encrypt Encrypt wallet.
     * @param password Wallet Password
     
     */
    public walletCreateWithHttpInfo(type: string, seed: string, label: string, seedPassphrase?: string, bip44Coin?: string, xpub?: string, scan?: number, encrypt?: boolean, password?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling walletCreate.');
        }
        if (seed === null || seed === undefined) {
            throw new Error('Required parameter seed was null or undefined when calling walletCreate.');
        }
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling walletCreate.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (seedPassphrase !== undefined && seedPassphrase !== null) {
            headers.set('seed-passphrase', String(seedPassphrase));
        }
        if (type !== undefined && type !== null) {
            headers.set('type', String(type));
        }
        if (bip44Coin !== undefined && bip44Coin !== null) {
            headers.set('bip44-coin', String(bip44Coin));
        }
        if (seed !== undefined && seed !== null) {
            headers.set('seed', String(seed));
        }
        if (xpub !== undefined && xpub !== null) {
            headers.set('xpub', String(xpub));
        }
        if (label !== undefined && label !== null) {
            headers.set('label', String(label));
        }
        if (scan !== undefined && scan !== null) {
            headers.set('scan', String(scan));
        }
        if (encrypt !== undefined && encrypt !== null) {
            headers.set('encrypt', String(encrypt));
        }
        if (password !== undefined && password !== null) {
            headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/create`, requestOptions);
    }

    /**
     * Decrypts wallet.
     * 
     * @param id Wallet id.
     * @param password Wallet password.
     
     */
    public walletDecryptWithHttpInfo(id: string, password: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletDecrypt.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletDecrypt.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (id !== undefined && id !== null) {
            headers.set('id', String(id));
        }
        if (password !== undefined && password !== null) {
            headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/decrypt`, requestOptions);
    }

    /**
     * Encrypt wallet.
     * 
     * @param id Wallet id.
     * @param password Wallet password.
     
     */
    public walletEncryptWithHttpInfo(id: string, password: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletEncrypt.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletEncrypt.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (id !== undefined && id !== null) {
            headers.set('id', String(id));
        }
        if (password !== undefined && password !== null) {
            headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/encrypt`, requestOptions);
    }

    /**
     * 
     * Returns the wallet directory path
     * @param addr Address port
     
     */
    public walletFolderWithHttpInfo(addr: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (addr === null || addr === undefined) {
            throw new Error('Required parameter addr was null or undefined when calling walletFolder.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (addr !== undefined && addr !== null) {
            queryParameters.set('addr', <any>addr);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallets/folderName`, requestOptions);
    }

    /**
     * 
     * Generates new addresses
     * @param id Wallet Id
     * @param num The number you want to generate
     * @param password Wallet Password
     
     */
    public walletNewAddressWithHttpInfo(id: string, num?: string, password?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletNewAddress.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (id !== undefined && id !== null) {
            queryParameters.set('id', <any>id);
        }
        if (num !== undefined && num !== null) {
            queryParameters.set('num', <any>num);
        }
        if (password !== undefined && password !== null) {
            queryParameters.set('password', <any>password);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/newAddress`, requestOptions);
    }

    /**
     * 
     * Returns the wallet directory path
     * @param entropy Entropy bitSize.
     
     */
    public walletNewSeedWithHttpInfo(entropy?: '128' | '256', extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (entropy !== undefined && entropy !== null) {
            queryParameters.set('entropy', <any>entropy);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/newSeed`, requestOptions);
    }

    /**
     * Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * Recovers an encrypted wallet by providing the wallet seed and optional seed passphrase
     * @param id Wallet id.
     * @param seed Wallet seed.
     * @param seedPassphrase Wallet seed-passphrase.
     * @param password Wallet password.
     
     */
    public walletRecoverWithHttpInfo(id: string, seed: string, seedPassphrase?: string, password?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletRecover.');
        }
        if (seed === null || seed === undefined) {
            throw new Error('Required parameter seed was null or undefined when calling walletRecover.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (id !== undefined && id !== null) {
            headers.set('id', String(id));
        }
        if (seed !== undefined && seed !== null) {
            headers.set('seed', String(seed));
        }
        if (seedPassphrase !== undefined && seedPassphrase !== null) {
            headers.set('seed-passphrase', String(seedPassphrase));
        }
        if (password !== undefined && password !== null) {
            headers.set('password', String(password));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/wallet/recover`, requestOptions);
    }

    /**
     * This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * 
     * @param id Wallet Id.
     * @param password Wallet password.
     
     */
    public walletSeedWithHttpInfo(id: string, password: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletSeed.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletSeed.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (id !== undefined && id !== null) {
            queryParameters.set('id', <any>id);
        }
        if (password !== undefined && password !== null) {
            queryParameters.set('password', <any>password);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/seed`, requestOptions);
    }

    /**
     * Verifies a wallet seed.
     * 
     * @param seed Seed to be verified.
     
     */
    public walletSeedVerifyWithHttpInfo(seed?: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (seed !== undefined && seed !== null) {
            headers.set('seed', String(seed));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/wallet/seed/verify`, requestOptions);
    }

    /**
     * Creates a signed transaction
     * 
     * @param walletTransactionRequest 
     
     */
    public walletTransactionWithHttpInfo(walletTransactionRequest: WalletTransactionRequest, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (walletTransactionRequest === null || walletTransactionRequest === undefined) {
            throw new Error('Required parameter walletTransactionRequest was null or undefined when calling walletTransaction.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers.set('Content-Type', httpContentTypeSelected);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: walletTransactionRequest == null ? '' : JSON.stringify(walletTransactionRequest), // https://github.com/angular/angular/issues/10612
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/transaction`, requestOptions);
    }

    /**
     * Creates a signed transaction
     * 
     * @param walletTransactionSignRequest 
     
     */
    public walletTransactionSignWithHttpInfo(walletTransactionSignRequest: WalletTransactionSignRequest, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (walletTransactionSignRequest === null || walletTransactionSignRequest === undefined) {
            throw new Error('Required parameter walletTransactionSignRequest was null or undefined when calling walletTransactionSign.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers.set('Content-Type', httpContentTypeSelected);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: walletTransactionSignRequest == null ? '' : JSON.stringify(walletTransactionSignRequest), // https://github.com/angular/angular/issues/10612
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v2/wallet/transaction/sign`, requestOptions);
    }

    /**
     * 
     * 
     * @param id Wallet Id.
     
     */
    public walletTransactionsWithHttpInfo(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletTransactions.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (id !== undefined && id !== null) {
            queryParameters.set('id', <any>id);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/transactions`, requestOptions);
    }

    /**
     * Unloads wallet from the wallet service.
     * 
     * @param id Wallet Id.
     
     */
    public walletUnloadWithHttpInfo(id: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletUnload.');
        }

        let queryParameters = new URLSearchParams('', new CustomQueryEncoderHelper());
        if (id !== undefined && id !== null) {
            queryParameters.set('id', <any>id);
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/unload`, requestOptions);
    }

    /**
     * Update the wallet.
     * 
     * @param id Wallet Id.
     * @param label The label the wallet will be updated to.
     
     */
    public walletUpdateWithHttpInfo(id: string, label: string, extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletUpdate.');
        }
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling walletUpdate.');
        }

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (id !== undefined && id !== null) {
            headers.set('id', String(id));
        }
        if (label !== undefined && label !== null) {
            headers.set('label', String(label));
        }

        // authentication (csrfAuth) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["X-CSRF-TOKEN"]) {
            headers.set('X-CSRF-TOKEN', this.configuration.apiKeys["X-CSRF-TOKEN"]);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'application/xml'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallet/update`, requestOptions);
    }

    /**
     * 
     * Returns all loaded wallets
     
     */
    public walletsWithHttpInfo(extraHttpRequestParams?: RequestOptionsArgs): Observable<Response> {

        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json',
            'application/xml',
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            withCredentials:this.configuration.withCredentials
        });
        // issues#4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(`${this.configuration.basePath}/api/v1/wallets`, requestOptions);
    }

}
