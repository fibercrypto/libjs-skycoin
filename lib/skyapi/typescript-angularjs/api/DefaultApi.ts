/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.25.1
 * Contact: skycoin.doe@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as models from '../model/models';

/* tslint:disable:no-unused-variable member-ordering */

export class DefaultApi {
    protected basePath = 'http://127.0.0.1:6420';
    public defaultHeaders : any = {};

    static $inject: string[] = ['$http', '$httpParamSerializer', 'basePath'];

    constructor(protected $http: ng.IHttpService, protected $httpParamSerializer?: (d: any) => any, basePath?: string) {
        if (basePath !== undefined) {
            this.basePath = basePath;
        }
    }

    /**
     * 
     * @summary Returns the total number of unique address that have coins.
     */
    public addressCount (extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/addresscount';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns the historical, spent outputs associated with an address
     * @param address address to filter by
     */
    public addressUxouts (address: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.InlineResponse200>> {
        const localVarPath = this.basePath + '/api/v1/address_uxouts';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling addressUxouts.');
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param addrs command separated list of addresses
     */
    public balanceGet (addrs: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/balance';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'addrs' is not null or undefined
        if (addrs === null || addrs === undefined) {
            throw new Error('Required parameter addrs was null or undefined when calling balanceGet.');
        }

        if (addrs !== undefined) {
            queryParameters['addrs'] = addrs;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param addrs command separated list of addresses
     */
    public balancePost (addrs: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/balance';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'addrs' is not null or undefined
        if (addrs === null || addrs === undefined) {
            throw new Error('Required parameter addrs was null or undefined when calling balancePost.');
        }

        if (addrs !== undefined) {
            queryParameters['addrs'] = addrs;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns a block by hash or seq. Note: only one of hash or seq is allowed
     * @param hash 
     * @param seq 
     */
    public block (hash?: string, seq?: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/block';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (hash !== undefined) {
            queryParameters['hash'] = hash;
        }

        if (seq !== undefined) {
            queryParameters['seq'] = seq;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns the blockchain metadata.
     */
    public blockchainMetadata (extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/blockchain/metadata';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns the blockchain sync progress.
     */
    public blockchainProgress (extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/blockchain/progress';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
     * @summary blocksHandler returns blocks between a start and end point,
     * @param start 
     * @param end 
     * @param seqs 
     */
    public blocksGet (start?: number, end?: number, seqs?: Array<number>, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/blocks';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (seqs !== undefined) {
            queryParameters['seqs'] = seqs;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
     * @summary blocksHandler returns blocks between a start and end point,
     * @param start 
     * @param end 
     * @param seqs 
     */
    public blocksPost (start?: number, end?: number, seqs?: Array<number>, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/blocks';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        if (end !== undefined) {
            queryParameters['end'] = end;
        }

        if (seqs !== undefined) {
            queryParameters['seqs'] = seqs;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * coinSupplyHandler returns coin distribution supply stats
     */
    public coinSupply (extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/api/v1/coinSupply';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     */
    public csrf (extraHttpRequestParams?: any ) : ng.IHttpPromise<models.InlineResponse2001> {
        const localVarPath = this.basePath + '/api/v1/csrf';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     */
    public defaultConnections (extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<string>> {
        const localVarPath = this.basePath + '/api/v1/network/defaultConnections';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns all transactions (confirmed and unconfirmed) for an address
     * @param address tags to filter by
     */
    public explorerAddress (address?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.InlineResponse2002>> {
        const localVarPath = this.basePath + '/api/v1/explorer/address';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns node health data.
     */
    public health (extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/health';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns the most recent N blocks on the blockchain
     * @param num 
     */
    public lastBlocks (num: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/last_blocks';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'num' is not null or undefined
        if (num === null || num === undefined) {
            throw new Error('Required parameter num was null or undefined when calling lastBlocks.');
        }

        if (num !== undefined) {
            queryParameters['num'] = num;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary This endpoint returns a specific connection.
     * @param addr Address port
     */
    public networkConnection (addr: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.InlineResponse2003> {
        const localVarPath = this.basePath + '/api/v1/network/connection';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'addr' is not null or undefined
        if (addr === null || addr === undefined) {
            throw new Error('Required parameter addr was null or undefined when calling networkConnection.');
        }

        if (addr !== undefined) {
            queryParameters['addr'] = addr;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary This endpoint returns all outgoings connections.
     * @param states Connection status.
     * @param direction Direction of the connection.
     */
    public networkConnections (states?: models.'pending' | 'connected' | 'introduced', direction?: models.'connected' | 'introduced', extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.InlineResponse2003>> {
        const localVarPath = this.basePath + '/api/v1/network/connections';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (states !== undefined) {
            queryParameters['states'] = states;
        }

        if (direction !== undefined) {
            queryParameters['direction'] = direction;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * This endpoint disconnects a connection by ID or address
     * @param id Address id.
     */
    public networkConnectionsDisconnect (id: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/api/v1/network/connection/disconnect';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling networkConnectionsDisconnect.');
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * This endpoint returns all connections found through peer exchange
     */
    public networkConnectionsExchange (extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<string>> {
        const localVarPath = this.basePath + '/api/v1/network/connections/exchange';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     */
    public networkConnectionsTrust (extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<string>> {
        const localVarPath = this.basePath + '/api/v1/network/connections/trust';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param address 
     * @param hash 
     */
    public outputsGet (address?: Array<string>, hash?: Array<string>, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/outputs';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (hash !== undefined) {
            queryParameters['hash'] = hash;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param address 
     * @param hash 
     */
    public outputsPost (address?: string, hash?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/outputs';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        if (hash !== undefined) {
            queryParameters['hash'] = hash;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns pending (unconfirmed) transactions without verbose
     */
    public pendingTxs (extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.InlineResponse2004>> {
        const localVarPath = this.basePath + '/api/v1/pendingTxs';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     */
    public resendUnconfirmedTxns (extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/api/v1/resendUnconfirmedTxns';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns the top skycoin holders.
     * @param includeDistribution include distribution addresses or not, default value false
     * @param n include distribution addresses or not, default value false
     */
    public richlist (includeDistribution?: boolean, n?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/richlist';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (includeDistribution !== undefined) {
            queryParameters['include-distribution'] = includeDistribution;
        }

        if (n !== undefined) {
            queryParameters['n'] = n;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns a transaction identified by its txid hash with just id
     * @param txid transaction hash
     * @param encoded return as a raw encoded transaction.
     */
    public transaction (txid: string, encoded?: boolean, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/transaction';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'txid' is not null or undefined
        if (txid === null || txid === undefined) {
            throw new Error('Required parameter txid was null or undefined when calling transaction.');
        }

        if (txid !== undefined) {
            queryParameters['txid'] = txid;
        }

        if (encoded !== undefined) {
            queryParameters['encoded'] = encoded;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Broadcast a hex-encoded, serialized transaction to the network.
     * @param rawtx hex-encoded serialized transaction string.
     */
    public transactionInject (rawtx: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v2/transaction/inject';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'rawtx' is not null or undefined
        if (rawtx === null || rawtx === undefined) {
            throw new Error('Required parameter rawtx was null or undefined when calling transactionInject.');
        }

        headerParams['rawtx'] = rawtx;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * @param txid Transaction id hash
     */
    public transactionRaw (txid?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v2/transaction/raw';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (txid !== undefined) {
            queryParameters['txid'] = txid;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Decode and verify an encoded transaction
     */
    public transactionVerify (extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v2/transaction/verify';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     */
    public transactionsGet (addrs?: string, confirmed?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/transactions';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (addrs !== undefined) {
            queryParameters['addrs'] = addrs;
        }

        if (confirmed !== undefined) {
            queryParameters['confirmed'] = confirmed;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param addrs command separated list of addresses
     * @param confirmed Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     */
    public transactionsPost (addrs?: string, confirmed?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/transactions';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (addrs !== undefined) {
            queryParameters['addrs'] = addrs;
        }

        if (confirmed !== undefined) {
            queryParameters['confirmed'] = confirmed;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns an unspent output by ID.
     * @param uxid uxid to filter by
     */
    public uxout (uxid?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/uxout';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (uxid !== undefined) {
            queryParameters['uxid'] = uxid;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Verifies a Skycoin address.
     * @param address Address id.
     */
    public verifyAddress (address: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.InlineResponse2007> {
        const localVarPath = this.basePath + '/api/v2/address/verify';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling verifyAddress.');
        }

        if (address !== undefined) {
            queryParameters['address'] = address;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * versionHandler returns the application version info
     */
    public version (extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/api/v1/version';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns a wallet by id.
     * @param id tags to filter by
     */
    public wallet (id: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling wallet.');
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * @param id tags to filter by
     */
    public walletBalance (id: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/balance';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletBalance.');
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
     * @param seed Wallet seed.
     * @param label Wallet label.
     * @param scan The number of addresses to scan ahead for balances.
     * @param encrypt Encrypt wallet.
     * @param password Wallet Password
     */
    public walletCreate (seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/create';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'seed' is not null or undefined
        if (seed === null || seed === undefined) {
            throw new Error('Required parameter seed was null or undefined when calling walletCreate.');
        }

        // verify required parameter 'label' is not null or undefined
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling walletCreate.');
        }

        headerParams['seed'] = seed;

        headerParams['label'] = label;

        headerParams['scan'] = scan;

        headerParams['encrypt'] = encrypt;

        headerParams['password'] = password;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Decrypts wallet.
     * @param id Wallet id.
     * @param password Wallet password.
     */
    public walletDecrypt (id: string, password: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/decrypt';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletDecrypt.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletDecrypt.');
        }

        headerParams['id'] = id;

        headerParams['password'] = password;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Encrypt wallet.
     * @param id Wallet id.
     * @param password Wallet password.
     */
    public walletEncrypt (id: string, password: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/encrypt';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletEncrypt.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletEncrypt.');
        }

        headerParams['id'] = id;

        headerParams['password'] = password;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns the wallet directory path
     * @param addr Address port
     */
    public walletFolder (addr: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.InlineResponse2006> {
        const localVarPath = this.basePath + '/api/v1/wallets/folderName';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'addr' is not null or undefined
        if (addr === null || addr === undefined) {
            throw new Error('Required parameter addr was null or undefined when calling walletFolder.');
        }

        if (addr !== undefined) {
            queryParameters['addr'] = addr;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Generates new addresses
     * @param id Wallet Id
     * @param num The number you want to generate
     * @param password Wallet Password
     */
    public walletNewAddress (id: string, num?: string, password?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/newAddress';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletNewAddress.');
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        if (num !== undefined) {
            queryParameters['num'] = num;
        }

        if (password !== undefined) {
            queryParameters['password'] = password;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns the wallet directory path
     * @param entropy Entropy bitSize.
     */
    public walletNewSeed (entropy?: models.'128' | '256', extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/newSeed';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (entropy !== undefined) {
            queryParameters['entropy'] = entropy;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * @param id Wallet id.
     * @param seed Wallet seed.
     * @param password Wallet password.
     */
    public walletRecover (id: string, seed: string, password?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v2/wallet/recover';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletRecover.');
        }

        // verify required parameter 'seed' is not null or undefined
        if (seed === null || seed === undefined) {
            throw new Error('Required parameter seed was null or undefined when calling walletRecover.');
        }

        headerParams['id'] = id;

        headerParams['seed'] = seed;

        headerParams['password'] = password;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * @param id Wallet Id.
     * @param password Wallet password.
     */
    public walletSeed (id: string, password: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/seed';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletSeed.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletSeed.');
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        if (password !== undefined) {
            queryParameters['password'] = password;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Verifies a wallet seed.
     * @param seed Seed to be verified.
     */
    public walletSeedVerify (seed?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v2/wallet/seed/verify';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        headerParams['seed'] = seed;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
     * @param id Wallet id
     * @param dst Recipient address
     * @param coins Number of coins to spend, in droplets. 1 coin equals 1e6 droplets.
     * @param password Wallet password.
     */
    public walletSpent (id: string, dst: string, coins: string, password: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/spend';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletSpent.');
        }

        // verify required parameter 'dst' is not null or undefined
        if (dst === null || dst === undefined) {
            throw new Error('Required parameter dst was null or undefined when calling walletSpent.');
        }

        // verify required parameter 'coins' is not null or undefined
        if (coins === null || coins === undefined) {
            throw new Error('Required parameter coins was null or undefined when calling walletSpent.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling walletSpent.');
        }

        headerParams['id'] = id;

        headerParams['dst'] = dst;

        headerParams['coins'] = coins;

        headerParams['password'] = password;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Creates a signed transaction
     * @param body 
     */
    public walletTransaction (body: models.models.InlineObject, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/transaction';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling walletTransaction.');
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: body,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
     * @param id Wallet id.
     */
    public walletTransactions (id: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<any> {
        const localVarPath = this.basePath + '/api/v1/wallet/transactions';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletTransactions.');
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Unloads wallet from the wallet service.
     * @param id Wallet Id.
     */
    public walletUnload (id: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/api/v1/wallet/unload';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletUnload.');
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * 
     * @summary Update the wallet.
     * @param id Wallet Id.
     * @param label The label the wallet will be updated to.
     */
    public walletUpdate (id: string, label: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/api/v1/wallet/update';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling walletUpdate.');
        }

        // verify required parameter 'label' is not null or undefined
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling walletUpdate.');
        }

        headerParams['id'] = id;

        headerParams['label'] = label;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
     * Returns all loaded wallets
     */
    public wallets (extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.InlineResponse2005>> {
        const localVarPath = this.basePath + '/api/v1/wallets';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
}
