// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.25.1
 * Contact: contact@skycoin.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://127.0.0.1:6420".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiV1ExplorerAddressInputs
 */
export interface ApiV1ExplorerAddressInputs {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ExplorerAddressInputs
     */
    owner?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1ExplorerAddressInputs
     */
    hours?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiV1ExplorerAddressInputs
     */
    calculatedHours?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ExplorerAddressInputs
     */
    coins?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ExplorerAddressInputs
     */
    uxid?: string;
}

/**
 * 
 * @export
 * @interface ApiV1ExplorerAddressOutputs
 */
export interface ApiV1ExplorerAddressOutputs {
    /**
     * 
     * @type {number}
     * @memberof ApiV1ExplorerAddressOutputs
     */
    hours?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ExplorerAddressOutputs
     */
    dst?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ExplorerAddressOutputs
     */
    coins?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ExplorerAddressOutputs
     */
    uxid?: string;
}

/**
 * 
 * @export
 * @interface ApiV1ExplorerAddressStatus
 */
export interface ApiV1ExplorerAddressStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1ExplorerAddressStatus
     */
    unconfirmed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiV1ExplorerAddressStatus
     */
    blockSeq?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiV1ExplorerAddressStatus
     */
    label?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1ExplorerAddressStatus
     */
    confirmed?: boolean;
}

/**
 * BlockTransactionVerbose has readable transaction data for transactions inside a block. It differs from Transaction in that it includes metadata for transaction inputs and the calculated coinhour fee spent by the block
 * @export
 * @interface ApiV1PendingTxsTransaction
 */
export interface ApiV1PendingTxsTransaction {
    /**
     * 
     * @type {Array<ApiV1ExplorerAddressOutputs>}
     * @memberof ApiV1PendingTxsTransaction
     */
    outputs?: Array<ApiV1ExplorerAddressOutputs>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PendingTxsTransaction
     */
    innerHash?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1PendingTxsTransaction
     */
    inputs?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1PendingTxsTransaction
     */
    sigs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ApiV1PendingTxsTransaction
     */
    length?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PendingTxsTransaction
     */
    txid?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1PendingTxsTransaction
     */
    type?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiV1PendingTxsTransaction
     */
    timestamp?: number;
}

/**
 * 
 * @export
 * @interface ApiV1WalletTransactionHoursSelection
 */
export interface ApiV1WalletTransactionHoursSelection {
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletTransactionHoursSelection
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletTransactionHoursSelection
     */
    shareFactor?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletTransactionHoursSelection
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface ApiV1WalletTransactionTo
 */
export interface ApiV1WalletTransactionTo {
    /**
     * 
     * @type {number}
     * @memberof ApiV1WalletTransactionTo
     */
    hours?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletTransactionTo
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1WalletTransactionTo
     */
    coins?: number;
}

/**
 * 
 * @export
 * @interface ApiV1WalletTransactionWallet
 */
export interface ApiV1WalletTransactionWallet {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1WalletTransactionWallet
     */
    unspents?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1WalletTransactionWallet
     */
    addresses?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletTransactionWallet
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletTransactionWallet
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface ApiV1WalletsEntries
 */
export interface ApiV1WalletsEntries {
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsEntries
     */
    publicKey?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsEntries
     */
    address?: string;
}

/**
 * 
 * @export
 * @interface ApiV1WalletsMeta
 */
export interface ApiV1WalletsMeta {
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsMeta
     */
    filename?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1WalletsMeta
     */
    encrypted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsMeta
     */
    cryptoType?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsMeta
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsMeta
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsMeta
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1WalletsMeta
     */
    coin?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1WalletsMeta
     */
    timestamp?: number;
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    changeAddress?: string;
    /**
     * 
     * @type {ApiV1WalletTransactionHoursSelection}
     * @memberof InlineObject
     */
    hoursSelection?: ApiV1WalletTransactionHoursSelection;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject
     */
    ignoreUnconfirmed?: boolean;
    /**
     * 
     * @type {Array<ApiV1WalletTransactionTo>}
     * @memberof InlineObject
     */
    to?: Array<ApiV1WalletTransactionTo>;
    /**
     * 
     * @type {ApiV1WalletTransactionWallet}
     * @memberof InlineObject
     */
    wallet?: ApiV1WalletTransactionWallet;
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    hours?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    coins?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    uxid?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    ownerAddress?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    spentBlockSeq?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    spentTx?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    srcBlockSeq?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    srcTx?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    csrfToken?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<ApiV1ExplorerAddressOutputs>}
     * @memberof InlineResponse2002
     */
    outputs?: Array<ApiV1ExplorerAddressOutputs>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    innerHash?: string;
    /**
     * 
     * @type {Array<ApiV1ExplorerAddressInputs>}
     * @memberof InlineResponse2002
     */
    inputs?: Array<ApiV1ExplorerAddressInputs>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    fee?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    sigs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    length?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    txid?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    type?: number;
    /**
     * 
     * @type {ApiV1ExplorerAddressStatus}
     * @memberof InlineResponse2002
     */
    status?: ApiV1ExplorerAddressStatus;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    timestamp?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    lastReceived?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    lastSent?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    outgoing?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    mirror?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    listenPort?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    isTrustedPeer?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    connectedAt?: number;
    /**
     * 
     * @type {InlineResponse2003UnconfirmedVerifyTransaction}
     * @memberof InlineResponse2003
     */
    unconfirmedVerifyTransaction?: InlineResponse2003UnconfirmedVerifyTransaction;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    state?: InlineResponse2003.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    userAgent?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    height?: number;
}

/**
 * @export
 * @namespace InlineResponse2003
 */
export namespace InlineResponse2003 {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Pending = 'pending',
        Connected = 'connected',
        Introduced = 'introduced'
    }
}

/**
 * Represent unconfirmed transactions
 * @export
 * @interface InlineResponse2003UnconfirmedVerifyTransaction
 */
export interface InlineResponse2003UnconfirmedVerifyTransaction {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003UnconfirmedVerifyTransaction
     */
    burnFactor?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003UnconfirmedVerifyTransaction
     */
    maxTransactionSize?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003UnconfirmedVerifyTransaction
     */
    maxDecimals?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    announced?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004
     */
    isValid?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    checked?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    received?: string;
    /**
     * 
     * @type {ApiV1PendingTxsTransaction}
     * @memberof InlineResponse2004
     */
    transaction?: ApiV1PendingTxsTransaction;
}

/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<ApiV1WalletsEntries>}
     * @memberof InlineResponse2005
     */
    entries?: Array<ApiV1WalletsEntries>;
    /**
     * 
     * @type {ApiV1WalletsMeta}
     * @memberof InlineResponse2005
     */
    meta?: ApiV1WalletsMeta;
}

/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    address?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {InlineResponse2007Data}
     * @memberof InlineResponse2007
     */
    data?: InlineResponse2007Data;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse2007
     */
    error?: any;
}

/**
 * 
 * @export
 * @interface InlineResponse2007Data
 */
export interface InlineResponse2007Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007Data
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    message?: string;
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/addresscount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts(address: string, options: any = {}): RequestArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling addressUxouts.');
            }
            const localVarPath = `/api/v1/address_uxouts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(addrs: string, options: any = {}): RequestArgs {
            // verify required parameter 'addrs' is not null or undefined
            if (addrs === null || addrs === undefined) {
                throw new RequiredError('addrs','Required parameter addrs was null or undefined when calling balanceGet.');
            }
            const localVarPath = `/api/v1/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost(addrs: string, options: any = {}): RequestArgs {
            // verify required parameter 'addrs' is not null or undefined
            if (addrs === null || addrs === undefined) {
                throw new RequiredError('addrs','Required parameter addrs was null or undefined when calling balancePost.');
            }
            const localVarPath = `/api/v1/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a block by hash or seq. Note: only one of hash or seq is allowed
         * @param {string} [hash] 
         * @param {number} [seq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(hash?: string, seq?: number, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/block`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (seq !== undefined) {
                localVarQueryParameter['seq'] = seq;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/blockchain/metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/blockchain/progress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
         * @summary blocksHandler returns blocks between a start and end point,
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {Array<number>} [seqs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksGet(start?: number, end?: number, seqs?: Array<number>, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/blocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (seqs) {
                localVarQueryParameter['seqs'] = seqs.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
         * @summary blocksHandler returns blocks between a start and end point,
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {Array<number>} [seqs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksPost(start?: number, end?: number, seqs?: Array<number>, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/blocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (seqs) {
                localVarQueryParameter['seqs'] = seqs.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/coinSupply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/csrf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/defaultConnections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions (confirmed and unconfirmed) for an address
         * @param {string} [address] tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAddress(address?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/explorer/address`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks(num: number, options: any = {}): RequestArgs {
            // verify required parameter 'num' is not null or undefined
            if (num === null || num === undefined) {
                throw new RequiredError('num','Required parameter num was null or undefined when calling lastBlocks.');
            }
            const localVarPath = `/api/v1/last_blocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (num !== undefined) {
                localVarQueryParameter['num'] = num;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection(addr: string, options: any = {}): RequestArgs {
            // verify required parameter 'addr' is not null or undefined
            if (addr === null || addr === undefined) {
                throw new RequiredError('addr','Required parameter addr was null or undefined when calling networkConnection.');
            }
            const localVarPath = `/api/v1/network/connection`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addr !== undefined) {
                localVarQueryParameter['addr'] = addr;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/connections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling networkConnectionsDisconnect.');
            }
            const localVarPath = `/api/v1/network/connection/disconnect`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/connections/exchange`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/connections/trust`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address] 
         * @param {Array<string>} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet(address?: Array<string>, hash?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/outputs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address) {
                localVarQueryParameter['address'] = address.join(COLLECTION_FORMATS["csv"]);
            }

            if (hash) {
                localVarQueryParameter['hash'] = hash.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost(address?: string, hash?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/outputs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns pending (unconfirmed) transactions without verbose
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/pendingTxs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/resendUnconfirmedTxns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist(includeDistribution?: boolean, n?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/richlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeDistribution !== undefined) {
                localVarQueryParameter['include-distribution'] = includeDistribution;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction hash
         * @param {boolean} [encoded] return as a raw encoded transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction(txid: string, encoded?: boolean, options: any = {}): RequestArgs {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling transaction.');
            }
            const localVarPath = `/api/v1/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (encoded !== undefined) {
                localVarQueryParameter['encoded'] = encoded;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject(rawtx: string, options: any = {}): RequestArgs {
            // verify required parameter 'rawtx' is not null or undefined
            if (rawtx === null || rawtx === undefined) {
                throw new RequiredError('rawtx','Required parameter rawtx was null or undefined when calling transactionInject.');
            }
            const localVarPath = `/api/v2/transaction/inject`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (rawtx !== undefined && rawtx !== null) {
                localVarHeaderParameter['rawtx'] = String(rawtx);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw(txid?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/transaction/raw`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Decode and verify an encoded transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify(options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/transaction/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(addrs?: string, confirmed?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            if (confirmed !== undefined) {
                localVarQueryParameter['confirmed'] = confirmed;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost(addrs?: string, confirmed?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            if (confirmed !== undefined) {
                localVarQueryParameter['confirmed'] = confirmed;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout(uxid?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/uxout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uxid !== undefined) {
                localVarQueryParameter['uxid'] = uxid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies a Skycoin address.
         * @param {string} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress(address: string, options: any = {}): RequestArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling verifyAddress.');
            }
            const localVarPath = `/api/v2/address/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling wallet.');
            }
            const localVarPath = `/api/v1/wallet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletBalance.');
            }
            const localVarPath = `/api/v1/wallet/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options: any = {}): RequestArgs {
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed','Required parameter seed was null or undefined when calling walletCreate.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling walletCreate.');
            }
            const localVarPath = `/api/v1/wallet/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }

            if (label !== undefined && label !== null) {
                localVarHeaderParameter['label'] = String(label);
            }

            if (scan !== undefined && scan !== null) {
                localVarHeaderParameter['scan'] = String(scan);
            }

            if (encrypt !== undefined && encrypt !== null) {
                localVarHeaderParameter['encrypt'] = String(encrypt);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt(id: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletDecrypt.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling walletDecrypt.');
            }
            const localVarPath = `/api/v1/wallet/decrypt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt(id: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletEncrypt.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling walletEncrypt.');
            }
            const localVarPath = `/api/v1/wallet/encrypt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder(addr: string, options: any = {}): RequestArgs {
            // verify required parameter 'addr' is not null or undefined
            if (addr === null || addr === undefined) {
                throw new RequiredError('addr','Required parameter addr was null or undefined when calling walletFolder.');
            }
            const localVarPath = `/api/v1/wallets/folderName`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addr !== undefined) {
                localVarQueryParameter['addr'] = addr;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress(id: string, num?: string, password?: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletNewAddress.');
            }
            const localVarPath = `/api/v1/wallet/newAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (num !== undefined) {
                localVarQueryParameter['num'] = num;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed(entropy?: '128' | '256', options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/wallet/newSeed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entropy !== undefined) {
                localVarQueryParameter['entropy'] = entropy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover(id: string, seed: string, password?: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletRecover.');
            }
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed','Required parameter seed was null or undefined when calling walletRecover.');
            }
            const localVarPath = `/api/v2/wallet/recover`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed(id: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletSeed.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling walletSeed.');
            }
            const localVarPath = `/api/v1/wallet/seed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify(seed?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/wallet/seed/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
         * @param {string} id Wallet id
         * @param {string} dst Recipient address
         * @param {string} coins Number of coins to spend, in droplets. 1 coin equals 1e6 droplets.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSpent(id: string, dst: string, coins: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletSpent.');
            }
            // verify required parameter 'dst' is not null or undefined
            if (dst === null || dst === undefined) {
                throw new RequiredError('dst','Required parameter dst was null or undefined when calling walletSpent.');
            }
            // verify required parameter 'coins' is not null or undefined
            if (coins === null || coins === undefined) {
                throw new RequiredError('coins','Required parameter coins was null or undefined when calling walletSpent.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling walletSpent.');
            }
            const localVarPath = `/api/v1/wallet/spend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (dst !== undefined && dst !== null) {
                localVarHeaderParameter['dst'] = String(dst);
            }

            if (coins !== undefined && coins !== null) {
                localVarHeaderParameter['coins'] = String(coins);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a signed transaction
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction(body: InlineObject, options: any = {}): RequestArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling walletTransaction.');
            }
            const localVarPath = `/api/v1/wallet/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InlineObject" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
         * @param {string} id Wallet id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletTransactions.');
            }
            const localVarPath = `/api/v1/wallet/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletUnload.');
            }
            const localVarPath = `/api/v1/wallet/unload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate(id: string, label: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletUpdate.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling walletUpdate.');
            }
            const localVarPath = `/api/v1/wallet/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (label !== undefined && label !== null) {
                localVarHeaderParameter['label'] = String(label);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).addressCount(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts(address: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse200>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).addressUxouts(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(addrs: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).balanceGet(addrs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost(addrs: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).balancePost(addrs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns a block by hash or seq. Note: only one of hash or seq is allowed
         * @param {string} [hash] 
         * @param {number} [seq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(hash?: string, seq?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).block(hash, seq, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).blockchainMetadata(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).blockchainProgress(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
         * @summary blocksHandler returns blocks between a start and end point,
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {Array<number>} [seqs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksGet(start?: number, end?: number, seqs?: Array<number>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).blocksGet(start, end, seqs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
         * @summary blocksHandler returns blocks between a start and end point,
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {Array<number>} [seqs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksPost(start?: number, end?: number, seqs?: Array<number>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).blocksPost(start, end, seqs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).coinSupply(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).csrf(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).defaultConnections(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns all transactions (confirmed and unconfirmed) for an address
         * @param {string} [address] tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAddress(address?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2002>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).explorerAddress(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).health(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks(num: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).lastBlocks(num, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection(addr: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnection(addr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2003>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnections(states, direction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnectionsDisconnect(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnectionsExchange(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnectionsTrust(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address] 
         * @param {Array<string>} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet(address?: Array<string>, hash?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).outputsGet(address, hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost(address?: string, hash?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).outputsPost(address, hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns pending (unconfirmed) transactions without verbose
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).pendingTxs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).resendUnconfirmedTxns(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist(includeDistribution?: boolean, n?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).richlist(includeDistribution, n, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction hash
         * @param {boolean} [encoded] return as a raw encoded transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction(txid: string, encoded?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transaction(txid, encoded, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject(rawtx: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionInject(rawtx, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw(txid?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionRaw(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Decode and verify an encoded transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionVerify(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(addrs?: string, confirmed?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionsGet(addrs, confirmed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost(addrs?: string, confirmed?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionsPost(addrs, confirmed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout(uxid?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).uxout(uxid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Verifies a Skycoin address.
         * @param {string} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress(address: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).verifyAddress(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).version(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).wallet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletBalance(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletCreate(seed, label, scan, encrypt, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt(id: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletDecrypt(id, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt(id: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletEncrypt(id, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder(addr: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletFolder(addr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress(id: string, num?: string, password?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletNewAddress(id, num, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed(entropy?: '128' | '256', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletNewSeed(entropy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover(id: string, seed: string, password?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletRecover(id, seed, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed(id: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletSeed(id, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify(seed?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletSeedVerify(seed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
         * @param {string} id Wallet id
         * @param {string} dst Recipient address
         * @param {string} coins Number of coins to spend, in droplets. 1 coin equals 1e6 droplets.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSpent(id: string, dst: string, coins: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletSpent(id, dst, coins, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Creates a signed transaction
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction(body: InlineObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletTransaction(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
         * @param {string} id Wallet id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletTransactions(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletUnload(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate(id: string, label: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletUpdate(id, label, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2005>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).wallets(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount(options?: any) {
            return DefaultApiFp(configuration).addressCount(options)(axios, basePath);
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts(address: string, options?: any) {
            return DefaultApiFp(configuration).addressUxouts(address, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(addrs: string, options?: any) {
            return DefaultApiFp(configuration).balanceGet(addrs, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost(addrs: string, options?: any) {
            return DefaultApiFp(configuration).balancePost(addrs, options)(axios, basePath);
        },
        /**
         * Returns a block by hash or seq. Note: only one of hash or seq is allowed
         * @param {string} [hash] 
         * @param {number} [seq] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(hash?: string, seq?: number, options?: any) {
            return DefaultApiFp(configuration).block(hash, seq, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata(options?: any) {
            return DefaultApiFp(configuration).blockchainMetadata(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress(options?: any) {
            return DefaultApiFp(configuration).blockchainProgress(options)(axios, basePath);
        },
        /**
         * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
         * @summary blocksHandler returns blocks between a start and end point,
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {Array<number>} [seqs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksGet(start?: number, end?: number, seqs?: Array<number>, options?: any) {
            return DefaultApiFp(configuration).blocksGet(start, end, seqs, options)(axios, basePath);
        },
        /**
         * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
         * @summary blocksHandler returns blocks between a start and end point,
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {Array<number>} [seqs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksPost(start?: number, end?: number, seqs?: Array<number>, options?: any) {
            return DefaultApiFp(configuration).blocksPost(start, end, seqs, options)(axios, basePath);
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply(options?: any) {
            return DefaultApiFp(configuration).coinSupply(options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf(options?: any) {
            return DefaultApiFp(configuration).csrf(options)(axios, basePath);
        },
        /**
         * 
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections(options?: any) {
            return DefaultApiFp(configuration).defaultConnections(options)(axios, basePath);
        },
        /**
         * Returns all transactions (confirmed and unconfirmed) for an address
         * @param {string} [address] tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explorerAddress(address?: string, options?: any) {
            return DefaultApiFp(configuration).explorerAddress(address, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any) {
            return DefaultApiFp(configuration).health(options)(axios, basePath);
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks(num: number, options?: any) {
            return DefaultApiFp(configuration).lastBlocks(num, options)(axios, basePath);
        },
        /**
         * 
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection(addr: string, options?: any) {
            return DefaultApiFp(configuration).networkConnection(addr, options)(axios, basePath);
        },
        /**
         * 
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options?: any) {
            return DefaultApiFp(configuration).networkConnections(states, direction, options)(axios, basePath);
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect(id: string, options?: any) {
            return DefaultApiFp(configuration).networkConnectionsDisconnect(id, options)(axios, basePath);
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange(options?: any) {
            return DefaultApiFp(configuration).networkConnectionsExchange(options)(axios, basePath);
        },
        /**
         * 
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust(options?: any) {
            return DefaultApiFp(configuration).networkConnectionsTrust(options)(axios, basePath);
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address] 
         * @param {Array<string>} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet(address?: Array<string>, hash?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).outputsGet(address, hash, options)(axios, basePath);
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost(address?: string, hash?: string, options?: any) {
            return DefaultApiFp(configuration).outputsPost(address, hash, options)(axios, basePath);
        },
        /**
         * Returns pending (unconfirmed) transactions without verbose
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs(options?: any) {
            return DefaultApiFp(configuration).pendingTxs(options)(axios, basePath);
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns(options?: any) {
            return DefaultApiFp(configuration).resendUnconfirmedTxns(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist(includeDistribution?: boolean, n?: string, options?: any) {
            return DefaultApiFp(configuration).richlist(includeDistribution, n, options)(axios, basePath);
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction hash
         * @param {boolean} [encoded] return as a raw encoded transaction.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction(txid: string, encoded?: boolean, options?: any) {
            return DefaultApiFp(configuration).transaction(txid, encoded, options)(axios, basePath);
        },
        /**
         * 
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject(rawtx: string, options?: any) {
            return DefaultApiFp(configuration).transactionInject(rawtx, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw(txid?: string, options?: any) {
            return DefaultApiFp(configuration).transactionRaw(txid, options)(axios, basePath);
        },
        /**
         * Decode and verify an encoded transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify(options?: any) {
            return DefaultApiFp(configuration).transactionVerify(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(addrs?: string, confirmed?: string, options?: any) {
            return DefaultApiFp(configuration).transactionsGet(addrs, confirmed, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost(addrs?: string, confirmed?: string, options?: any) {
            return DefaultApiFp(configuration).transactionsPost(addrs, confirmed, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout(uxid?: string, options?: any) {
            return DefaultApiFp(configuration).uxout(uxid, options)(axios, basePath);
        },
        /**
         * 
         * @summary Verifies a Skycoin address.
         * @param {string} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress(address: string, options?: any) {
            return DefaultApiFp(configuration).verifyAddress(address, options)(axios, basePath);
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any) {
            return DefaultApiFp(configuration).version(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet(id: string, options?: any) {
            return DefaultApiFp(configuration).wallet(id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance(id: string, options?: any) {
            return DefaultApiFp(configuration).walletBalance(id, options)(axios, basePath);
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options?: any) {
            return DefaultApiFp(configuration).walletCreate(seed, label, scan, encrypt, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt(id: string, password: string, options?: any) {
            return DefaultApiFp(configuration).walletDecrypt(id, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt(id: string, password: string, options?: any) {
            return DefaultApiFp(configuration).walletEncrypt(id, password, options)(axios, basePath);
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder(addr: string, options?: any) {
            return DefaultApiFp(configuration).walletFolder(addr, options)(axios, basePath);
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress(id: string, num?: string, password?: string, options?: any) {
            return DefaultApiFp(configuration).walletNewAddress(id, num, password, options)(axios, basePath);
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed(entropy?: '128' | '256', options?: any) {
            return DefaultApiFp(configuration).walletNewSeed(entropy, options)(axios, basePath);
        },
        /**
         * 
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover(id: string, seed: string, password?: string, options?: any) {
            return DefaultApiFp(configuration).walletRecover(id, seed, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed(id: string, password: string, options?: any) {
            return DefaultApiFp(configuration).walletSeed(id, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify(seed?: string, options?: any) {
            return DefaultApiFp(configuration).walletSeedVerify(seed, options)(axios, basePath);
        },
        /**
         * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
         * @param {string} id Wallet id
         * @param {string} dst Recipient address
         * @param {string} coins Number of coins to spend, in droplets. 1 coin equals 1e6 droplets.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSpent(id: string, dst: string, coins: string, password: string, options?: any) {
            return DefaultApiFp(configuration).walletSpent(id, dst, coins, password, options)(axios, basePath);
        },
        /**
         * Creates a signed transaction
         * @param {InlineObject} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction(body: InlineObject, options?: any) {
            return DefaultApiFp(configuration).walletTransaction(body, options)(axios, basePath);
        },
        /**
         * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
         * @param {string} id Wallet id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions(id: string, options?: any) {
            return DefaultApiFp(configuration).walletTransactions(id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload(id: string, options?: any) {
            return DefaultApiFp(configuration).walletUnload(id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate(id: string, label: string, options?: any) {
            return DefaultApiFp(configuration).walletUpdate(id, label, options)(axios, basePath);
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets(options?: any) {
            return DefaultApiFp(configuration).wallets(options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Returns the total number of unique address that have coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addressCount(options?: any) {
        return DefaultApiFp(this.configuration).addressCount(options)(this.axios, this.basePath);
    }

    /**
     * Returns the historical, spent outputs associated with an address
     * @param {string} address address to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addressUxouts(address: string, options?: any) {
        return DefaultApiFp(this.configuration).addressUxouts(address, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} addrs command separated list of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public balanceGet(addrs: string, options?: any) {
        return DefaultApiFp(this.configuration).balanceGet(addrs, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} addrs command separated list of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public balancePost(addrs: string, options?: any) {
        return DefaultApiFp(this.configuration).balancePost(addrs, options)(this.axios, this.basePath);
    }

    /**
     * Returns a block by hash or seq. Note: only one of hash or seq is allowed
     * @param {string} [hash] 
     * @param {number} [seq] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public block(hash?: string, seq?: number, options?: any) {
        return DefaultApiFp(this.configuration).block(hash, seq, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the blockchain metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blockchainMetadata(options?: any) {
        return DefaultApiFp(this.configuration).blockchainMetadata(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the blockchain sync progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blockchainProgress(options?: any) {
        return DefaultApiFp(this.configuration).blockchainProgress(options)(this.axios, this.basePath);
    }

    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
     * @summary blocksHandler returns blocks between a start and end point,
     * @param {number} [start] 
     * @param {number} [end] 
     * @param {Array<number>} [seqs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blocksGet(start?: number, end?: number, seqs?: Array<number>, options?: any) {
        return DefaultApiFp(this.configuration).blocksGet(start, end, seqs, options)(this.axios, this.basePath);
    }

    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
     * @summary blocksHandler returns blocks between a start and end point,
     * @param {number} [start] 
     * @param {number} [end] 
     * @param {Array<number>} [seqs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blocksPost(start?: number, end?: number, seqs?: Array<number>, options?: any) {
        return DefaultApiFp(this.configuration).blocksPost(start, end, seqs, options)(this.axios, this.basePath);
    }

    /**
     * coinSupplyHandler returns coin distribution supply stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public coinSupply(options?: any) {
        return DefaultApiFp(this.configuration).coinSupply(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public csrf(options?: any) {
        return DefaultApiFp(this.configuration).csrf(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public defaultConnections(options?: any) {
        return DefaultApiFp(this.configuration).defaultConnections(options)(this.axios, this.basePath);
    }

    /**
     * Returns all transactions (confirmed and unconfirmed) for an address
     * @param {string} [address] tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public explorerAddress(address?: string, options?: any) {
        return DefaultApiFp(this.configuration).explorerAddress(address, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns node health data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public health(options?: any) {
        return DefaultApiFp(this.configuration).health(options)(this.axios, this.basePath);
    }

    /**
     * Returns the most recent N blocks on the blockchain
     * @param {number} num 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lastBlocks(num: number, options?: any) {
        return DefaultApiFp(this.configuration).lastBlocks(num, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary This endpoint returns a specific connection.
     * @param {string} addr Address port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnection(addr: string, options?: any) {
        return DefaultApiFp(this.configuration).networkConnection(addr, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary This endpoint returns all outgoings connections.
     * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
     * @param {'connected' | 'introduced'} [direction] Direction of the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options?: any) {
        return DefaultApiFp(this.configuration).networkConnections(states, direction, options)(this.axios, this.basePath);
    }

    /**
     * This endpoint disconnects a connection by ID or address
     * @param {string} id Address id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnectionsDisconnect(id: string, options?: any) {
        return DefaultApiFp(this.configuration).networkConnectionsDisconnect(id, options)(this.axios, this.basePath);
    }

    /**
     * This endpoint returns all connections found through peer exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnectionsExchange(options?: any) {
        return DefaultApiFp(this.configuration).networkConnectionsExchange(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnectionsTrust(options?: any) {
        return DefaultApiFp(this.configuration).networkConnectionsTrust(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param {Array<string>} [address] 
     * @param {Array<string>} [hash] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public outputsGet(address?: Array<string>, hash?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).outputsGet(address, hash, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param {string} [address] 
     * @param {string} [hash] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public outputsPost(address?: string, hash?: string, options?: any) {
        return DefaultApiFp(this.configuration).outputsPost(address, hash, options)(this.axios, this.basePath);
    }

    /**
     * Returns pending (unconfirmed) transactions without verbose
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pendingTxs(options?: any) {
        return DefaultApiFp(this.configuration).pendingTxs(options)(this.axios, this.basePath);
    }

    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resendUnconfirmedTxns(options?: any) {
        return DefaultApiFp(this.configuration).resendUnconfirmedTxns(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the top skycoin holders.
     * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
     * @param {string} [n] include distribution addresses or not, default value false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public richlist(includeDistribution?: boolean, n?: string, options?: any) {
        return DefaultApiFp(this.configuration).richlist(includeDistribution, n, options)(this.axios, this.basePath);
    }

    /**
     * Returns a transaction identified by its txid hash with just id
     * @param {string} txid transaction hash
     * @param {boolean} [encoded] return as a raw encoded transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transaction(txid: string, encoded?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).transaction(txid, encoded, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Broadcast a hex-encoded, serialized transaction to the network.
     * @param {string} rawtx hex-encoded serialized transaction string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionInject(rawtx: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionInject(rawtx, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * @param {string} [txid] Transaction id hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionRaw(txid?: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionRaw(txid, options)(this.axios, this.basePath);
    }

    /**
     * Decode and verify an encoded transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionVerify(options?: any) {
        return DefaultApiFp(this.configuration).transactionVerify(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param {string} [addrs] command separated list of addresses
     * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionsGet(addrs?: string, confirmed?: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionsGet(addrs, confirmed, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param {string} [addrs] command separated list of addresses
     * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionsPost(addrs?: string, confirmed?: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionsPost(addrs, confirmed, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns an unspent output by ID.
     * @param {string} [uxid] uxid to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uxout(uxid?: string, options?: any) {
        return DefaultApiFp(this.configuration).uxout(uxid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Verifies a Skycoin address.
     * @param {string} address Address id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifyAddress(address: string, options?: any) {
        return DefaultApiFp(this.configuration).verifyAddress(address, options)(this.axios, this.basePath);
    }

    /**
     * versionHandler returns the application version info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public version(options?: any) {
        return DefaultApiFp(this.configuration).version(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns a wallet by id.
     * @param {string} id tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public wallet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).wallet(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} id tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletBalance(id: string, options?: any) {
        return DefaultApiFp(this.configuration).walletBalance(id, options)(this.axios, this.basePath);
    }

    /**
     * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
     * @param {string} seed Wallet seed.
     * @param {string} label Wallet label.
     * @param {number} [scan] The number of addresses to scan ahead for balances.
     * @param {boolean} [encrypt] Encrypt wallet.
     * @param {string} [password] Wallet Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletCreate(seed, label, scan, encrypt, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Decrypts wallet.
     * @param {string} id Wallet id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletDecrypt(id: string, password: string, options?: any) {
        return DefaultApiFp(this.configuration).walletDecrypt(id, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Encrypt wallet.
     * @param {string} id Wallet id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletEncrypt(id: string, password: string, options?: any) {
        return DefaultApiFp(this.configuration).walletEncrypt(id, password, options)(this.axios, this.basePath);
    }

    /**
     * Returns the wallet directory path
     * @param {string} addr Address port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletFolder(addr: string, options?: any) {
        return DefaultApiFp(this.configuration).walletFolder(addr, options)(this.axios, this.basePath);
    }

    /**
     * Generates new addresses
     * @param {string} id Wallet Id
     * @param {string} [num] The number you want to generate
     * @param {string} [password] Wallet Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletNewAddress(id: string, num?: string, password?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletNewAddress(id, num, password, options)(this.axios, this.basePath);
    }

    /**
     * Returns the wallet directory path
     * @param {'128' | '256'} [entropy] Entropy bitSize.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletNewSeed(entropy?: '128' | '256', options?: any) {
        return DefaultApiFp(this.configuration).walletNewSeed(entropy, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * @param {string} id Wallet id.
     * @param {string} seed Wallet seed.
     * @param {string} [password] Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletRecover(id: string, seed: string, password?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletRecover(id, seed, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * @param {string} id Wallet Id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletSeed(id: string, password: string, options?: any) {
        return DefaultApiFp(this.configuration).walletSeed(id, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Verifies a wallet seed.
     * @param {string} [seed] Seed to be verified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletSeedVerify(seed?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletSeedVerify(seed, options)(this.axios, this.basePath);
    }

    /**
     * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
     * @param {string} id Wallet id
     * @param {string} dst Recipient address
     * @param {string} coins Number of coins to spend, in droplets. 1 coin equals 1e6 droplets.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletSpent(id: string, dst: string, coins: string, password: string, options?: any) {
        return DefaultApiFp(this.configuration).walletSpent(id, dst, coins, password, options)(this.axios, this.basePath);
    }

    /**
     * Creates a signed transaction
     * @param {InlineObject} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletTransaction(body: InlineObject, options?: any) {
        return DefaultApiFp(this.configuration).walletTransaction(body, options)(this.axios, this.basePath);
    }

    /**
     * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
     * @param {string} id Wallet id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletTransactions(id: string, options?: any) {
        return DefaultApiFp(this.configuration).walletTransactions(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Unloads wallet from the wallet service.
     * @param {string} id Wallet Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletUnload(id: string, options?: any) {
        return DefaultApiFp(this.configuration).walletUnload(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the wallet.
     * @param {string} id Wallet Id.
     * @param {string} label The label the wallet will be updated to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletUpdate(id: string, label: string, options?: any) {
        return DefaultApiFp(this.configuration).walletUpdate(id, label, options)(this.axios, this.basePath);
    }

    /**
     * Returns all loaded wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public wallets(options?: any) {
        return DefaultApiFp(this.configuration).wallets(options)(this.axios, this.basePath);
    }

}

