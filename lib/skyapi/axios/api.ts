// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.26.0
 * Contact: contact@skycoin.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://127.0.0.1:6420".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    address: string;
}

/**
 * 
 * @export
 * @interface ApiV1PendingTxsTransaction
 */
export interface ApiV1PendingTxsTransaction {
    /**
     * 
     * @type {number}
     * @memberof ApiV1PendingTxsTransaction
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiV1PendingTxsTransaction
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PendingTxsTransaction
     */
    txid?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PendingTxsTransaction
     */
    innerHash?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1PendingTxsTransaction
     */
    sigs?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1PendingTxsTransaction
     */
    inputs?: Array<string>;
    /**
     * 
     * @type {Array<ApiV1PendingTxsTransactionOutputs>}
     * @memberof ApiV1PendingTxsTransaction
     */
    outputs?: Array<ApiV1PendingTxsTransactionOutputs>;
}

/**
 * 
 * @export
 * @interface ApiV1PendingTxsTransactionOutputs
 */
export interface ApiV1PendingTxsTransactionOutputs {
    /**
     * 
     * @type {string}
     * @memberof ApiV1PendingTxsTransactionOutputs
     */
    uxid?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PendingTxsTransactionOutputs
     */
    dst?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PendingTxsTransactionOutputs
     */
    coins?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1PendingTxsTransactionOutputs
     */
    hours?: number;
}

/**
 * 
 * @export
 * @interface BlockSchema
 */
export interface BlockSchema {
    /**
     * 
     * @type {BlockVerboseSchemaHeader}
     * @memberof BlockSchema
     */
    header?: BlockVerboseSchemaHeader;
    /**
     * 
     * @type {BlockSchemaBody}
     * @memberof BlockSchema
     */
    body?: BlockSchemaBody;
    /**
     * 
     * @type {number}
     * @memberof BlockSchema
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface BlockSchemaBody
 */
export interface BlockSchemaBody {
    /**
     * 
     * @type {Array<any>}
     * @memberof BlockSchemaBody
     */
    txns?: Array<any>;
}

/**
 * 
 * @export
 * @interface BlockVerboseSchema
 */
export interface BlockVerboseSchema {
    /**
     * 
     * @type {BlockVerboseSchemaHeader}
     * @memberof BlockVerboseSchema
     */
    header?: BlockVerboseSchemaHeader;
    /**
     * 
     * @type {BlockVerboseSchemaBody}
     * @memberof BlockVerboseSchema
     */
    body?: BlockVerboseSchemaBody;
    /**
     * 
     * @type {number}
     * @memberof BlockVerboseSchema
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface BlockVerboseSchemaBody
 */
export interface BlockVerboseSchemaBody {
    /**
     * 
     * @type {Array<any>}
     * @memberof BlockVerboseSchemaBody
     */
    txns?: Array<any>;
}

/**
 * 
 * @export
 * @interface BlockVerboseSchemaHeader
 */
export interface BlockVerboseSchemaHeader {
    /**
     * 
     * @type {number}
     * @memberof BlockVerboseSchemaHeader
     */
    seq?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockVerboseSchemaHeader
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockVerboseSchemaHeader
     */
    fee?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockVerboseSchemaHeader
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof BlockVerboseSchemaHeader
     */
    blockHash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockVerboseSchemaHeader
     */
    previousBlockHash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockVerboseSchemaHeader
     */
    txBodyHash?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockVerboseSchemaHeader
     */
    uxHash?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count?: number;
}

/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<BlockSchema>}
     * @memberof InlineResponse2001
     */
    blocks?: Array<BlockSchema>;
}

/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {ApiV1PendingTxsTransaction}
     * @memberof InlineResponse20010
     */
    transaction?: ApiV1PendingTxsTransaction;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    received?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    checked?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    announced?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20010
     */
    isValid?: boolean;
}

/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * CurrentCoinHourSupply is coins hours in non distribution addresses.
     * @type {string}
     * @memberof InlineResponse2002
     */
    currentCoinhourSupply?: string;
    /**
     * Coins distributed beyond the project.
     * @type {string}
     * @memberof InlineResponse2002
     */
    currentSupply?: string;
    /**
     * Distribution addresses which are locked and do not count towards total supply.
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    lockedDistributionAddresses?: Array<string>;
    /**
     * MaxSupply is the maximum number of coins to be distributed ever.
     * @type {string}
     * @memberof InlineResponse2002
     */
    maxSupply?: string;
    /**
     * TotalCoinHourSupply is coin hours in all addresses including unlocked distribution addresses.
     * @type {string}
     * @memberof InlineResponse2002
     */
    totalCoinhourSupply?: string;
    /**
     * TotalSupply is CurrentSupply plus coins held by the distribution addresses that are spendable.
     * @type {string}
     * @memberof InlineResponse2002
     */
    totalSupply?: string;
    /**
     * Distribution addresses which count towards total supply.
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    unlockedDistributionAddresses?: Array<string>;
}

/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    csrfToken?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<NetworkConnectionSchema>}
     * @memberof InlineResponse2004
     */
    connections?: Array<NetworkConnectionSchema>;
}

/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * git branch name
     * @type {string}
     * @memberof InlineResponse2005
     */
    branch?: string;
    /**
     * git commit id
     * @type {string}
     * @memberof InlineResponse2005
     */
    commit?: string;
    /**
     * version number
     * @type {string}
     * @memberof InlineResponse2005
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Array<TransactionEncoded>}
     * @memberof InlineResponse2006
     */
    transactions?: Array<TransactionEncoded>;
}

/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    address?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {InlineResponse2008Data}
     * @memberof InlineResponse2008
     */
    data?: InlineResponse2008Data;
}

/**
 * 
 * @export
 * @interface InlineResponse2008Data
 */
export interface InlineResponse2008Data {
    /**
     * 
     * @type {Transaction}
     * @memberof InlineResponse2008Data
     */
    transaction?: Transaction;
}

/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {any}
     * @memberof InlineResponse2009
     */
    data?: any;
}

/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface NetworkConnectionSchema
 */
export interface NetworkConnectionSchema {
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionSchema
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchema
     */
    connectedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchema
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchema
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkConnectionSchema
     */
    isTrustedPeer?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchema
     */
    lastReceived?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchema
     */
    lastSent?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchema
     */
    listenPort?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchema
     */
    mirror?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkConnectionSchema
     */
    outgoing?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionSchema
     */
    state?: NetworkConnectionSchema.StateEnum;
    /**
     * 
     * @type {NetworkConnectionSchemaUnconfirmedVerifyTransaction}
     * @memberof NetworkConnectionSchema
     */
    unconfirmedVerifyTransaction?: NetworkConnectionSchemaUnconfirmedVerifyTransaction;
    /**
     * 
     * @type {string}
     * @memberof NetworkConnectionSchema
     */
    userAgent?: string;
}

/**
 * @export
 * @namespace NetworkConnectionSchema
 */
export namespace NetworkConnectionSchema {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Pending = 'pending',
        Connected = 'connected',
        Introduced = 'introduced'
    }
}

/**
 * Represent unconfirmed transactions
 * @export
 * @interface NetworkConnectionSchemaUnconfirmedVerifyTransaction
 */
export interface NetworkConnectionSchemaUnconfirmedVerifyTransaction {
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchemaUnconfirmedVerifyTransaction
     */
    burnFactor?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchemaUnconfirmedVerifyTransaction
     */
    maxDecimals?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkConnectionSchemaUnconfirmedVerifyTransaction
     */
    maxTransactionSize?: number;
}

/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {TransactionStatus}
     * @memberof Transaction
     */
    status?: TransactionStatus;
    /**
     * 
     * @type {TransactionTxn}
     * @memberof Transaction
     */
    txn?: TransactionTxn;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface TransactionEncoded
 */
export interface TransactionEncoded {
    /**
     * 
     * @type {ApiV1PendingTxsTransaction}
     * @memberof TransactionEncoded
     */
    transaction?: ApiV1PendingTxsTransaction;
    /**
     * 
     * @type {string}
     * @memberof TransactionEncoded
     */
    received?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionEncoded
     */
    checked?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionEncoded
     */
    announced?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionEncoded
     */
    isValid?: boolean;
}

/**
 * 
 * @export
 * @interface TransactionEncodedS
 */
export interface TransactionEncodedS {
    /**
     * 
     * @type {number}
     * @memberof TransactionEncodedS
     */
    time?: number;
    /**
     * 
     * @type {TransactionStatus}
     * @memberof TransactionEncodedS
     */
    status?: TransactionStatus;
    /**
     * 
     * @type {string}
     * @memberof TransactionEncodedS
     */
    encodedTransaction?: string;
}

/**
 * 
 * @export
 * @interface TransactionStatus
 */
export interface TransactionStatus {
    /**
     * If confirmed, the sequence of the block in which the transaction was executed
     * @type {number}
     * @memberof TransactionStatus
     */
    blockSeq?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionStatus
     */
    confirmed?: boolean;
    /**
     * If confirmed, how many blocks deep in the chain it is. Will be at least 1 if confirmed
     * @type {number}
     * @memberof TransactionStatus
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionStatus
     */
    unconfirmed?: boolean;
}

/**
 * TransactionVerbose has readable transaction data. It adds TransactionStatus to a BlockTransactionVerbose
 * @export
 * @interface TransactionTxn
 */
export interface TransactionTxn {
    /**
     * 
     * @type {string}
     * @memberof TransactionTxn
     */
    innerHash?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionTxn
     */
    inputs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TransactionTxn
     */
    length?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof TransactionTxn
     */
    outputs?: Array<any>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionTxn
     */
    sigs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TransactionTxn
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionTxn
     */
    txid?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionTxn
     */
    type?: number;
}

/**
 * 
 * @export
 * @interface TransactionV2ParamsAddress
 */
export interface TransactionV2ParamsAddress {
    /**
     * 
     * @type {TransactionV2ParamsAddressHoursSelection}
     * @memberof TransactionV2ParamsAddress
     */
    hoursSelection?: TransactionV2ParamsAddressHoursSelection;
}

/**
 * 
 * @export
 * @interface TransactionV2ParamsAddressHoursSelection
 */
export interface TransactionV2ParamsAddressHoursSelection {
    /**
     * 
     * @type {string}
     * @memberof TransactionV2ParamsAddressHoursSelection
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface TransactionV2ParamsUnspent
 */
export interface TransactionV2ParamsUnspent {
    /**
     * 
     * @type {TransactionV2ParamsUnspentHoursSelection}
     * @memberof TransactionV2ParamsUnspent
     */
    hoursSelection?: TransactionV2ParamsUnspentHoursSelection;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionV2ParamsUnspent
     */
    unspents?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionV2ParamsUnspent
     */
    changeAddress?: string;
    /**
     * 
     * @type {Array<TransactionV2ParamsUnspentTo>}
     * @memberof TransactionV2ParamsUnspent
     */
    to?: Array<TransactionV2ParamsUnspentTo>;
}

/**
 * 
 * @export
 * @interface TransactionV2ParamsUnspentHoursSelection
 */
export interface TransactionV2ParamsUnspentHoursSelection {
    /**
     * 
     * @type {string}
     * @memberof TransactionV2ParamsUnspentHoursSelection
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionV2ParamsUnspentHoursSelection
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionV2ParamsUnspentHoursSelection
     */
    shareFactor?: string;
}

/**
 * 
 * @export
 * @interface TransactionV2ParamsUnspentTo
 */
export interface TransactionV2ParamsUnspentTo {
    /**
     * 
     * @type {string}
     * @memberof TransactionV2ParamsUnspentTo
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionV2ParamsUnspentTo
     */
    coins?: string;
}

/**
 * 
 * @export
 * @interface TransactionVerbose
 */
export interface TransactionVerbose {
    /**
     * 
     * @type {number}
     * @memberof TransactionVerbose
     */
    time?: number;
    /**
     * 
     * @type {TransactionStatus}
     * @memberof TransactionVerbose
     */
    status?: TransactionStatus;
    /**
     * 
     * @type {TransactionVerboseTxn}
     * @memberof TransactionVerbose
     */
    txn?: TransactionVerboseTxn;
}

/**
 * TransactionVerbose has readable transaction data. It adds TransactionStatus to a BlockTransactionVerbose
 * @export
 * @interface TransactionVerboseTxn
 */
export interface TransactionVerboseTxn {
    /**
     * 
     * @type {TransactionStatus}
     * @memberof TransactionVerboseTxn
     */
    status?: TransactionStatus;
    /**
     * 
     * @type {number}
     * @memberof TransactionVerboseTxn
     */
    fee?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionVerboseTxn
     */
    innerHash?: string;
    /**
     * 
     * @type {Array<TransactionVerboseTxnInputs>}
     * @memberof TransactionVerboseTxn
     */
    inputs?: Array<TransactionVerboseTxnInputs>;
    /**
     * 
     * @type {number}
     * @memberof TransactionVerboseTxn
     */
    length?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof TransactionVerboseTxn
     */
    outputs?: Array<any>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionVerboseTxn
     */
    sigs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TransactionVerboseTxn
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionVerboseTxn
     */
    txid?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionVerboseTxn
     */
    type?: number;
}

/**
 * 
 * @export
 * @interface TransactionVerboseTxnInputs
 */
export interface TransactionVerboseTxnInputs {
    /**
     * 
     * @type {string}
     * @memberof TransactionVerboseTxnInputs
     */
    uxid?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionVerboseTxnInputs
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionVerboseTxnInputs
     */
    coins?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionVerboseTxnInputs
     */
    hours?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionVerboseTxnInputs
     */
    calculatedHours?: number;
}

/**
 * 
 * @export
 * @interface TransactionVerifyRequest
 */
export interface TransactionVerifyRequest {
    /**
     * 
     * @type {boolean}
     * @memberof TransactionVerifyRequest
     */
    unsigned?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionVerifyRequest
     */
    encodedTransaction?: string;
}

/**
 * 
 * @export
 * @interface WalletTransactionRequest
 */
export interface WalletTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionRequest
     */
    changeAddress?: string;
    /**
     * 
     * @type {WalletTransactionRequestHoursSelection}
     * @memberof WalletTransactionRequest
     */
    hoursSelection?: WalletTransactionRequestHoursSelection;
    /**
     * 
     * @type {boolean}
     * @memberof WalletTransactionRequest
     */
    ignoreUnconfirmed?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof WalletTransactionRequest
     */
    to?: Array<any>;
    /**
     * 
     * @type {WalletTransactionRequestWallet}
     * @memberof WalletTransactionRequest
     */
    wallet?: WalletTransactionRequestWallet;
}

/**
 * 
 * @export
 * @interface WalletTransactionRequestHoursSelection
 */
export interface WalletTransactionRequestHoursSelection {
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionRequestHoursSelection
     */
    mode?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionRequestHoursSelection
     */
    shareFactor?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionRequestHoursSelection
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface WalletTransactionRequestWallet
 */
export interface WalletTransactionRequestWallet {
    /**
     * 
     * @type {Array<string>}
     * @memberof WalletTransactionRequestWallet
     */
    addresses?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionRequestWallet
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionRequestWallet
     */
    password?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WalletTransactionRequestWallet
     */
    unspents?: Array<string>;
}

/**
 * 
 * @export
 * @interface WalletTransactionSignRequest
 */
export interface WalletTransactionSignRequest {
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionSignRequest
     */
    walletId?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionSignRequest
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletTransactionSignRequest
     */
    encodedTransaction?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof WalletTransactionSignRequest
     */
    signIndexes?: Array<number>;
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/addresscount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts(address: string, options: any = {}): RequestArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling addressUxouts.');
            }
            const localVarPath = `/api/v1/address_uxouts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RawtxGet(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/rawtx`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2MetricsGet(options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(addrs: string, options: any = {}): RequestArgs {
            // verify required parameter 'addrs' is not null or undefined
            if (addrs === null || addrs === undefined) {
                throw new RequiredError('addrs','Required parameter addrs was null or undefined when calling balanceGet.');
            }
            const localVarPath = `/api/v1/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost(addrs: string, options: any = {}): RequestArgs {
            // verify required parameter 'addrs' is not null or undefined
            if (addrs === null || addrs === undefined) {
                throw new RequiredError('addrs','Required parameter addrs was null or undefined when calling balancePost.');
            }
            const localVarPath = `/api/v1/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} [hash] get block by hash
         * @param {number} [seq] get block by sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(hash?: string, seq?: number, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/block`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (seq !== undefined) {
                localVarQueryParameter['seq'] = seq;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/blockchain/metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/blockchain/progress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {number} [start] start seq
         * @param {number} [end] end seq
         * @param {Array<number>} [seq] comma-separated list of block seqs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks(start?: number, end?: number, seq?: Array<number>, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/blocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (seq) {
                localVarQueryParameter['seq'] = seq;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/coinSupply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/csrf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataDELETE(type?: string, key?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined && type !== null) {
                localVarHeaderParameter['type'] = String(type);
            }

            if (key !== undefined && key !== null) {
                localVarHeaderParameter['key'] = String(key);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGET(type?: string, key?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined && type !== null) {
                localVarHeaderParameter['type'] = String(type);
            }

            if (key !== undefined && key !== null) {
                localVarHeaderParameter['key'] = String(key);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {string} [val] additional value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPOST(type?: string, key?: string, val?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/data`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined && type !== null) {
                localVarHeaderParameter['type'] = String(type);
            }

            if (key !== undefined && key !== null) {
                localVarHeaderParameter['key'] = String(key);
            }

            if (val !== undefined && val !== null) {
                localVarHeaderParameter['val'] = String(val);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/defaultConnections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num Num of blockss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks(num: number, options: any = {}): RequestArgs {
            // verify required parameter 'num' is not null or undefined
            if (num === null || num === undefined) {
                throw new RequiredError('num','Required parameter num was null or undefined when calling lastBlocks.');
            }
            const localVarPath = `/api/v1/last_blocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (num !== undefined) {
                localVarQueryParameter['num'] = num;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection(addr: string, options: any = {}): RequestArgs {
            // verify required parameter 'addr' is not null or undefined
            if (addr === null || addr === undefined) {
                throw new RequiredError('addr','Required parameter addr was null or undefined when calling networkConnection.');
            }
            const localVarPath = `/api/v1/network/connection`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addr !== undefined) {
                localVarQueryParameter['addr'] = addr;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/connections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling networkConnectionsDisconnect.');
            }
            const localVarPath = `/api/v1/network/connection/disconnect`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/connections/exchange`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/network/connections/trust`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address] 
         * @param {Array<string>} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet(address?: Array<string>, hash?: Array<string>, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/outputs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address) {
                localVarQueryParameter['address'] = address;
            }

            if (hash) {
                localVarQueryParameter['hash'] = hash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost(address?: string, hash?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/outputs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/pendingTxs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/resendUnconfirmedTxns`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist(includeDistribution?: boolean, n?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/richlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeDistribution !== undefined) {
                localVarQueryParameter['include-distribution'] = includeDistribution;
            }

            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction(txid: string, options: any = {}): RequestArgs {
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid','Required parameter txid was null or undefined when calling transaction.');
            }
            const localVarPath = `/api/v1/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject(rawtx: string, options: any = {}): RequestArgs {
            // verify required parameter 'rawtx' is not null or undefined
            if (rawtx === null || rawtx === undefined) {
                throw new RequiredError('rawtx','Required parameter rawtx was null or undefined when calling transactionInject.');
            }
            const localVarPath = `/api/v1/injectTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (rawtx !== undefined && rawtx !== null) {
                localVarHeaderParameter['rawtx'] = String(rawtx);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPost(transactionV2ParamsAddress?: TransactionV2ParamsAddress, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionV2ParamsAddress" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(transactionV2ParamsAddress || {}) : (transactionV2ParamsAddress || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPostUnspent(transactionV2ParamsUnspent: TransactionV2ParamsUnspent, options: any = {}): RequestArgs {
            // verify required parameter 'transactionV2ParamsUnspent' is not null or undefined
            if (transactionV2ParamsUnspent === null || transactionV2ParamsUnspent === undefined) {
                throw new RequiredError('transactionV2ParamsUnspent','Required parameter transactionV2ParamsUnspent was null or undefined when calling transactionPostUnspent.');
            }
            const localVarPath = `/api/v2/transaction/unspent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionV2ParamsUnspent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(transactionV2ParamsUnspent || {}) : (transactionV2ParamsUnspent || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw(txid?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/transaction/raw`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Decode and verify an encoded transaction
         * @param {TransactionVerifyRequest} transactionVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify(transactionVerifyRequest: TransactionVerifyRequest, options: any = {}): RequestArgs {
            // verify required parameter 'transactionVerifyRequest' is not null or undefined
            if (transactionVerifyRequest === null || transactionVerifyRequest === undefined) {
                throw new RequiredError('transactionVerifyRequest','Required parameter transactionVerifyRequest was null or undefined when calling transactionVerify.');
            }
            const localVarPath = `/api/v2/transaction/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionVerifyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(transactionVerifyRequest || {}) : (transactionVerifyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(addrs?: string, confirmed?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            if (confirmed !== undefined) {
                localVarQueryParameter['confirmed'] = confirmed;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost(addrs?: string, confirmed?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }

            if (confirmed !== undefined) {
                localVarQueryParameter['confirmed'] = confirmed;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout(uxid?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/uxout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uxid !== undefined) {
                localVarQueryParameter['uxid'] = uxid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies a Skycoin address.
         * @param {any} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress(address: any, options: any = {}): RequestArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling verifyAddress.');
            }
            const localVarPath = `/api/v2/address/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling wallet.');
            }
            const localVarPath = `/api/v1/wallet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletBalance.');
            }
            const localVarPath = `/api/v1/wallet/balance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options: any = {}): RequestArgs {
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed','Required parameter seed was null or undefined when calling walletCreate.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling walletCreate.');
            }
            const localVarPath = `/api/v1/wallet/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }

            if (label !== undefined && label !== null) {
                localVarHeaderParameter['label'] = String(label);
            }

            if (scan !== undefined && scan !== null) {
                localVarHeaderParameter['scan'] = String(scan);
            }

            if (encrypt !== undefined && encrypt !== null) {
                localVarHeaderParameter['encrypt'] = String(encrypt);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt(id: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletDecrypt.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling walletDecrypt.');
            }
            const localVarPath = `/api/v1/wallet/decrypt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt(id: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletEncrypt.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling walletEncrypt.');
            }
            const localVarPath = `/api/v1/wallet/encrypt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder(addr: string, options: any = {}): RequestArgs {
            // verify required parameter 'addr' is not null or undefined
            if (addr === null || addr === undefined) {
                throw new RequiredError('addr','Required parameter addr was null or undefined when calling walletFolder.');
            }
            const localVarPath = `/api/v1/wallets/folderName`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addr !== undefined) {
                localVarQueryParameter['addr'] = addr;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress(id: string, num?: string, password?: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletNewAddress.');
            }
            const localVarPath = `/api/v1/wallet/newAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (num !== undefined) {
                localVarQueryParameter['num'] = num;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed(entropy?: '128' | '256', options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/wallet/newSeed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entropy !== undefined) {
                localVarQueryParameter['entropy'] = entropy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover(id: string, seed: string, password?: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletRecover.');
            }
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed','Required parameter seed was null or undefined when calling walletRecover.');
            }
            const localVarPath = `/api/v2/wallet/recover`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }

            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed(id: string, password: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletSeed.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling walletSeed.');
            }
            const localVarPath = `/api/v1/wallet/seed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify(seed?: string, options: any = {}): RequestArgs {
            const localVarPath = `/api/v2/wallet/seed/verify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a signed transaction
         * @param {WalletTransactionRequest} walletTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction(walletTransactionRequest: WalletTransactionRequest, options: any = {}): RequestArgs {
            // verify required parameter 'walletTransactionRequest' is not null or undefined
            if (walletTransactionRequest === null || walletTransactionRequest === undefined) {
                throw new RequiredError('walletTransactionRequest','Required parameter walletTransactionRequest was null or undefined when calling walletTransaction.');
            }
            const localVarPath = `/api/v1/wallet/transaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WalletTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(walletTransactionRequest || {}) : (walletTransactionRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a signed transaction
         * @param {WalletTransactionSignRequest} walletTransactionSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionSign(walletTransactionSignRequest: WalletTransactionSignRequest, options: any = {}): RequestArgs {
            // verify required parameter 'walletTransactionSignRequest' is not null or undefined
            if (walletTransactionSignRequest === null || walletTransactionSignRequest === undefined) {
                throw new RequiredError('walletTransactionSignRequest','Required parameter walletTransactionSignRequest was null or undefined when calling walletTransactionSign.');
            }
            const localVarPath = `/api/v2/wallet/transaction/sign`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WalletTransactionSignRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(walletTransactionSignRequest || {}) : (walletTransactionSignRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletTransactions.');
            }
            const localVarPath = `/api/v1/wallet/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload(id: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletUnload.');
            }
            const localVarPath = `/api/v1/wallet/unload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate(id: string, label: string, options: any = {}): RequestArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling walletUpdate.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label','Required parameter label was null or undefined when calling walletUpdate.');
            }
            const localVarPath = `/api/v1/wallet/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-CSRF-TOKEN")
					: configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }

            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }

            if (label !== undefined && label !== null) {
                localVarHeaderParameter['label'] = String(label);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets(options: any = {}): RequestArgs {
            const localVarPath = `/api/v1/wallets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).addressCount(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts(address: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).addressUxouts(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RawtxGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).apiV1RawtxGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2MetricsGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).apiV2MetricsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(addrs: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).balanceGet(addrs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost(addrs: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).balancePost(addrs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} [hash] get block by hash
         * @param {number} [seq] get block by sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(hash?: string, seq?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockSchema>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).block(hash, seq, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).blockchainMetadata(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).blockchainProgress(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {number} [start] start seq
         * @param {number} [end] end seq
         * @param {Array<number>} [seq] comma-separated list of block seqs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks(start?: number, end?: number, seq?: Array<number>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).blocks(start, end, seq, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).coinSupply(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).csrf(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataDELETE(type?: string, key?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).dataDELETE(type, key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGET(type?: string, key?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).dataGET(type, key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {string} [val] additional value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPOST(type?: string, key?: string, val?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).dataPOST(type, key, val, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).defaultConnections(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).health(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num Num of blockss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks(num: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).lastBlocks(num, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection(addr: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConnectionSchema> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnection(addr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnections(states, direction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnectionsDisconnect(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnectionsExchange(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).networkConnectionsTrust(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address] 
         * @param {Array<string>} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet(address?: Array<string>, hash?: Array<string>, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).outputsGet(address, hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost(address?: string, hash?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).outputsPost(address, hash, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20010>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).pendingTxs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).resendUnconfirmedTxns(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist(includeDistribution?: boolean, n?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).richlist(includeDistribution, n, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction(txid: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transaction(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject(rawtx: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionInject(rawtx, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPost(transactionV2ParamsAddress?: TransactionV2ParamsAddress, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionPost(transactionV2ParamsAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPostUnspent(transactionV2ParamsUnspent: TransactionV2ParamsUnspent, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionPostUnspent(transactionV2ParamsUnspent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw(txid?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionRaw(txid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Decode and verify an encoded transaction
         * @param {TransactionVerifyRequest} transactionVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify(transactionVerifyRequest: TransactionVerifyRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionVerify(transactionVerifyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(addrs?: string, confirmed?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionsGet(addrs, confirmed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost(addrs?: string, confirmed?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).transactionsPost(addrs, confirmed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout(uxid?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).uxout(uxid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Verifies a Skycoin address.
         * @param {any} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress(address: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).verifyAddress(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).version(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).wallet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletBalance(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletCreate(seed, label, scan, encrypt, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt(id: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletDecrypt(id, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt(id: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletEncrypt(id, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder(addr: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletFolder(addr, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress(id: string, num?: string, password?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletNewAddress(id, num, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed(entropy?: '128' | '256', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletNewSeed(entropy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover(id: string, seed: string, password?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletRecover(id, seed, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed(id: string, password: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletSeed(id, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify(seed?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletSeedVerify(seed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a signed transaction
         * @param {WalletTransactionRequest} walletTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction(walletTransactionRequest: WalletTransactionRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletTransaction(walletTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a signed transaction
         * @param {WalletTransactionSignRequest} walletTransactionSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionSign(walletTransactionSignRequest: WalletTransactionSignRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletTransactionSign(walletTransactionSignRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletTransactions(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletUnload(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate(id: string, label: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).walletUpdate(id, label, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).wallets(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount(options?: any) {
            return DefaultApiFp(configuration).addressCount(options)(axios, basePath);
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts(address: string, options?: any) {
            return DefaultApiFp(configuration).addressUxouts(address, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RawtxGet(options?: any) {
            return DefaultApiFp(configuration).apiV1RawtxGet(options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2MetricsGet(options?: any) {
            return DefaultApiFp(configuration).apiV2MetricsGet(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet(addrs: string, options?: any) {
            return DefaultApiFp(configuration).balanceGet(addrs, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost(addrs: string, options?: any) {
            return DefaultApiFp(configuration).balancePost(addrs, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} [hash] get block by hash
         * @param {number} [seq] get block by sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(hash?: string, seq?: number, options?: any) {
            return DefaultApiFp(configuration).block(hash, seq, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata(options?: any) {
            return DefaultApiFp(configuration).blockchainMetadata(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress(options?: any) {
            return DefaultApiFp(configuration).blockchainProgress(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {number} [start] start seq
         * @param {number} [end] end seq
         * @param {Array<number>} [seq] comma-separated list of block seqs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks(start?: number, end?: number, seq?: Array<number>, options?: any) {
            return DefaultApiFp(configuration).blocks(start, end, seq, options)(axios, basePath);
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply(options?: any) {
            return DefaultApiFp(configuration).coinSupply(options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf(options?: any) {
            return DefaultApiFp(configuration).csrf(options)(axios, basePath);
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataDELETE(type?: string, key?: string, options?: any) {
            return DefaultApiFp(configuration).dataDELETE(type, key, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGET(type?: string, key?: string, options?: any) {
            return DefaultApiFp(configuration).dataGET(type, key, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {string} [val] additional value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPOST(type?: string, key?: string, val?: string, options?: any) {
            return DefaultApiFp(configuration).dataPOST(type, key, val, options)(axios, basePath);
        },
        /**
         * 
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections(options?: any) {
            return DefaultApiFp(configuration).defaultConnections(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any) {
            return DefaultApiFp(configuration).health(options)(axios, basePath);
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num Num of blockss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks(num: number, options?: any) {
            return DefaultApiFp(configuration).lastBlocks(num, options)(axios, basePath);
        },
        /**
         * 
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection(addr: string, options?: any) {
            return DefaultApiFp(configuration).networkConnection(addr, options)(axios, basePath);
        },
        /**
         * 
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options?: any) {
            return DefaultApiFp(configuration).networkConnections(states, direction, options)(axios, basePath);
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect(id: string, options?: any) {
            return DefaultApiFp(configuration).networkConnectionsDisconnect(id, options)(axios, basePath);
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange(options?: any) {
            return DefaultApiFp(configuration).networkConnectionsExchange(options)(axios, basePath);
        },
        /**
         * 
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust(options?: any) {
            return DefaultApiFp(configuration).networkConnectionsTrust(options)(axios, basePath);
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address] 
         * @param {Array<string>} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet(address?: Array<string>, hash?: Array<string>, options?: any) {
            return DefaultApiFp(configuration).outputsGet(address, hash, options)(axios, basePath);
        },
        /**
         * 
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address] 
         * @param {string} [hash] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost(address?: string, hash?: string, options?: any) {
            return DefaultApiFp(configuration).outputsPost(address, hash, options)(axios, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs(options?: any) {
            return DefaultApiFp(configuration).pendingTxs(options)(axios, basePath);
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns(options?: any) {
            return DefaultApiFp(configuration).resendUnconfirmedTxns(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist(includeDistribution?: boolean, n?: string, options?: any) {
            return DefaultApiFp(configuration).richlist(includeDistribution, n, options)(axios, basePath);
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction(txid: string, options?: any) {
            return DefaultApiFp(configuration).transaction(txid, options)(axios, basePath);
        },
        /**
         * 
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject(rawtx: string, options?: any) {
            return DefaultApiFp(configuration).transactionInject(rawtx, options)(axios, basePath);
        },
        /**
         * 
         * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPost(transactionV2ParamsAddress?: TransactionV2ParamsAddress, options?: any) {
            return DefaultApiFp(configuration).transactionPost(transactionV2ParamsAddress, options)(axios, basePath);
        },
        /**
         * 
         * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPostUnspent(transactionV2ParamsUnspent: TransactionV2ParamsUnspent, options?: any) {
            return DefaultApiFp(configuration).transactionPostUnspent(transactionV2ParamsUnspent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw(txid?: string, options?: any) {
            return DefaultApiFp(configuration).transactionRaw(txid, options)(axios, basePath);
        },
        /**
         * Decode and verify an encoded transaction
         * @param {TransactionVerifyRequest} transactionVerifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify(transactionVerifyRequest: TransactionVerifyRequest, options?: any) {
            return DefaultApiFp(configuration).transactionVerify(transactionVerifyRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet(addrs?: string, confirmed?: string, options?: any) {
            return DefaultApiFp(configuration).transactionsGet(addrs, confirmed, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost(addrs?: string, confirmed?: string, options?: any) {
            return DefaultApiFp(configuration).transactionsPost(addrs, confirmed, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout(uxid?: string, options?: any) {
            return DefaultApiFp(configuration).uxout(uxid, options)(axios, basePath);
        },
        /**
         * 
         * @summary Verifies a Skycoin address.
         * @param {any} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress(address: any, options?: any) {
            return DefaultApiFp(configuration).verifyAddress(address, options)(axios, basePath);
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any) {
            return DefaultApiFp(configuration).version(options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet(id: string, options?: any) {
            return DefaultApiFp(configuration).wallet(id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance(id: string, options?: any) {
            return DefaultApiFp(configuration).walletBalance(id, options)(axios, basePath);
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options?: any) {
            return DefaultApiFp(configuration).walletCreate(seed, label, scan, encrypt, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt(id: string, password: string, options?: any) {
            return DefaultApiFp(configuration).walletDecrypt(id, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt(id: string, password: string, options?: any) {
            return DefaultApiFp(configuration).walletEncrypt(id, password, options)(axios, basePath);
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder(addr: string, options?: any) {
            return DefaultApiFp(configuration).walletFolder(addr, options)(axios, basePath);
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress(id: string, num?: string, password?: string, options?: any) {
            return DefaultApiFp(configuration).walletNewAddress(id, num, password, options)(axios, basePath);
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed(entropy?: '128' | '256', options?: any) {
            return DefaultApiFp(configuration).walletNewSeed(entropy, options)(axios, basePath);
        },
        /**
         * 
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover(id: string, seed: string, password?: string, options?: any) {
            return DefaultApiFp(configuration).walletRecover(id, seed, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed(id: string, password: string, options?: any) {
            return DefaultApiFp(configuration).walletSeed(id, password, options)(axios, basePath);
        },
        /**
         * 
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify(seed?: string, options?: any) {
            return DefaultApiFp(configuration).walletSeedVerify(seed, options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a signed transaction
         * @param {WalletTransactionRequest} walletTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction(walletTransactionRequest: WalletTransactionRequest, options?: any) {
            return DefaultApiFp(configuration).walletTransaction(walletTransactionRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a signed transaction
         * @param {WalletTransactionSignRequest} walletTransactionSignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionSign(walletTransactionSignRequest: WalletTransactionSignRequest, options?: any) {
            return DefaultApiFp(configuration).walletTransactionSign(walletTransactionSignRequest, options)(axios, basePath);
        },
        /**
         * 
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions(id: string, options?: any) {
            return DefaultApiFp(configuration).walletTransactions(id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload(id: string, options?: any) {
            return DefaultApiFp(configuration).walletUnload(id, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate(id: string, label: string, options?: any) {
            return DefaultApiFp(configuration).walletUpdate(id, label, options)(axios, basePath);
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets(options?: any) {
            return DefaultApiFp(configuration).wallets(options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Returns the total number of unique address that have coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addressCount(options?: any) {
        return DefaultApiFp(this.configuration).addressCount(options)(this.axios, this.basePath);
    }

    /**
     * Returns the historical, spent outputs associated with an address
     * @param {string} address address to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addressUxouts(address: string, options?: any) {
        return DefaultApiFp(this.configuration).addressUxouts(address, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1RawtxGet(options?: any) {
        return DefaultApiFp(this.configuration).apiV1RawtxGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV2MetricsGet(options?: any) {
        return DefaultApiFp(this.configuration).apiV2MetricsGet(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} addrs command separated list of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public balanceGet(addrs: string, options?: any) {
        return DefaultApiFp(this.configuration).balanceGet(addrs, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} addrs command separated list of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public balancePost(addrs: string, options?: any) {
        return DefaultApiFp(this.configuration).balancePost(addrs, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} [hash] get block by hash
     * @param {number} [seq] get block by sequence number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public block(hash?: string, seq?: number, options?: any) {
        return DefaultApiFp(this.configuration).block(hash, seq, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the blockchain metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blockchainMetadata(options?: any) {
        return DefaultApiFp(this.configuration).blockchainMetadata(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the blockchain sync progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blockchainProgress(options?: any) {
        return DefaultApiFp(this.configuration).blockchainProgress(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {number} [start] start seq
     * @param {number} [end] end seq
     * @param {Array<number>} [seq] comma-separated list of block seqs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public blocks(start?: number, end?: number, seq?: Array<number>, options?: any) {
        return DefaultApiFp(this.configuration).blocks(start, end, seq, options)(this.axios, this.basePath);
    }

    /**
     * coinSupplyHandler returns coin distribution supply stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public coinSupply(options?: any) {
        return DefaultApiFp(this.configuration).coinSupply(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public csrf(options?: any) {
        return DefaultApiFp(this.configuration).csrf(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} [type] storage type.
     * @param {string} [key] key of the specific value to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataDELETE(type?: string, key?: string, options?: any) {
        return DefaultApiFp(this.configuration).dataDELETE(type, key, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} [type] storage type.
     * @param {string} [key] key of the specific value to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataGET(type?: string, key?: string, options?: any) {
        return DefaultApiFp(this.configuration).dataGET(type, key, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} [type] storage type.
     * @param {string} [key] key of the specific value to get.
     * @param {string} [val] additional value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public dataPOST(type?: string, key?: string, val?: string, options?: any) {
        return DefaultApiFp(this.configuration).dataPOST(type, key, val, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public defaultConnections(options?: any) {
        return DefaultApiFp(this.configuration).defaultConnections(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns node health data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public health(options?: any) {
        return DefaultApiFp(this.configuration).health(options)(this.axios, this.basePath);
    }

    /**
     * Returns the most recent N blocks on the blockchain
     * @param {number} num Num of blockss
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lastBlocks(num: number, options?: any) {
        return DefaultApiFp(this.configuration).lastBlocks(num, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary This endpoint returns a specific connection.
     * @param {string} addr Address port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnection(addr: string, options?: any) {
        return DefaultApiFp(this.configuration).networkConnection(addr, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary This endpoint returns all outgoings connections.
     * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
     * @param {'connected' | 'introduced'} [direction] Direction of the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnections(states?: 'pending' | 'connected' | 'introduced', direction?: 'connected' | 'introduced', options?: any) {
        return DefaultApiFp(this.configuration).networkConnections(states, direction, options)(this.axios, this.basePath);
    }

    /**
     * This endpoint disconnects a connection by ID or address
     * @param {string} id Address id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnectionsDisconnect(id: string, options?: any) {
        return DefaultApiFp(this.configuration).networkConnectionsDisconnect(id, options)(this.axios, this.basePath);
    }

    /**
     * This endpoint returns all connections found through peer exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnectionsExchange(options?: any) {
        return DefaultApiFp(this.configuration).networkConnectionsExchange(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkConnectionsTrust(options?: any) {
        return DefaultApiFp(this.configuration).networkConnectionsTrust(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param {Array<string>} [address] 
     * @param {Array<string>} [hash] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public outputsGet(address?: Array<string>, hash?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).outputsGet(address, hash, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param {string} [address] 
     * @param {string} [hash] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public outputsPost(address?: string, hash?: string, options?: any) {
        return DefaultApiFp(this.configuration).outputsPost(address, hash, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pendingTxs(options?: any) {
        return DefaultApiFp(this.configuration).pendingTxs(options)(this.axios, this.basePath);
    }

    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resendUnconfirmedTxns(options?: any) {
        return DefaultApiFp(this.configuration).resendUnconfirmedTxns(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the top skycoin holders.
     * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
     * @param {string} [n] include distribution addresses or not, default value false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public richlist(includeDistribution?: boolean, n?: string, options?: any) {
        return DefaultApiFp(this.configuration).richlist(includeDistribution, n, options)(this.axios, this.basePath);
    }

    /**
     * Returns a transaction identified by its txid hash with just id
     * @param {string} txid transaction Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transaction(txid: string, options?: any) {
        return DefaultApiFp(this.configuration).transaction(txid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Broadcast a hex-encoded, serialized transaction to the network.
     * @param {string} rawtx hex-encoded serialized transaction string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionInject(rawtx: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionInject(rawtx, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionPost(transactionV2ParamsAddress?: TransactionV2ParamsAddress, options?: any) {
        return DefaultApiFp(this.configuration).transactionPost(transactionV2ParamsAddress, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionPostUnspent(transactionV2ParamsUnspent: TransactionV2ParamsUnspent, options?: any) {
        return DefaultApiFp(this.configuration).transactionPostUnspent(transactionV2ParamsUnspent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * @param {string} [txid] Transaction id hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionRaw(txid?: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionRaw(txid, options)(this.axios, this.basePath);
    }

    /**
     * Decode and verify an encoded transaction
     * @param {TransactionVerifyRequest} transactionVerifyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionVerify(transactionVerifyRequest: TransactionVerifyRequest, options?: any) {
        return DefaultApiFp(this.configuration).transactionVerify(transactionVerifyRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param {string} [addrs] command separated list of addresses
     * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionsGet(addrs?: string, confirmed?: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionsGet(addrs, confirmed, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns transactions that match the filters.
     * @param {string} [addrs] command separated list of addresses
     * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionsPost(addrs?: string, confirmed?: string, options?: any) {
        return DefaultApiFp(this.configuration).transactionsPost(addrs, confirmed, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns an unspent output by ID.
     * @param {string} [uxid] uxid to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uxout(uxid?: string, options?: any) {
        return DefaultApiFp(this.configuration).uxout(uxid, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Verifies a Skycoin address.
     * @param {any} address Address id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifyAddress(address: any, options?: any) {
        return DefaultApiFp(this.configuration).verifyAddress(address, options)(this.axios, this.basePath);
    }

    /**
     * versionHandler returns the application version info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public version(options?: any) {
        return DefaultApiFp(this.configuration).version(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns a wallet by id.
     * @param {string} id tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public wallet(id: string, options?: any) {
        return DefaultApiFp(this.configuration).wallet(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} id tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletBalance(id: string, options?: any) {
        return DefaultApiFp(this.configuration).walletBalance(id, options)(this.axios, this.basePath);
    }

    /**
     * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
     * @param {string} seed Wallet seed.
     * @param {string} label Wallet label.
     * @param {number} [scan] The number of addresses to scan ahead for balances.
     * @param {boolean} [encrypt] Encrypt wallet.
     * @param {string} [password] Wallet Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletCreate(seed: string, label: string, scan?: number, encrypt?: boolean, password?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletCreate(seed, label, scan, encrypt, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Decrypts wallet.
     * @param {string} id Wallet id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletDecrypt(id: string, password: string, options?: any) {
        return DefaultApiFp(this.configuration).walletDecrypt(id, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Encrypt wallet.
     * @param {string} id Wallet id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletEncrypt(id: string, password: string, options?: any) {
        return DefaultApiFp(this.configuration).walletEncrypt(id, password, options)(this.axios, this.basePath);
    }

    /**
     * Returns the wallet directory path
     * @param {string} addr Address port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletFolder(addr: string, options?: any) {
        return DefaultApiFp(this.configuration).walletFolder(addr, options)(this.axios, this.basePath);
    }

    /**
     * Generates new addresses
     * @param {string} id Wallet Id
     * @param {string} [num] The number you want to generate
     * @param {string} [password] Wallet Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletNewAddress(id: string, num?: string, password?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletNewAddress(id, num, password, options)(this.axios, this.basePath);
    }

    /**
     * Returns the wallet directory path
     * @param {'128' | '256'} [entropy] Entropy bitSize.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletNewSeed(entropy?: '128' | '256', options?: any) {
        return DefaultApiFp(this.configuration).walletNewSeed(entropy, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * @param {string} id Wallet id.
     * @param {string} seed Wallet seed.
     * @param {string} [password] Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletRecover(id: string, seed: string, password?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletRecover(id, seed, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * @param {string} id Wallet Id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletSeed(id: string, password: string, options?: any) {
        return DefaultApiFp(this.configuration).walletSeed(id, password, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Verifies a wallet seed.
     * @param {string} [seed] Seed to be verified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletSeedVerify(seed?: string, options?: any) {
        return DefaultApiFp(this.configuration).walletSeedVerify(seed, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a signed transaction
     * @param {WalletTransactionRequest} walletTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletTransaction(walletTransactionRequest: WalletTransactionRequest, options?: any) {
        return DefaultApiFp(this.configuration).walletTransaction(walletTransactionRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a signed transaction
     * @param {WalletTransactionSignRequest} walletTransactionSignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletTransactionSign(walletTransactionSignRequest: WalletTransactionSignRequest, options?: any) {
        return DefaultApiFp(this.configuration).walletTransactionSign(walletTransactionSignRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @param {string} id Wallet Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletTransactions(id: string, options?: any) {
        return DefaultApiFp(this.configuration).walletTransactions(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Unloads wallet from the wallet service.
     * @param {string} id Wallet Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletUnload(id: string, options?: any) {
        return DefaultApiFp(this.configuration).walletUnload(id, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update the wallet.
     * @param {string} id Wallet Id.
     * @param {string} label The label the wallet will be updated to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public walletUpdate(id: string, label: string, options?: any) {
        return DefaultApiFp(this.configuration).walletUpdate(id, label, options)(this.axios, this.basePath);
    }

    /**
     * Returns all loaded wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public wallets(options?: any) {
        return DefaultApiFp(this.configuration).wallets(options)(this.axios, this.basePath);
    }

}

