"use strict";
// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.26.0
 * Contact: contact@skycoin.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var url = require("url");
var axios_1 = require("axios");
var BASE_PATH = "http://127.0.0.1:6420".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, axios) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (axios === void 0) { axios = axios_1.default; }
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        _this.name = "RequiredError";
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace NetworkConnectionSchema
 */
var NetworkConnectionSchema;
(function (NetworkConnectionSchema) {
    /**
     * @export
     * @enum {string}
     */
    var StateEnum;
    (function (StateEnum) {
        StateEnum["Pending"] = "pending";
        StateEnum["Connected"] = "connected";
        StateEnum["Introduced"] = "introduced";
    })(StateEnum = NetworkConnectionSchema.StateEnum || (NetworkConnectionSchema.StateEnum = {}));
})(NetworkConnectionSchema = exports.NetworkConnectionSchema || (exports.NetworkConnectionSchema = {}));
/**
 * DefaultApi - axios parameter creator
 * @export
 */
exports.DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/addresscount";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts: function (address, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address', 'Required parameter address was null or undefined when calling addressUxouts.');
            }
            var localVarPath = "/api/v1/address_uxouts";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RawtxGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/rawtx";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2MetricsGet: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v2/metrics";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet: function (addrs, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'addrs' is not null or undefined
            if (addrs === null || addrs === undefined) {
                throw new RequiredError('addrs', 'Required parameter addrs was null or undefined when calling balanceGet.');
            }
            var localVarPath = "/api/v1/balance";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost: function (addrs, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'addrs' is not null or undefined
            if (addrs === null || addrs === undefined) {
                throw new RequiredError('addrs', 'Required parameter addrs was null or undefined when calling balancePost.');
            }
            var localVarPath = "/api/v1/balance";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} [hash] get block by hash
         * @param {number} [seq] get block by sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block: function (hash, seq, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/block";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }
            if (seq !== undefined) {
                localVarQueryParameter['seq'] = seq;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/blockchain/metadata";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/blockchain/progress";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {number} [start] start seq
         * @param {number} [end] end seq
         * @param {Array<number>} [seq] comma-separated list of block seqs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks: function (start, end, seq, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/blocks";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (seq) {
                localVarQueryParameter['seq'] = seq;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/coinSupply";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/csrf";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataDELETE: function (type, key, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v2/data";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (type !== undefined && type !== null) {
                localVarHeaderParameter['type'] = String(type);
            }
            if (key !== undefined && key !== null) {
                localVarHeaderParameter['key'] = String(key);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGET: function (type, key, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v2/data";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (type !== undefined && type !== null) {
                localVarHeaderParameter['type'] = String(type);
            }
            if (key !== undefined && key !== null) {
                localVarHeaderParameter['key'] = String(key);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {string} [val] additional value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPOST: function (type, key, val, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v2/data";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (type !== undefined && type !== null) {
                localVarHeaderParameter['type'] = String(type);
            }
            if (key !== undefined && key !== null) {
                localVarHeaderParameter['key'] = String(key);
            }
            if (val !== undefined && val !== null) {
                localVarHeaderParameter['val'] = String(val);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/network/defaultConnections";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/health";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num Num of blockss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks: function (num, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'num' is not null or undefined
            if (num === null || num === undefined) {
                throw new RequiredError('num', 'Required parameter num was null or undefined when calling lastBlocks.');
            }
            var localVarPath = "/api/v1/last_blocks";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (num !== undefined) {
                localVarQueryParameter['num'] = num;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection: function (addr, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'addr' is not null or undefined
            if (addr === null || addr === undefined) {
                throw new RequiredError('addr', 'Required parameter addr was null or undefined when calling networkConnection.');
            }
            var localVarPath = "/api/v1/network/connection";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (addr !== undefined) {
                localVarQueryParameter['addr'] = addr;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections: function (states, direction, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/network/connections";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }
            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling networkConnectionsDisconnect.');
            }
            var localVarPath = "/api/v1/network/connection/disconnect";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/network/connections/exchange";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/network/connections/trust";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address]
         * @param {Array<string>} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet: function (address, hash, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/outputs";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (address) {
                localVarQueryParameter['address'] = address;
            }
            if (hash) {
                localVarQueryParameter['hash'] = hash;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address]
         * @param {string} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost: function (address, hash, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/outputs";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/pendingTxs";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/resendUnconfirmedTxns";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist: function (includeDistribution, n, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/richlist";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (includeDistribution !== undefined) {
                localVarQueryParameter['include-distribution'] = includeDistribution;
            }
            if (n !== undefined) {
                localVarQueryParameter['n'] = n;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction: function (txid, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'txid' is not null or undefined
            if (txid === null || txid === undefined) {
                throw new RequiredError('txid', 'Required parameter txid was null or undefined when calling transaction.');
            }
            var localVarPath = "/api/v1/transaction";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject: function (rawtx, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'rawtx' is not null or undefined
            if (rawtx === null || rawtx === undefined) {
                throw new RequiredError('rawtx', 'Required parameter rawtx was null or undefined when calling transactionInject.');
            }
            var localVarPath = "/api/v1/injectTransaction";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (rawtx !== undefined && rawtx !== null) {
                localVarHeaderParameter['rawtx'] = String(rawtx);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPost: function (transactionV2ParamsAddress, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v2/transaction";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TransactionV2ParamsAddress" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(transactionV2ParamsAddress || {}) : (transactionV2ParamsAddress || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPostUnspent: function (transactionV2ParamsUnspent, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'transactionV2ParamsUnspent' is not null or undefined
            if (transactionV2ParamsUnspent === null || transactionV2ParamsUnspent === undefined) {
                throw new RequiredError('transactionV2ParamsUnspent', 'Required parameter transactionV2ParamsUnspent was null or undefined when calling transactionPostUnspent.');
            }
            var localVarPath = "/api/v2/transaction/unspent";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TransactionV2ParamsUnspent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(transactionV2ParamsUnspent || {}) : (transactionV2ParamsUnspent || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw: function (txid, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v2/transaction/raw";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Decode and verify an encoded transaction
         * @param {TransactionVerifyRequest} transactionVerifyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify: function (transactionVerifyRequest, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'transactionVerifyRequest' is not null or undefined
            if (transactionVerifyRequest === null || transactionVerifyRequest === undefined) {
                throw new RequiredError('transactionVerifyRequest', 'Required parameter transactionVerifyRequest was null or undefined when calling transactionVerify.');
            }
            var localVarPath = "/api/v2/transaction/verify";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("TransactionVerifyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(transactionVerifyRequest || {}) : (transactionVerifyRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: function (addrs, confirmed, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/transactions";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }
            if (confirmed !== undefined) {
                localVarQueryParameter['confirmed'] = confirmed;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost: function (addrs, confirmed, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/transactions";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (addrs !== undefined) {
                localVarQueryParameter['addrs'] = addrs;
            }
            if (confirmed !== undefined) {
                localVarQueryParameter['confirmed'] = confirmed;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout: function (uxid, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/uxout";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (uxid !== undefined) {
                localVarQueryParameter['uxid'] = uxid;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Verifies a Skycoin address.
         * @param {any} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress: function (address, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address', 'Required parameter address was null or undefined when calling verifyAddress.');
            }
            var localVarPath = "/api/v2/address/verify";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/version";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling wallet.');
            }
            var localVarPath = "/api/v1/wallet";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletBalance.');
            }
            var localVarPath = "/api/v1/wallet/balance";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate: function (seed, label, scan, encrypt, password, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed', 'Required parameter seed was null or undefined when calling walletCreate.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label', 'Required parameter label was null or undefined when calling walletCreate.');
            }
            var localVarPath = "/api/v1/wallet/create";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }
            if (label !== undefined && label !== null) {
                localVarHeaderParameter['label'] = String(label);
            }
            if (scan !== undefined && scan !== null) {
                localVarHeaderParameter['scan'] = String(scan);
            }
            if (encrypt !== undefined && encrypt !== null) {
                localVarHeaderParameter['encrypt'] = String(encrypt);
            }
            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt: function (id, password, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletDecrypt.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password', 'Required parameter password was null or undefined when calling walletDecrypt.');
            }
            var localVarPath = "/api/v1/wallet/decrypt";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }
            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt: function (id, password, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletEncrypt.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password', 'Required parameter password was null or undefined when calling walletEncrypt.');
            }
            var localVarPath = "/api/v1/wallet/encrypt";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }
            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder: function (addr, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'addr' is not null or undefined
            if (addr === null || addr === undefined) {
                throw new RequiredError('addr', 'Required parameter addr was null or undefined when calling walletFolder.');
            }
            var localVarPath = "/api/v1/wallets/folderName";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (addr !== undefined) {
                localVarQueryParameter['addr'] = addr;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress: function (id, num, password, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletNewAddress.');
            }
            var localVarPath = "/api/v1/wallet/newAddress";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (num !== undefined) {
                localVarQueryParameter['num'] = num;
            }
            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed: function (entropy, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/wallet/newSeed";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (entropy !== undefined) {
                localVarQueryParameter['entropy'] = entropy;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover: function (id, seed, password, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletRecover.');
            }
            // verify required parameter 'seed' is not null or undefined
            if (seed === null || seed === undefined) {
                throw new RequiredError('seed', 'Required parameter seed was null or undefined when calling walletRecover.');
            }
            var localVarPath = "/api/v2/wallet/recover";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }
            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }
            if (password !== undefined && password !== null) {
                localVarHeaderParameter['password'] = String(password);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed: function (id, password, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletSeed.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password', 'Required parameter password was null or undefined when calling walletSeed.');
            }
            var localVarPath = "/api/v1/wallet/seed";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify: function (seed, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v2/wallet/seed/verify";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (seed !== undefined && seed !== null) {
                localVarHeaderParameter['seed'] = String(seed);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a signed transaction
         * @param {WalletTransactionRequest} walletTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction: function (walletTransactionRequest, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'walletTransactionRequest' is not null or undefined
            if (walletTransactionRequest === null || walletTransactionRequest === undefined) {
                throw new RequiredError('walletTransactionRequest', 'Required parameter walletTransactionRequest was null or undefined when calling walletTransaction.');
            }
            var localVarPath = "/api/v1/wallet/transaction";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("WalletTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(walletTransactionRequest || {}) : (walletTransactionRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a signed transaction
         * @param {WalletTransactionSignRequest} walletTransactionSignRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionSign: function (walletTransactionSignRequest, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'walletTransactionSignRequest' is not null or undefined
            if (walletTransactionSignRequest === null || walletTransactionSignRequest === undefined) {
                throw new RequiredError('walletTransactionSignRequest', 'Required parameter walletTransactionSignRequest was null or undefined when calling walletTransactionSign.');
            }
            var localVarPath = "/api/v2/wallet/transaction/sign";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("WalletTransactionSignRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(walletTransactionSignRequest || {}) : (walletTransactionSignRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletTransactions.');
            }
            var localVarPath = "/api/v1/wallet/transactions";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletUnload.');
            }
            var localVarPath = "/api/v1/wallet/unload";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate: function (id, label, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling walletUpdate.');
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError('label', 'Required parameter label was null or undefined when calling walletUpdate.');
            }
            var localVarPath = "/api/v1/wallet/update";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication csrfAuth required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CSRF-TOKEN")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CSRF-TOKEN"] = localVarApiKeyValue;
            }
            if (id !== undefined && id !== null) {
                localVarHeaderParameter['id'] = String(id);
            }
            if (label !== undefined && label !== null) {
                localVarHeaderParameter['label'] = String(label);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/api/v1/wallets";
            var localVarUrlObj = url.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DefaultApi - functional programming interface
 * @export
 */
exports.DefaultApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).addressCount(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts: function (address, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).addressUxouts(address, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RawtxGet: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).apiV1RawtxGet(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2MetricsGet: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).apiV2MetricsGet(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet: function (addrs, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).balanceGet(addrs, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost: function (addrs, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).balancePost(addrs, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} [hash] get block by hash
         * @param {number} [seq] get block by sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block: function (hash, seq, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).block(hash, seq, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).blockchainMetadata(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).blockchainProgress(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {number} [start] start seq
         * @param {number} [end] end seq
         * @param {Array<number>} [seq] comma-separated list of block seqs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks: function (start, end, seq, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).blocks(start, end, seq, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).coinSupply(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).csrf(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataDELETE: function (type, key, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).dataDELETE(type, key, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGET: function (type, key, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).dataGET(type, key, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {string} [val] additional value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPOST: function (type, key, val, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).dataPOST(type, key, val, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).defaultConnections(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).health(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num Num of blockss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks: function (num, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).lastBlocks(num, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection: function (addr, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).networkConnection(addr, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections: function (states, direction, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).networkConnections(states, direction, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect: function (id, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).networkConnectionsDisconnect(id, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).networkConnectionsExchange(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).networkConnectionsTrust(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address]
         * @param {Array<string>} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet: function (address, hash, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).outputsGet(address, hash, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address]
         * @param {string} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost: function (address, hash, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).outputsPost(address, hash, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).pendingTxs(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).resendUnconfirmedTxns(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist: function (includeDistribution, n, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).richlist(includeDistribution, n, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction: function (txid, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transaction(txid, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject: function (rawtx, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transactionInject(rawtx, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPost: function (transactionV2ParamsAddress, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transactionPost(transactionV2ParamsAddress, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPostUnspent: function (transactionV2ParamsUnspent, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transactionPostUnspent(transactionV2ParamsUnspent, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw: function (txid, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transactionRaw(txid, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Decode and verify an encoded transaction
         * @param {TransactionVerifyRequest} transactionVerifyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify: function (transactionVerifyRequest, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transactionVerify(transactionVerifyRequest, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: function (addrs, confirmed, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transactionsGet(addrs, confirmed, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost: function (addrs, confirmed, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).transactionsPost(addrs, confirmed, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout: function (uxid, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).uxout(uxid, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Verifies a Skycoin address.
         * @param {any} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress: function (address, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).verifyAddress(address, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).version(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet: function (id, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).wallet(id, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance: function (id, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletBalance(id, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate: function (seed, label, scan, encrypt, password, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletCreate(seed, label, scan, encrypt, password, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt: function (id, password, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletDecrypt(id, password, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt: function (id, password, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletEncrypt(id, password, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder: function (addr, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletFolder(addr, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress: function (id, num, password, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletNewAddress(id, num, password, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed: function (entropy, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletNewSeed(entropy, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover: function (id, seed, password, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletRecover(id, seed, password, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed: function (id, password, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletSeed(id, password, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify: function (seed, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletSeedVerify(seed, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Creates a signed transaction
         * @param {WalletTransactionRequest} walletTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction: function (walletTransactionRequest, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletTransaction(walletTransactionRequest, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Creates a signed transaction
         * @param {WalletTransactionSignRequest} walletTransactionSignRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionSign: function (walletTransactionSignRequest, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletTransactionSign(walletTransactionSignRequest, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions: function (id, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletTransactions(id, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload: function (id, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletUnload(id, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate: function (id, label, options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).walletUpdate(id, label, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets: function (options) {
            var localVarAxiosArgs = exports.DefaultApiAxiosParamCreator(configuration).wallets(options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * DefaultApi - factory interface
 * @export
 */
exports.DefaultApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Returns the total number of unique address that have coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCount: function (options) {
            return exports.DefaultApiFp(configuration).addressCount(options)(axios, basePath);
        },
        /**
         * Returns the historical, spent outputs associated with an address
         * @param {string} address address to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUxouts: function (address, options) {
            return exports.DefaultApiFp(configuration).addressUxouts(address, options)(axios, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RawtxGet: function (options) {
            return exports.DefaultApiFp(configuration).apiV1RawtxGet(options)(axios, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2MetricsGet: function (options) {
            return exports.DefaultApiFp(configuration).apiV2MetricsGet(options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balanceGet: function (addrs, options) {
            return exports.DefaultApiFp(configuration).balanceGet(addrs, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} addrs command separated list of addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balancePost: function (addrs, options) {
            return exports.DefaultApiFp(configuration).balancePost(addrs, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} [hash] get block by hash
         * @param {number} [seq] get block by sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block: function (hash, seq, options) {
            return exports.DefaultApiFp(configuration).block(hash, seq, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the blockchain metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainMetadata: function (options) {
            return exports.DefaultApiFp(configuration).blockchainMetadata(options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the blockchain sync progress.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainProgress: function (options) {
            return exports.DefaultApiFp(configuration).blockchainProgress(options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
         * @param {number} [start] start seq
         * @param {number} [end] end seq
         * @param {Array<number>} [seq] comma-separated list of block seqs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks: function (start, end, seq, options) {
            return exports.DefaultApiFp(configuration).blocks(start, end, seq, options)(axios, basePath);
        },
        /**
         * coinSupplyHandler returns coin distribution supply stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coinSupply: function (options) {
            return exports.DefaultApiFp(configuration).coinSupply(options)(axios, basePath);
        },
        /**
         *
         * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrf: function (options) {
            return exports.DefaultApiFp(configuration).csrf(options)(axios, basePath);
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataDELETE: function (type, key, options) {
            return exports.DefaultApiFp(configuration).dataDELETE(type, key, options)(axios, basePath);
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGET: function (type, key, options) {
            return exports.DefaultApiFp(configuration).dataGET(type, key, options)(axios, basePath);
        },
        /**
         *
         * @param {string} [type] storage type.
         * @param {string} [key] key of the specific value to get.
         * @param {string} [val] additional value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPOST: function (type, key, val, options) {
            return exports.DefaultApiFp(configuration).dataPOST(type, key, val, options)(axios, basePath);
        },
        /**
         *
         * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultConnections: function (options) {
            return exports.DefaultApiFp(configuration).defaultConnections(options)(axios, basePath);
        },
        /**
         *
         * @summary Returns node health data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: function (options) {
            return exports.DefaultApiFp(configuration).health(options)(axios, basePath);
        },
        /**
         * Returns the most recent N blocks on the blockchain
         * @param {number} num Num of blockss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastBlocks: function (num, options) {
            return exports.DefaultApiFp(configuration).lastBlocks(num, options)(axios, basePath);
        },
        /**
         *
         * @summary This endpoint returns a specific connection.
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnection: function (addr, options) {
            return exports.DefaultApiFp(configuration).networkConnection(addr, options)(axios, basePath);
        },
        /**
         *
         * @summary This endpoint returns all outgoings connections.
         * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
         * @param {'connected' | 'introduced'} [direction] Direction of the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnections: function (states, direction, options) {
            return exports.DefaultApiFp(configuration).networkConnections(states, direction, options)(axios, basePath);
        },
        /**
         * This endpoint disconnects a connection by ID or address
         * @param {string} id Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsDisconnect: function (id, options) {
            return exports.DefaultApiFp(configuration).networkConnectionsDisconnect(id, options)(axios, basePath);
        },
        /**
         * This endpoint returns all connections found through peer exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsExchange: function (options) {
            return exports.DefaultApiFp(configuration).networkConnectionsExchange(options)(axios, basePath);
        },
        /**
         *
         * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkConnectionsTrust: function (options) {
            return exports.DefaultApiFp(configuration).networkConnectionsTrust(options)(axios, basePath);
        },
        /**
         *
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {Array<string>} [address]
         * @param {Array<string>} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsGet: function (address, hash, options) {
            return exports.DefaultApiFp(configuration).outputsGet(address, hash, options)(axios, basePath);
        },
        /**
         *
         * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
         * @param {string} [address]
         * @param {string} [hash]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outputsPost: function (address, hash, options) {
            return exports.DefaultApiFp(configuration).outputsPost(address, hash, options)(axios, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingTxs: function (options) {
            return exports.DefaultApiFp(configuration).pendingTxs(options)(axios, basePath);
        },
        /**
         * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUnconfirmedTxns: function (options) {
            return exports.DefaultApiFp(configuration).resendUnconfirmedTxns(options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the top skycoin holders.
         * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
         * @param {string} [n] include distribution addresses or not, default value false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        richlist: function (includeDistribution, n, options) {
            return exports.DefaultApiFp(configuration).richlist(includeDistribution, n, options)(axios, basePath);
        },
        /**
         * Returns a transaction identified by its txid hash with just id
         * @param {string} txid transaction Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transaction: function (txid, options) {
            return exports.DefaultApiFp(configuration).transaction(txid, options)(axios, basePath);
        },
        /**
         *
         * @summary Broadcast a hex-encoded, serialized transaction to the network.
         * @param {string} rawtx hex-encoded serialized transaction string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInject: function (rawtx, options) {
            return exports.DefaultApiFp(configuration).transactionInject(rawtx, options)(axios, basePath);
        },
        /**
         *
         * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPost: function (transactionV2ParamsAddress, options) {
            return exports.DefaultApiFp(configuration).transactionPost(transactionV2ParamsAddress, options)(axios, basePath);
        },
        /**
         *
         * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionPostUnspent: function (transactionV2ParamsUnspent, options) {
            return exports.DefaultApiFp(configuration).transactionPostUnspent(transactionV2ParamsUnspent, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
         * @param {string} [txid] Transaction id hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRaw: function (txid, options) {
            return exports.DefaultApiFp(configuration).transactionRaw(txid, options)(axios, basePath);
        },
        /**
         * Decode and verify an encoded transaction
         * @param {TransactionVerifyRequest} transactionVerifyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionVerify: function (transactionVerifyRequest, options) {
            return exports.DefaultApiFp(configuration).transactionVerify(transactionVerifyRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsGet: function (addrs, confirmed, options) {
            return exports.DefaultApiFp(configuration).transactionsGet(addrs, confirmed, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns transactions that match the filters.
         * @param {string} [addrs] command separated list of addresses
         * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionsPost: function (addrs, confirmed, options) {
            return exports.DefaultApiFp(configuration).transactionsPost(addrs, confirmed, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns an unspent output by ID.
         * @param {string} [uxid] uxid to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uxout: function (uxid, options) {
            return exports.DefaultApiFp(configuration).uxout(uxid, options)(axios, basePath);
        },
        /**
         *
         * @summary Verifies a Skycoin address.
         * @param {any} address Address id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAddress: function (address, options) {
            return exports.DefaultApiFp(configuration).verifyAddress(address, options)(axios, basePath);
        },
        /**
         * versionHandler returns the application version info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: function (options) {
            return exports.DefaultApiFp(configuration).version(options)(axios, basePath);
        },
        /**
         *
         * @summary Returns a wallet by id.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallet: function (id, options) {
            return exports.DefaultApiFp(configuration).wallet(id, options)(axios, basePath);
        },
        /**
         *
         * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
         * @param {string} id tags to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletBalance: function (id, options) {
            return exports.DefaultApiFp(configuration).walletBalance(id, options)(axios, basePath);
        },
        /**
         * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
         * @param {string} seed Wallet seed.
         * @param {string} label Wallet label.
         * @param {number} [scan] The number of addresses to scan ahead for balances.
         * @param {boolean} [encrypt] Encrypt wallet.
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletCreate: function (seed, label, scan, encrypt, password, options) {
            return exports.DefaultApiFp(configuration).walletCreate(seed, label, scan, encrypt, password, options)(axios, basePath);
        },
        /**
         *
         * @summary Decrypts wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletDecrypt: function (id, password, options) {
            return exports.DefaultApiFp(configuration).walletDecrypt(id, password, options)(axios, basePath);
        },
        /**
         *
         * @summary Encrypt wallet.
         * @param {string} id Wallet id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletEncrypt: function (id, password, options) {
            return exports.DefaultApiFp(configuration).walletEncrypt(id, password, options)(axios, basePath);
        },
        /**
         * Returns the wallet directory path
         * @param {string} addr Address port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletFolder: function (addr, options) {
            return exports.DefaultApiFp(configuration).walletFolder(addr, options)(axios, basePath);
        },
        /**
         * Generates new addresses
         * @param {string} id Wallet Id
         * @param {string} [num] The number you want to generate
         * @param {string} [password] Wallet Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewAddress: function (id, num, password, options) {
            return exports.DefaultApiFp(configuration).walletNewAddress(id, num, password, options)(axios, basePath);
        },
        /**
         * Returns the wallet directory path
         * @param {'128' | '256'} [entropy] Entropy bitSize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletNewSeed: function (entropy, options) {
            return exports.DefaultApiFp(configuration).walletNewSeed(entropy, options)(axios, basePath);
        },
        /**
         *
         * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
         * @param {string} id Wallet id.
         * @param {string} seed Wallet seed.
         * @param {string} [password] Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletRecover: function (id, seed, password, options) {
            return exports.DefaultApiFp(configuration).walletRecover(id, seed, password, options)(axios, basePath);
        },
        /**
         *
         * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
         * @param {string} id Wallet Id.
         * @param {string} password Wallet password.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeed: function (id, password, options) {
            return exports.DefaultApiFp(configuration).walletSeed(id, password, options)(axios, basePath);
        },
        /**
         *
         * @summary Verifies a wallet seed.
         * @param {string} [seed] Seed to be verified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletSeedVerify: function (seed, options) {
            return exports.DefaultApiFp(configuration).walletSeedVerify(seed, options)(axios, basePath);
        },
        /**
         *
         * @summary Creates a signed transaction
         * @param {WalletTransactionRequest} walletTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransaction: function (walletTransactionRequest, options) {
            return exports.DefaultApiFp(configuration).walletTransaction(walletTransactionRequest, options)(axios, basePath);
        },
        /**
         *
         * @summary Creates a signed transaction
         * @param {WalletTransactionSignRequest} walletTransactionSignRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactionSign: function (walletTransactionSignRequest, options) {
            return exports.DefaultApiFp(configuration).walletTransactionSign(walletTransactionSignRequest, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletTransactions: function (id, options) {
            return exports.DefaultApiFp(configuration).walletTransactions(id, options)(axios, basePath);
        },
        /**
         *
         * @summary Unloads wallet from the wallet service.
         * @param {string} id Wallet Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUnload: function (id, options) {
            return exports.DefaultApiFp(configuration).walletUnload(id, options)(axios, basePath);
        },
        /**
         *
         * @summary Update the wallet.
         * @param {string} id Wallet Id.
         * @param {string} label The label the wallet will be updated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletUpdate: function (id, label, options) {
            return exports.DefaultApiFp(configuration).walletUpdate(id, label, options)(axios, basePath);
        },
        /**
         * Returns all loaded wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wallets: function (options) {
            return exports.DefaultApiFp(configuration).wallets(options)(axios, basePath);
        },
    };
};
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
var DefaultApi = /** @class */ (function (_super) {
    __extends(DefaultApi, _super);
    function DefaultApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Returns the total number of unique address that have coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.addressCount = function (options) {
        return exports.DefaultApiFp(this.configuration).addressCount(options)(this.axios, this.basePath);
    };
    /**
     * Returns the historical, spent outputs associated with an address
     * @param {string} address address to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.addressUxouts = function (address, options) {
        return exports.DefaultApiFp(this.configuration).addressUxouts(address, options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.apiV1RawtxGet = function (options) {
        return exports.DefaultApiFp(this.configuration).apiV1RawtxGet(options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.apiV2MetricsGet = function (options) {
        return exports.DefaultApiFp(this.configuration).apiV2MetricsGet(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} addrs command separated list of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.balanceGet = function (addrs, options) {
        return exports.DefaultApiFp(this.configuration).balanceGet(addrs, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} addrs command separated list of addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.balancePost = function (addrs, options) {
        return exports.DefaultApiFp(this.configuration).balancePost(addrs, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} [hash] get block by hash
     * @param {number} [seq] get block by sequence number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.block = function (hash, seq, options) {
        return exports.DefaultApiFp(this.configuration).block(hash, seq, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the blockchain metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.blockchainMetadata = function (options) {
        return exports.DefaultApiFp(this.configuration).blockchainMetadata(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the blockchain sync progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.blockchainProgress = function (options) {
        return exports.DefaultApiFp(this.configuration).blockchainProgress(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * @param {number} [start] start seq
     * @param {number} [end] end seq
     * @param {Array<number>} [seq] comma-separated list of block seqs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.blocks = function (start, end, seq, options) {
        return exports.DefaultApiFp(this.configuration).blocks(start, end, seq, options)(this.axios, this.basePath);
    };
    /**
     * coinSupplyHandler returns coin distribution supply stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.coinSupply = function (options) {
        return exports.DefaultApiFp(this.configuration).coinSupply(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.csrf = function (options) {
        return exports.DefaultApiFp(this.configuration).csrf(options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {string} [type] storage type.
     * @param {string} [key] key of the specific value to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.dataDELETE = function (type, key, options) {
        return exports.DefaultApiFp(this.configuration).dataDELETE(type, key, options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {string} [type] storage type.
     * @param {string} [key] key of the specific value to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.dataGET = function (type, key, options) {
        return exports.DefaultApiFp(this.configuration).dataGET(type, key, options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {string} [type] storage type.
     * @param {string} [key] key of the specific value to get.
     * @param {string} [val] additional value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.dataPOST = function (type, key, val, options) {
        return exports.DefaultApiFp(this.configuration).dataPOST(type, key, val, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.defaultConnections = function (options) {
        return exports.DefaultApiFp(this.configuration).defaultConnections(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns node health data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.health = function (options) {
        return exports.DefaultApiFp(this.configuration).health(options)(this.axios, this.basePath);
    };
    /**
     * Returns the most recent N blocks on the blockchain
     * @param {number} num Num of blockss
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.lastBlocks = function (num, options) {
        return exports.DefaultApiFp(this.configuration).lastBlocks(num, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary This endpoint returns a specific connection.
     * @param {string} addr Address port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.networkConnection = function (addr, options) {
        return exports.DefaultApiFp(this.configuration).networkConnection(addr, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary This endpoint returns all outgoings connections.
     * @param {'pending' | 'connected' | 'introduced'} [states] Connection status.
     * @param {'connected' | 'introduced'} [direction] Direction of the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.networkConnections = function (states, direction, options) {
        return exports.DefaultApiFp(this.configuration).networkConnections(states, direction, options)(this.axios, this.basePath);
    };
    /**
     * This endpoint disconnects a connection by ID or address
     * @param {string} id Address id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.networkConnectionsDisconnect = function (id, options) {
        return exports.DefaultApiFp(this.configuration).networkConnectionsDisconnect(id, options)(this.axios, this.basePath);
    };
    /**
     * This endpoint returns all connections found through peer exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.networkConnectionsExchange = function (options) {
        return exports.DefaultApiFp(this.configuration).networkConnectionsExchange(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.networkConnectionsTrust = function (options) {
        return exports.DefaultApiFp(this.configuration).networkConnectionsTrust(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param {Array<string>} [address]
     * @param {Array<string>} [hash]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.outputsGet = function (address, hash, options) {
        return exports.DefaultApiFp(this.configuration).outputsGet(address, hash, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * @param {string} [address]
     * @param {string} [hash]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.outputsPost = function (address, hash, options) {
        return exports.DefaultApiFp(this.configuration).outputsPost(address, hash, options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.pendingTxs = function (options) {
        return exports.DefaultApiFp(this.configuration).pendingTxs(options)(this.axios, this.basePath);
    };
    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.resendUnconfirmedTxns = function (options) {
        return exports.DefaultApiFp(this.configuration).resendUnconfirmedTxns(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the top skycoin holders.
     * @param {boolean} [includeDistribution] include distribution addresses or not, default value false
     * @param {string} [n] include distribution addresses or not, default value false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.richlist = function (includeDistribution, n, options) {
        return exports.DefaultApiFp(this.configuration).richlist(includeDistribution, n, options)(this.axios, this.basePath);
    };
    /**
     * Returns a transaction identified by its txid hash with just id
     * @param {string} txid transaction Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transaction = function (txid, options) {
        return exports.DefaultApiFp(this.configuration).transaction(txid, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Broadcast a hex-encoded, serialized transaction to the network.
     * @param {string} rawtx hex-encoded serialized transaction string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transactionInject = function (rawtx, options) {
        return exports.DefaultApiFp(this.configuration).transactionInject(rawtx, options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {TransactionV2ParamsAddress} [transactionV2ParamsAddress]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transactionPost = function (transactionV2ParamsAddress, options) {
        return exports.DefaultApiFp(this.configuration).transactionPost(transactionV2ParamsAddress, options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {TransactionV2ParamsUnspent} transactionV2ParamsUnspent Unspent parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transactionPostUnspent = function (transactionV2ParamsUnspent, options) {
        return exports.DefaultApiFp(this.configuration).transactionPostUnspent(transactionV2ParamsUnspent, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * @param {string} [txid] Transaction id hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transactionRaw = function (txid, options) {
        return exports.DefaultApiFp(this.configuration).transactionRaw(txid, options)(this.axios, this.basePath);
    };
    /**
     * Decode and verify an encoded transaction
     * @param {TransactionVerifyRequest} transactionVerifyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transactionVerify = function (transactionVerifyRequest, options) {
        return exports.DefaultApiFp(this.configuration).transactionVerify(transactionVerifyRequest, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns transactions that match the filters.
     * @param {string} [addrs] command separated list of addresses
     * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transactionsGet = function (addrs, confirmed, options) {
        return exports.DefaultApiFp(this.configuration).transactionsGet(addrs, confirmed, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns transactions that match the filters.
     * @param {string} [addrs] command separated list of addresses
     * @param {string} [confirmed] Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.transactionsPost = function (addrs, confirmed, options) {
        return exports.DefaultApiFp(this.configuration).transactionsPost(addrs, confirmed, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns an unspent output by ID.
     * @param {string} [uxid] uxid to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.uxout = function (uxid, options) {
        return exports.DefaultApiFp(this.configuration).uxout(uxid, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Verifies a Skycoin address.
     * @param {any} address Address id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.verifyAddress = function (address, options) {
        return exports.DefaultApiFp(this.configuration).verifyAddress(address, options)(this.axios, this.basePath);
    };
    /**
     * versionHandler returns the application version info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.version = function (options) {
        return exports.DefaultApiFp(this.configuration).version(options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns a wallet by id.
     * @param {string} id tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.wallet = function (id, options) {
        return exports.DefaultApiFp(this.configuration).wallet(id, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * @param {string} id tags to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletBalance = function (id, options) {
        return exports.DefaultApiFp(this.configuration).walletBalance(id, options)(this.axios, this.basePath);
    };
    /**
     * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
     * @param {string} seed Wallet seed.
     * @param {string} label Wallet label.
     * @param {number} [scan] The number of addresses to scan ahead for balances.
     * @param {boolean} [encrypt] Encrypt wallet.
     * @param {string} [password] Wallet Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletCreate = function (seed, label, scan, encrypt, password, options) {
        return exports.DefaultApiFp(this.configuration).walletCreate(seed, label, scan, encrypt, password, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Decrypts wallet.
     * @param {string} id Wallet id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletDecrypt = function (id, password, options) {
        return exports.DefaultApiFp(this.configuration).walletDecrypt(id, password, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Encrypt wallet.
     * @param {string} id Wallet id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletEncrypt = function (id, password, options) {
        return exports.DefaultApiFp(this.configuration).walletEncrypt(id, password, options)(this.axios, this.basePath);
    };
    /**
     * Returns the wallet directory path
     * @param {string} addr Address port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletFolder = function (addr, options) {
        return exports.DefaultApiFp(this.configuration).walletFolder(addr, options)(this.axios, this.basePath);
    };
    /**
     * Generates new addresses
     * @param {string} id Wallet Id
     * @param {string} [num] The number you want to generate
     * @param {string} [password] Wallet Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletNewAddress = function (id, num, password, options) {
        return exports.DefaultApiFp(this.configuration).walletNewAddress(id, num, password, options)(this.axios, this.basePath);
    };
    /**
     * Returns the wallet directory path
     * @param {'128' | '256'} [entropy] Entropy bitSize.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletNewSeed = function (entropy, options) {
        return exports.DefaultApiFp(this.configuration).walletNewSeed(entropy, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * @param {string} id Wallet id.
     * @param {string} seed Wallet seed.
     * @param {string} [password] Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletRecover = function (id, seed, password, options) {
        return exports.DefaultApiFp(this.configuration).walletRecover(id, seed, password, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * @param {string} id Wallet Id.
     * @param {string} password Wallet password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletSeed = function (id, password, options) {
        return exports.DefaultApiFp(this.configuration).walletSeed(id, password, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Verifies a wallet seed.
     * @param {string} [seed] Seed to be verified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletSeedVerify = function (seed, options) {
        return exports.DefaultApiFp(this.configuration).walletSeedVerify(seed, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Creates a signed transaction
     * @param {WalletTransactionRequest} walletTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletTransaction = function (walletTransactionRequest, options) {
        return exports.DefaultApiFp(this.configuration).walletTransaction(walletTransactionRequest, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Creates a signed transaction
     * @param {WalletTransactionSignRequest} walletTransactionSignRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletTransactionSign = function (walletTransactionSignRequest, options) {
        return exports.DefaultApiFp(this.configuration).walletTransactionSign(walletTransactionSignRequest, options)(this.axios, this.basePath);
    };
    /**
     *
     * @param {string} id Wallet Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletTransactions = function (id, options) {
        return exports.DefaultApiFp(this.configuration).walletTransactions(id, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Unloads wallet from the wallet service.
     * @param {string} id Wallet Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletUnload = function (id, options) {
        return exports.DefaultApiFp(this.configuration).walletUnload(id, options)(this.axios, this.basePath);
    };
    /**
     *
     * @summary Update the wallet.
     * @param {string} id Wallet Id.
     * @param {string} label The label the wallet will be updated to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.walletUpdate = function (id, label, options) {
        return exports.DefaultApiFp(this.configuration).walletUpdate(id, label, options)(this.axios, this.basePath);
    };
    /**
     * Returns all loaded wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    DefaultApi.prototype.wallets = function (options) {
        return exports.DefaultApiFp(this.configuration).wallets(options)(this.axios, this.basePath);
    };
    return DefaultApi;
}(BaseAPI));
exports.DefaultApi = DefaultApi;
