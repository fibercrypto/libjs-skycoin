// tslint:disable
/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * The version of the OpenAPI document: 0.27.0
 * Contact: contact@skycoin.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BlockSchema,
    BlockSchemaFromJSON,
    BlockSchemaToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse20010,
    InlineResponse20010FromJSON,
    InlineResponse20010ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    InlineResponse2004,
    InlineResponse2004FromJSON,
    InlineResponse2004ToJSON,
    InlineResponse2005,
    InlineResponse2005FromJSON,
    InlineResponse2005ToJSON,
    InlineResponse2006,
    InlineResponse2006FromJSON,
    InlineResponse2006ToJSON,
    InlineResponse2007,
    InlineResponse2007FromJSON,
    InlineResponse2007ToJSON,
    InlineResponse2008,
    InlineResponse2008FromJSON,
    InlineResponse2008ToJSON,
    InlineResponse2009,
    InlineResponse2009FromJSON,
    InlineResponse2009ToJSON,
    InlineResponseDefault,
    InlineResponseDefaultFromJSON,
    InlineResponseDefaultToJSON,
    NetworkConnectionSchema,
    NetworkConnectionSchemaFromJSON,
    NetworkConnectionSchemaToJSON,
    Transaction,
    TransactionFromJSON,
    TransactionToJSON,
    TransactionV2ParamsAddress,
    TransactionV2ParamsAddressFromJSON,
    TransactionV2ParamsAddressToJSON,
    TransactionV2ParamsUnspent,
    TransactionV2ParamsUnspentFromJSON,
    TransactionV2ParamsUnspentToJSON,
    TransactionVerifyRequest,
    TransactionVerifyRequestFromJSON,
    TransactionVerifyRequestToJSON,
    WalletTransactionRequest,
    WalletTransactionRequestFromJSON,
    WalletTransactionRequestToJSON,
    WalletTransactionSignRequest,
    WalletTransactionSignRequestFromJSON,
    WalletTransactionSignRequestToJSON,
} from '../models';

export interface AddressUxoutsRequest {
    address: string;
}

export interface BalanceGetRequest {
    addrs: string;
}

export interface BalancePostRequest {
    addrs: string;
}

export interface BlockRequest {
    hash?: string;
    seq?: number;
}

export interface BlocksRequest {
    start?: number;
    end?: number;
    seq?: Array<number>;
}

export interface DataDELETERequest {
    type?: string;
    key?: string;
}

export interface DataGETRequest {
    type?: string;
    key?: string;
}

export interface DataPOSTRequest {
    type?: string;
    key?: string;
    val?: string;
}

export interface LastBlocksRequest {
    num: number;
}

export interface NetworkConnectionRequest {
    addr: string;
}

export interface NetworkConnectionsRequest {
    states?: NetworkConnectionsStatesEnum;
    direction?: NetworkConnectionsDirectionEnum;
}

export interface NetworkConnectionsDisconnectRequest {
    id: string;
}

export interface OutputsGetRequest {
    address?: Array<string>;
    hash?: Array<string>;
}

export interface OutputsPostRequest {
    address?: string;
    hash?: string;
}

export interface RichlistRequest {
    includeDistribution?: boolean;
    n?: string;
}

export interface TransactionRequest {
    txid: string;
}

export interface TransactionInjectRequest {
    rawtx: string;
    noBroadcast?: boolean;
}

export interface TransactionPostRequest {
    transactionV2ParamsAddress?: TransactionV2ParamsAddress;
}

export interface TransactionPostUnspentRequest {
    transactionV2ParamsUnspent: TransactionV2ParamsUnspent;
}

export interface TransactionRawRequest {
    txid?: string;
}

export interface TransactionVerifyRequest {
    transactionVerifyRequest: TransactionVerifyRequest;
}

export interface TransactionsGetRequest {
    addrs?: string;
    confirmed?: string;
}

export interface TransactionsPostRequest {
    addrs?: string;
    confirmed?: string;
}

export interface UxoutRequest {
    uxid?: string;
}

export interface VerifyAddressRequest {
    address: object;
}

export interface WalletRequest {
    id: string;
}

export interface WalletBalanceRequest {
    id: string;
}

export interface WalletCreateRequest {
    type: string;
    seed: string;
    label: string;
    seedPassphrase?: string;
    bip44Coin?: string;
    xpub?: string;
    scan?: number;
    encrypt?: boolean;
    password?: string;
}

export interface WalletDecryptRequest {
    id: string;
    password: string;
}

export interface WalletEncryptRequest {
    id: string;
    password: string;
}

export interface WalletFolderRequest {
    addr: string;
}

export interface WalletNewAddressRequest {
    id: string;
    num?: string;
    password?: string;
}

export interface WalletNewSeedRequest {
    entropy?: WalletNewSeedEntropyEnum;
}

export interface WalletRecoverRequest {
    id: string;
    seed: string;
    seedPassphrase?: string;
    password?: string;
}

export interface WalletSeedRequest {
    id: string;
    password: string;
}

export interface WalletSeedVerifyRequest {
    seed?: string;
}

export interface WalletTransactionRequest {
    walletTransactionRequest: WalletTransactionRequest;
}

export interface WalletTransactionSignRequest {
    walletTransactionSignRequest: WalletTransactionSignRequest;
}

export interface WalletTransactionsRequest {
    id: string;
}

export interface WalletUnloadRequest {
    id: string;
}

export interface WalletUpdateRequest {
    id: string;
    label: string;
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Returns the total number of unique address that have coins.
     */
    async addressCountRaw(): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/addresscount`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     * Returns the total number of unique address that have coins.
     */
    async addressCount(): Promise<InlineResponse200> {
        const response = await this.addressCountRaw();
        return await response.value();
    }

    /**
     * Returns the historical, spent outputs associated with an address
     */
    async addressUxoutsRaw(requestParameters: AddressUxoutsRequest): Promise<runtime.ApiResponse<Array<object>>> {
        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address','Required parameter requestParameters.address was null or undefined when calling addressUxouts.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/address_uxouts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the historical, spent outputs associated with an address
     */
    async addressUxouts(requestParameters: AddressUxoutsRequest): Promise<Array<object>> {
        const response = await this.addressUxoutsRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiV1RawtxGetRaw(): Promise<runtime.ApiResponse<string>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/rawtx`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     */
    async apiV1RawtxGet(): Promise<string> {
        const response = await this.apiV1RawtxGetRaw();
        return await response.value();
    }

    /**
     */
    async apiV2MetricsGetRaw(): Promise<runtime.ApiResponse<string>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/metrics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     */
    async apiV2MetricsGet(): Promise<string> {
        const response = await this.apiV2MetricsGetRaw();
        return await response.value();
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balanceGetRaw(requestParameters: BalanceGetRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.addrs === null || requestParameters.addrs === undefined) {
            throw new runtime.RequiredError('addrs','Required parameter requestParameters.addrs was null or undefined when calling balanceGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/balance`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balanceGet(requestParameters: BalanceGetRequest): Promise<object> {
        const response = await this.balanceGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balancePostRaw(requestParameters: BalancePostRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.addrs === null || requestParameters.addrs === undefined) {
            throw new runtime.RequiredError('addrs','Required parameter requestParameters.addrs was null or undefined when calling balancePost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/balance`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balancePost(requestParameters: BalancePostRequest): Promise<object> {
        const response = await this.balancePostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async blockRaw(requestParameters: BlockRequest): Promise<runtime.ApiResponse<Array<BlockSchema>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.hash !== undefined) {
            queryParameters['hash'] = requestParameters.hash;
        }

        if (requestParameters.seq !== undefined) {
            queryParameters['seq'] = requestParameters.seq;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/block`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BlockSchemaFromJSON));
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async block(requestParameters: BlockRequest): Promise<Array<BlockSchema>> {
        const response = await this.blockRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the blockchain metadata.
     */
    async blockchainMetadataRaw(): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/blockchain/metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the blockchain metadata.
     */
    async blockchainMetadata(): Promise<object> {
        const response = await this.blockchainMetadataRaw();
        return await response.value();
    }

    /**
     * Returns the blockchain sync progress.
     */
    async blockchainProgressRaw(): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/blockchain/progress`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the blockchain sync progress.
     */
    async blockchainProgress(): Promise<object> {
        const response = await this.blockchainProgressRaw();
        return await response.value();
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async blocksRaw(requestParameters: BlocksRequest): Promise<runtime.ApiResponse<InlineResponse2001>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = requestParameters.end;
        }

        if (requestParameters.seq) {
            queryParameters['seq'] = requestParameters.seq;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/blocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async blocks(requestParameters: BlocksRequest): Promise<InlineResponse2001> {
        const response = await this.blocksRaw(requestParameters);
        return await response.value();
    }

    /**
     * coinSupplyHandler returns coin distribution supply stats
     */
    async coinSupplyRaw(): Promise<runtime.ApiResponse<InlineResponse2002>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/coinSupply`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2002FromJSON(jsonValue));
    }

    /**
     * coinSupplyHandler returns coin distribution supply stats
     */
    async coinSupply(): Promise<InlineResponse2002> {
        const response = await this.coinSupplyRaw();
        return await response.value();
    }

    /**
     * Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     */
    async csrfRaw(): Promise<runtime.ApiResponse<InlineResponse2003>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/csrf`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     * Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     */
    async csrf(): Promise<InlineResponse2003> {
        const response = await this.csrfRaw();
        return await response.value();
    }

    /**
     */
    async dataDELETERaw(requestParameters: DataDELETERequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.type !== undefined && requestParameters.type !== null) {
            headerParameters['type'] = String(requestParameters.type);
        }

        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            headerParameters['key'] = String(requestParameters.key);
        }

        const response = await this.request({
            path: `/api/v2/data`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async dataDELETE(requestParameters: DataDELETERequest): Promise<void> {
        await this.dataDELETERaw(requestParameters);
    }

    /**
     */
    async dataGETRaw(requestParameters: DataGETRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.type !== undefined && requestParameters.type !== null) {
            headerParameters['type'] = String(requestParameters.type);
        }

        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            headerParameters['key'] = String(requestParameters.key);
        }

        const response = await this.request({
            path: `/api/v2/data`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     */
    async dataGET(requestParameters: DataGETRequest): Promise<object> {
        const response = await this.dataGETRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async dataPOSTRaw(requestParameters: DataPOSTRequest): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.type !== undefined && requestParameters.type !== null) {
            headerParameters['type'] = String(requestParameters.type);
        }

        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            headerParameters['key'] = String(requestParameters.key);
        }

        if (requestParameters.val !== undefined && requestParameters.val !== null) {
            headerParameters['val'] = String(requestParameters.val);
        }

        const response = await this.request({
            path: `/api/v2/data`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async dataPOST(requestParameters: DataPOSTRequest): Promise<void> {
        await this.dataPOSTRaw(requestParameters);
    }

    /**
     * defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     */
    async defaultConnectionsRaw(): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/network/defaultConnections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     */
    async defaultConnections(): Promise<Array<string>> {
        const response = await this.defaultConnectionsRaw();
        return await response.value();
    }

    /**
     * Returns node health data.
     */
    async healthRaw(): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns node health data.
     */
    async health(): Promise<object> {
        const response = await this.healthRaw();
        return await response.value();
    }

    /**
     * Returns the most recent N blocks on the blockchain
     */
    async lastBlocksRaw(requestParameters: LastBlocksRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.num === null || requestParameters.num === undefined) {
            throw new runtime.RequiredError('num','Required parameter requestParameters.num was null or undefined when calling lastBlocks.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.num !== undefined) {
            queryParameters['num'] = requestParameters.num;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/last_blocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the most recent N blocks on the blockchain
     */
    async lastBlocks(requestParameters: LastBlocksRequest): Promise<object> {
        const response = await this.lastBlocksRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns a specific connection.
     */
    async networkConnectionRaw(requestParameters: NetworkConnectionRequest): Promise<runtime.ApiResponse<NetworkConnectionSchema>> {
        if (requestParameters.addr === null || requestParameters.addr === undefined) {
            throw new runtime.RequiredError('addr','Required parameter requestParameters.addr was null or undefined when calling networkConnection.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addr !== undefined) {
            queryParameters['addr'] = requestParameters.addr;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/network/connection`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => NetworkConnectionSchemaFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a specific connection.
     */
    async networkConnection(requestParameters: NetworkConnectionRequest): Promise<NetworkConnectionSchema> {
        const response = await this.networkConnectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns all outgoings connections.
     */
    async networkConnectionsRaw(requestParameters: NetworkConnectionsRequest): Promise<runtime.ApiResponse<InlineResponse2004>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.states !== undefined) {
            queryParameters['states'] = requestParameters.states;
        }

        if (requestParameters.direction !== undefined) {
            queryParameters['direction'] = requestParameters.direction;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/network/connections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2004FromJSON(jsonValue));
    }

    /**
     * This endpoint returns all outgoings connections.
     */
    async networkConnections(requestParameters: NetworkConnectionsRequest): Promise<InlineResponse2004> {
        const response = await this.networkConnectionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint disconnects a connection by ID or address
     */
    async networkConnectionsDisconnectRaw(requestParameters: NetworkConnectionsDisconnectRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling networkConnectionsDisconnect.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/network/connection/disconnect`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint disconnects a connection by ID or address
     */
    async networkConnectionsDisconnect(requestParameters: NetworkConnectionsDisconnectRequest): Promise<void> {
        await this.networkConnectionsDisconnectRaw(requestParameters);
    }

    /**
     * This endpoint returns all connections found through peer exchange
     */
    async networkConnectionsExchangeRaw(): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/network/connections/exchange`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This endpoint returns all connections found through peer exchange
     */
    async networkConnectionsExchange(): Promise<Array<string>> {
        const response = await this.networkConnectionsExchangeRaw();
        return await response.value();
    }

    /**
     * trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     */
    async networkConnectionsTrustRaw(): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/network/connections/trust`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     */
    async networkConnectionsTrust(): Promise<Array<string>> {
        const response = await this.networkConnectionsTrustRaw();
        return await response.value();
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsGetRaw(requestParameters: OutputsGetRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.hash) {
            queryParameters['hash'] = requestParameters.hash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/outputs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsGet(requestParameters: OutputsGetRequest): Promise<object> {
        const response = await this.outputsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsPostRaw(requestParameters: OutputsPostRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.hash !== undefined) {
            queryParameters['hash'] = requestParameters.hash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/outputs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsPost(requestParameters: OutputsPostRequest): Promise<object> {
        const response = await this.outputsPostRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async pendingTxsRaw(): Promise<runtime.ApiResponse<Array<InlineResponse20010>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/pendingTxs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InlineResponse20010FromJSON));
    }

    /**
     */
    async pendingTxs(): Promise<Array<InlineResponse20010>> {
        const response = await this.pendingTxsRaw();
        return await response.value();
    }

    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     */
    async resendUnconfirmedTxnsRaw(): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/resendUnconfirmedTxns`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     */
    async resendUnconfirmedTxns(): Promise<object> {
        const response = await this.resendUnconfirmedTxnsRaw();
        return await response.value();
    }

    /**
     * Returns the top skycoin holders.
     */
    async richlistRaw(requestParameters: RichlistRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.includeDistribution !== undefined) {
            queryParameters['include-distribution'] = requestParameters.includeDistribution;
        }

        if (requestParameters.n !== undefined) {
            queryParameters['n'] = requestParameters.n;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/richlist`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the top skycoin holders.
     */
    async richlist(requestParameters: RichlistRequest): Promise<object> {
        const response = await this.richlistRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a transaction identified by its txid hash with just id
     */
    async transactionRaw(requestParameters: TransactionRequest): Promise<runtime.ApiResponse<Transaction>> {
        if (requestParameters.txid === null || requestParameters.txid === undefined) {
            throw new runtime.RequiredError('txid','Required parameter requestParameters.txid was null or undefined when calling transaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.txid !== undefined) {
            queryParameters['txid'] = requestParameters.txid;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/transaction`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionFromJSON(jsonValue));
    }

    /**
     * Returns a transaction identified by its txid hash with just id
     */
    async transaction(requestParameters: TransactionRequest): Promise<Transaction> {
        const response = await this.transactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Broadcast a hex-encoded, serialized transaction to the network.
     */
    async transactionInjectRaw(requestParameters: TransactionInjectRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.rawtx === null || requestParameters.rawtx === undefined) {
            throw new runtime.RequiredError('rawtx','Required parameter requestParameters.rawtx was null or undefined when calling transactionInject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.rawtx !== undefined && requestParameters.rawtx !== null) {
            headerParameters['rawtx'] = String(requestParameters.rawtx);
        }

        if (requestParameters.noBroadcast !== undefined && requestParameters.noBroadcast !== null) {
            headerParameters['no_broadcast'] = String(requestParameters.noBroadcast);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/injectTransaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Broadcast a hex-encoded, serialized transaction to the network.
     */
    async transactionInject(requestParameters: TransactionInjectRequest): Promise<string> {
        const response = await this.transactionInjectRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async transactionPostRaw(requestParameters: TransactionPostRequest): Promise<runtime.ApiResponse<InlineResponse2008>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionV2ParamsAddressToJSON(requestParameters.transactionV2ParamsAddress),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2008FromJSON(jsonValue));
    }

    /**
     */
    async transactionPost(requestParameters: TransactionPostRequest): Promise<InlineResponse2008> {
        const response = await this.transactionPostRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async transactionPostUnspentRaw(requestParameters: TransactionPostUnspentRequest): Promise<runtime.ApiResponse<InlineResponse2008>> {
        if (requestParameters.transactionV2ParamsUnspent === null || requestParameters.transactionV2ParamsUnspent === undefined) {
            throw new runtime.RequiredError('transactionV2ParamsUnspent','Required parameter requestParameters.transactionV2ParamsUnspent was null or undefined when calling transactionPostUnspent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/transaction/unspent`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionV2ParamsUnspentToJSON(requestParameters.transactionV2ParamsUnspent),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2008FromJSON(jsonValue));
    }

    /**
     */
    async transactionPostUnspent(requestParameters: TransactionPostUnspentRequest): Promise<InlineResponse2008> {
        const response = await this.transactionPostUnspentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     */
    async transactionRawRaw(requestParameters: TransactionRawRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.txid !== undefined) {
            queryParameters['txid'] = requestParameters.txid;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/transaction/raw`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     */
    async transactionRaw(requestParameters: TransactionRawRequest): Promise<object> {
        const response = await this.transactionRawRaw(requestParameters);
        return await response.value();
    }

    /**
     * Decode and verify an encoded transaction
     */
    async transactionVerifyRaw(requestParameters: TransactionVerifyRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.transactionVerifyRequest === null || requestParameters.transactionVerifyRequest === undefined) {
            throw new runtime.RequiredError('transactionVerifyRequest','Required parameter requestParameters.transactionVerifyRequest was null or undefined when calling transactionVerify.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/transaction/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionVerifyRequestToJSON(requestParameters.transactionVerifyRequest),
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Decode and verify an encoded transaction
     */
    async transactionVerify(requestParameters: TransactionVerifyRequest): Promise<object> {
        const response = await this.transactionVerifyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsGetRaw(requestParameters: TransactionsGetRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        if (requestParameters.confirmed !== undefined) {
            queryParameters['confirmed'] = requestParameters.confirmed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsGet(requestParameters: TransactionsGetRequest): Promise<object> {
        const response = await this.transactionsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsPostRaw(requestParameters: TransactionsPostRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        if (requestParameters.confirmed !== undefined) {
            queryParameters['confirmed'] = requestParameters.confirmed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsPost(requestParameters: TransactionsPostRequest): Promise<object> {
        const response = await this.transactionsPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns an unspent output by ID.
     */
    async uxoutRaw(requestParameters: UxoutRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.uxid !== undefined) {
            queryParameters['uxid'] = requestParameters.uxid;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/uxout`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns an unspent output by ID.
     */
    async uxout(requestParameters: UxoutRequest): Promise<object> {
        const response = await this.uxoutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verifies a Skycoin address.
     */
    async verifyAddressRaw(requestParameters: VerifyAddressRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address','Required parameter requestParameters.address was null or undefined when calling verifyAddress.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/address/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Verifies a Skycoin address.
     */
    async verifyAddress(requestParameters: VerifyAddressRequest): Promise<object> {
        const response = await this.verifyAddressRaw(requestParameters);
        return await response.value();
    }

    /**
     * versionHandler returns the application version info
     */
    async versionRaw(): Promise<runtime.ApiResponse<InlineResponse2005>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2005FromJSON(jsonValue));
    }

    /**
     * versionHandler returns the application version info
     */
    async version(): Promise<InlineResponse2005> {
        const response = await this.versionRaw();
        return await response.value();
    }

    /**
     * Returns a wallet by id.
     */
    async walletRaw(requestParameters: WalletRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling wallet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns a wallet by id.
     */
    async wallet(requestParameters: WalletRequest): Promise<object> {
        const response = await this.walletRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the wallet\'s balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     */
    async walletBalanceRaw(requestParameters: WalletBalanceRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletBalance.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet/balance`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the wallet\'s balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     */
    async walletBalance(requestParameters: WalletBalanceRequest): Promise<object> {
        const response = await this.walletBalanceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a wallet
     */
    async walletCreateRaw(requestParameters: WalletCreateRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling walletCreate.');
        }

        if (requestParameters.seed === null || requestParameters.seed === undefined) {
            throw new runtime.RequiredError('seed','Required parameter requestParameters.seed was null or undefined when calling walletCreate.');
        }

        if (requestParameters.label === null || requestParameters.label === undefined) {
            throw new runtime.RequiredError('label','Required parameter requestParameters.label was null or undefined when calling walletCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.seedPassphrase !== undefined && requestParameters.seedPassphrase !== null) {
            headerParameters['seed-passphrase'] = String(requestParameters.seedPassphrase);
        }

        if (requestParameters.type !== undefined && requestParameters.type !== null) {
            headerParameters['type'] = String(requestParameters.type);
        }

        if (requestParameters.bip44Coin !== undefined && requestParameters.bip44Coin !== null) {
            headerParameters['bip44-coin'] = String(requestParameters.bip44Coin);
        }

        if (requestParameters.seed !== undefined && requestParameters.seed !== null) {
            headerParameters['seed'] = String(requestParameters.seed);
        }

        if (requestParameters.xpub !== undefined && requestParameters.xpub !== null) {
            headerParameters['xpub'] = String(requestParameters.xpub);
        }

        if (requestParameters.label !== undefined && requestParameters.label !== null) {
            headerParameters['label'] = String(requestParameters.label);
        }

        if (requestParameters.scan !== undefined && requestParameters.scan !== null) {
            headerParameters['scan'] = String(requestParameters.scan);
        }

        if (requestParameters.encrypt !== undefined && requestParameters.encrypt !== null) {
            headerParameters['encrypt'] = String(requestParameters.encrypt);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Create a wallet
     */
    async walletCreate(requestParameters: WalletCreateRequest): Promise<object> {
        const response = await this.walletCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Decrypts wallet.
     */
    async walletDecryptRaw(requestParameters: WalletDecryptRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletDecrypt.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling walletDecrypt.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/decrypt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Decrypts wallet.
     */
    async walletDecrypt(requestParameters: WalletDecryptRequest): Promise<object> {
        const response = await this.walletDecryptRaw(requestParameters);
        return await response.value();
    }

    /**
     * Encrypt wallet.
     */
    async walletEncryptRaw(requestParameters: WalletEncryptRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletEncrypt.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling walletEncrypt.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/encrypt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Encrypt wallet.
     */
    async walletEncrypt(requestParameters: WalletEncryptRequest): Promise<object> {
        const response = await this.walletEncryptRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the wallet directory path
     */
    async walletFolderRaw(requestParameters: WalletFolderRequest): Promise<runtime.ApiResponse<InlineResponse2007>> {
        if (requestParameters.addr === null || requestParameters.addr === undefined) {
            throw new runtime.RequiredError('addr','Required parameter requestParameters.addr was null or undefined when calling walletFolder.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addr !== undefined) {
            queryParameters['addr'] = requestParameters.addr;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallets/folderName`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2007FromJSON(jsonValue));
    }

    /**
     * Returns the wallet directory path
     */
    async walletFolder(requestParameters: WalletFolderRequest): Promise<InlineResponse2007> {
        const response = await this.walletFolderRaw(requestParameters);
        return await response.value();
    }

    /**
     * Generates new addresses
     */
    async walletNewAddressRaw(requestParameters: WalletNewAddressRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletNewAddress.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.num !== undefined) {
            queryParameters['num'] = requestParameters.num;
        }

        if (requestParameters.password !== undefined) {
            queryParameters['password'] = requestParameters.password;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/newAddress`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Generates new addresses
     */
    async walletNewAddress(requestParameters: WalletNewAddressRequest): Promise<object> {
        const response = await this.walletNewAddressRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the wallet directory path
     */
    async walletNewSeedRaw(requestParameters: WalletNewSeedRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.entropy !== undefined) {
            queryParameters['entropy'] = requestParameters.entropy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet/newSeed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the wallet directory path
     */
    async walletNewSeed(requestParameters: WalletNewSeedRequest): Promise<object> {
        const response = await this.walletNewSeedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Recovers an encrypted wallet by providing the wallet seed and optional seed passphrase
     * Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     */
    async walletRecoverRaw(requestParameters: WalletRecoverRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletRecover.');
        }

        if (requestParameters.seed === null || requestParameters.seed === undefined) {
            throw new runtime.RequiredError('seed','Required parameter requestParameters.seed was null or undefined when calling walletRecover.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.seed !== undefined && requestParameters.seed !== null) {
            headerParameters['seed'] = String(requestParameters.seed);
        }

        if (requestParameters.seedPassphrase !== undefined && requestParameters.seedPassphrase !== null) {
            headerParameters['seed-passphrase'] = String(requestParameters.seedPassphrase);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/wallet/recover`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Recovers an encrypted wallet by providing the wallet seed and optional seed passphrase
     * Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     */
    async walletRecover(requestParameters: WalletRecoverRequest): Promise<object> {
        const response = await this.walletRecoverRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     */
    async walletSeedRaw(requestParameters: WalletSeedRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletSeed.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling walletSeed.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.password !== undefined) {
            queryParameters['password'] = requestParameters.password;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/seed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     */
    async walletSeed(requestParameters: WalletSeedRequest): Promise<object> {
        const response = await this.walletSeedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verifies a wallet seed.
     */
    async walletSeedVerifyRaw(requestParameters: WalletSeedVerifyRequest): Promise<runtime.ApiResponse<object>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.seed !== undefined && requestParameters.seed !== null) {
            headerParameters['seed'] = String(requestParameters.seed);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/wallet/seed/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Verifies a wallet seed.
     */
    async walletSeedVerify(requestParameters: WalletSeedVerifyRequest): Promise<object> {
        const response = await this.walletSeedVerifyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a signed transaction
     */
    async walletTransactionRaw(requestParameters: WalletTransactionRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.walletTransactionRequest === null || requestParameters.walletTransactionRequest === undefined) {
            throw new runtime.RequiredError('walletTransactionRequest','Required parameter requestParameters.walletTransactionRequest was null or undefined when calling walletTransaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WalletTransactionRequestToJSON(requestParameters.walletTransactionRequest),
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Creates a signed transaction
     */
    async walletTransaction(requestParameters: WalletTransactionRequest): Promise<object> {
        const response = await this.walletTransactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a signed transaction
     */
    async walletTransactionSignRaw(requestParameters: WalletTransactionSignRequest): Promise<runtime.ApiResponse<InlineResponse2009>> {
        if (requestParameters.walletTransactionSignRequest === null || requestParameters.walletTransactionSignRequest === undefined) {
            throw new runtime.RequiredError('walletTransactionSignRequest','Required parameter requestParameters.walletTransactionSignRequest was null or undefined when calling walletTransactionSign.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/wallet/transaction/sign`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WalletTransactionSignRequestToJSON(requestParameters.walletTransactionSignRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2009FromJSON(jsonValue));
    }

    /**
     * Creates a signed transaction
     */
    async walletTransactionSign(requestParameters: WalletTransactionSignRequest): Promise<InlineResponse2009> {
        const response = await this.walletTransactionSignRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async walletTransactionsRaw(requestParameters: WalletTransactionsRequest): Promise<runtime.ApiResponse<InlineResponse2006>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletTransactions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2006FromJSON(jsonValue));
    }

    /**
     */
    async walletTransactions(requestParameters: WalletTransactionsRequest): Promise<InlineResponse2006> {
        const response = await this.walletTransactionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Unloads wallet from the wallet service.
     */
    async walletUnloadRaw(requestParameters: WalletUnloadRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletUnload.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/unload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unloads wallet from the wallet service.
     */
    async walletUnload(requestParameters: WalletUnloadRequest): Promise<void> {
        await this.walletUnloadRaw(requestParameters);
    }

    /**
     * Update the wallet.
     */
    async walletUpdateRaw(requestParameters: WalletUpdateRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletUpdate.');
        }

        if (requestParameters.label === null || requestParameters.label === undefined) {
            throw new runtime.RequiredError('label','Required parameter requestParameters.label was null or undefined when calling walletUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.label !== undefined && requestParameters.label !== null) {
            headerParameters['label'] = String(requestParameters.label);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Update the wallet.
     */
    async walletUpdate(requestParameters: WalletUpdateRequest): Promise<string> {
        const response = await this.walletUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns all loaded wallets
     */
    async walletsRaw(): Promise<runtime.ApiResponse<Array<object>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns all loaded wallets
     */
    async wallets(): Promise<Array<object>> {
        const response = await this.walletsRaw();
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum NetworkConnectionsStatesEnum {
    Pending = 'pending',
    Connected = 'connected',
    Introduced = 'introduced'
}
/**
    * @export
    * @enum {string}
    */
export enum NetworkConnectionsDirectionEnum {
    Connected = 'connected',
    Introduced = 'introduced'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletNewSeedEntropyEnum {
    _128 = '128',
    _256 = '256'
}
