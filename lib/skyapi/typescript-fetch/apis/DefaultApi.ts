// tslint:disable
/**
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * OpenAPI spec version: 0.25.1
 * Contact: skycoin.doe@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    InlineObject,
    InlineObjectFromJSON,
    InlineObjectToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    InlineResponse2001,
    InlineResponse2001FromJSON,
    InlineResponse2001ToJSON,
    InlineResponse2002,
    InlineResponse2002FromJSON,
    InlineResponse2002ToJSON,
    InlineResponse2003,
    InlineResponse2003FromJSON,
    InlineResponse2003ToJSON,
    InlineResponse2004,
    InlineResponse2004FromJSON,
    InlineResponse2004ToJSON,
    InlineResponse2005,
    InlineResponse2005FromJSON,
    InlineResponse2005ToJSON,
    InlineResponse2006,
    InlineResponse2006FromJSON,
    InlineResponse2006ToJSON,
    InlineResponse2007,
    InlineResponse2007FromJSON,
    InlineResponse2007ToJSON,
    InlineResponseDefault,
    InlineResponseDefaultFromJSON,
    InlineResponseDefaultToJSON,
} from '../models';

export interface AddressUxoutsRequest {
    address: string;
}

export interface BalanceGetRequest {
    addrs: string;
}

export interface BalancePostRequest {
    addrs: string;
}

export interface BlockRequest {
    hash?: string;
    seq?: number;
}

export interface BlocksGetRequest {
    start?: number;
    end?: number;
    seqs?: Array<number>;
}

export interface BlocksPostRequest {
    start?: number;
    end?: number;
    seqs?: Array<number>;
}

export interface ExplorerAddressRequest {
    address?: string;
}

export interface LastBlocksRequest {
    num: number;
}

export interface NetworkConnectionRequest {
    addr: string;
}

export interface NetworkConnectionsRequest {
    states?: NetworkConnectionsStatesEnum;
    direction?: NetworkConnectionsDirectionEnum;
}

export interface NetworkConnectionsDisconnectRequest {
    id: string;
}

export interface OutputsGetRequest {
    address?: Array<string>;
    hash?: Array<string>;
}

export interface OutputsPostRequest {
    address?: string;
    hash?: string;
}

export interface RichlistRequest {
    includeDistribution?: boolean;
    n?: string;
}

export interface TransactionRequest {
    txid: string;
    encoded?: boolean;
}

export interface TransactionInjectRequest {
    rawtx: string;
}

export interface TransactionRawRequest {
    txid?: string;
}

export interface TransactionsGetRequest {
    addrs?: string;
    confirmed?: string;
}

export interface TransactionsPostRequest {
    addrs?: string;
    confirmed?: string;
}

export interface UxoutRequest {
    uxid?: string;
}

export interface VerifyAddressRequest {
    address: string;
}

export interface WalletRequest {
    id: string;
}

export interface WalletBalanceRequest {
    id: string;
}

export interface WalletCreateRequest {
    seed: string;
    label: string;
    scan?: number;
    encrypt?: boolean;
    password?: string;
}

export interface WalletDecryptRequest {
    id: string;
    password: string;
}

export interface WalletEncryptRequest {
    id: string;
    password: string;
}

export interface WalletFolderRequest {
    addr: string;
}

export interface WalletNewAddressRequest {
    id: string;
    num?: string;
    password?: string;
}

export interface WalletNewSeedRequest {
    entropy?: WalletNewSeedEntropyEnum;
}

export interface WalletRecoverRequest {
    id: string;
    seed: string;
    password?: string;
}

export interface WalletSeedRequest {
    id: string;
    password: string;
}

export interface WalletSeedVerifyRequest {
    seed?: string;
}

export interface WalletSpentRequest {
    id: string;
    dst: string;
    coins: string;
    password: string;
}

export interface WalletTransactionRequest {
    body: InlineObject;
}

export interface WalletTransactionsRequest {
    id: string;
}

export interface WalletUnloadRequest {
    id: string;
}

export interface WalletUpdateRequest {
    id: string;
    label: string;
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Returns the total number of unique address that have coins.
     */
    async addressCountRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/addresscount`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the total number of unique address that have coins.
     */
    async addressCount(): Promise<any> {
        const response = await this.addressCountRaw();
        return await response.value();
    }

    /**
     * Returns the historical, spent outputs associated with an address
     */
    async addressUxoutsRaw(requestParameters: AddressUxoutsRequest): Promise<runtime.ApiResponse<Array<InlineResponse200>>> {
        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address','Required parameter requestParameters.address was null or undefined when calling addressUxouts.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/address_uxouts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InlineResponse200FromJSON));
    }

    /**
     * Returns the historical, spent outputs associated with an address
     */
    async addressUxouts(requestParameters: AddressUxoutsRequest): Promise<Array<InlineResponse200>> {
        const response = await this.addressUxoutsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balanceGetRaw(requestParameters: BalanceGetRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.addrs === null || requestParameters.addrs === undefined) {
            throw new runtime.RequiredError('addrs','Required parameter requestParameters.addrs was null or undefined when calling balanceGet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/balance`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balanceGet(requestParameters: BalanceGetRequest): Promise<any> {
        const response = await this.balanceGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balancePostRaw(requestParameters: BalancePostRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.addrs === null || requestParameters.addrs === undefined) {
            throw new runtime.RequiredError('addrs','Required parameter requestParameters.addrs was null or undefined when calling balancePost.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/balance`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     */
    async balancePost(requestParameters: BalancePostRequest): Promise<any> {
        const response = await this.balancePostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a block by hash or seq. Note: only one of hash or seq is allowed
     */
    async blockRaw(requestParameters: BlockRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.hash !== undefined) {
            queryParameters['hash'] = requestParameters.hash;
        }

        if (requestParameters.seq !== undefined) {
            queryParameters['seq'] = requestParameters.seq;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/block`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns a block by hash or seq. Note: only one of hash or seq is allowed
     */
    async block(requestParameters: BlockRequest): Promise<any> {
        const response = await this.blockRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the blockchain metadata.
     */
    async blockchainMetadataRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/blockchain/metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the blockchain metadata.
     */
    async blockchainMetadata(): Promise<any> {
        const response = await this.blockchainMetadataRaw();
        return await response.value();
    }

    /**
     * Returns the blockchain sync progress.
     */
    async blockchainProgressRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/blockchain/progress`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the blockchain sync progress.
     */
    async blockchainProgress(): Promise<any> {
        const response = await this.blockchainProgressRaw();
        return await response.value();
    }

    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
     * blocksHandler returns blocks between a start and end point,
     */
    async blocksGetRaw(requestParameters: BlocksGetRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = requestParameters.end;
        }

        if (requestParameters.seqs) {
            queryParameters['seqs'] = requestParameters.seqs.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/blocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose.
     * blocksHandler returns blocks between a start and end point,
     */
    async blocksGet(requestParameters: BlocksGetRequest): Promise<any> {
        const response = await this.blocksGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
     * blocksHandler returns blocks between a start and end point,
     */
    async blocksPostRaw(requestParameters: BlocksPostRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = requestParameters.end;
        }

        if (requestParameters.seqs) {
            queryParameters['seqs'] = requestParameters.seqs.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/blocks`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * or an explicit list of sequences. If using start and end, the block sequences include both the start and end point. Explicit sequences cannot be combined with start and end. Without verbose
     * blocksHandler returns blocks between a start and end point,
     */
    async blocksPost(requestParameters: BlocksPostRequest): Promise<any> {
        const response = await this.blocksPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * coinSupplyHandler returns coin distribution supply stats
     */
    async coinSupplyRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/coinSupply`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * coinSupplyHandler returns coin distribution supply stats
     */
    async coinSupply(): Promise<void> {
        await this.coinSupplyRaw();
    }

    /**
     * Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     */
    async csrfRaw(): Promise<runtime.ApiResponse<InlineResponse2001>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/csrf`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2001FromJSON(jsonValue));
    }

    /**
     * Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     */
    async csrf(): Promise<InlineResponse2001> {
        const response = await this.csrfRaw();
        return await response.value();
    }

    /**
     * defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     */
    async defaultConnectionsRaw(): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/network/defaultConnections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     */
    async defaultConnections(): Promise<Array<string>> {
        const response = await this.defaultConnectionsRaw();
        return await response.value();
    }

    /**
     * Returns all transactions (confirmed and unconfirmed) for an address
     */
    async explorerAddressRaw(requestParameters: ExplorerAddressRequest): Promise<runtime.ApiResponse<Array<InlineResponse2002>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/explorer/address`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InlineResponse2002FromJSON));
    }

    /**
     * Returns all transactions (confirmed and unconfirmed) for an address
     */
    async explorerAddress(requestParameters: ExplorerAddressRequest): Promise<Array<InlineResponse2002>> {
        const response = await this.explorerAddressRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns node health data.
     */
    async healthRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns node health data.
     */
    async health(): Promise<any> {
        const response = await this.healthRaw();
        return await response.value();
    }

    /**
     * Returns the most recent N blocks on the blockchain
     */
    async lastBlocksRaw(requestParameters: LastBlocksRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.num === null || requestParameters.num === undefined) {
            throw new runtime.RequiredError('num','Required parameter requestParameters.num was null or undefined when calling lastBlocks.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.num !== undefined) {
            queryParameters['num'] = requestParameters.num;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/last_blocks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the most recent N blocks on the blockchain
     */
    async lastBlocks(requestParameters: LastBlocksRequest): Promise<any> {
        const response = await this.lastBlocksRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns a specific connection.
     */
    async networkConnectionRaw(requestParameters: NetworkConnectionRequest): Promise<runtime.ApiResponse<InlineResponse2003>> {
        if (requestParameters.addr === null || requestParameters.addr === undefined) {
            throw new runtime.RequiredError('addr','Required parameter requestParameters.addr was null or undefined when calling networkConnection.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addr !== undefined) {
            queryParameters['addr'] = requestParameters.addr;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/network/connection`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2003FromJSON(jsonValue));
    }

    /**
     * This endpoint returns a specific connection.
     */
    async networkConnection(requestParameters: NetworkConnectionRequest): Promise<InlineResponse2003> {
        const response = await this.networkConnectionRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint returns all outgoings connections.
     */
    async networkConnectionsRaw(requestParameters: NetworkConnectionsRequest): Promise<runtime.ApiResponse<Array<InlineResponse2003>>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.states !== undefined) {
            queryParameters['states'] = requestParameters.states;
        }

        if (requestParameters.direction !== undefined) {
            queryParameters['direction'] = requestParameters.direction;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/network/connections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InlineResponse2003FromJSON));
    }

    /**
     * This endpoint returns all outgoings connections.
     */
    async networkConnections(requestParameters: NetworkConnectionsRequest): Promise<Array<InlineResponse2003>> {
        const response = await this.networkConnectionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint disconnects a connection by ID or address
     */
    async networkConnectionsDisconnectRaw(requestParameters: NetworkConnectionsDisconnectRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling networkConnectionsDisconnect.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/network/connection/disconnect`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint disconnects a connection by ID or address
     */
    async networkConnectionsDisconnect(requestParameters: NetworkConnectionsDisconnectRequest): Promise<void> {
        await this.networkConnectionsDisconnectRaw(requestParameters);
    }

    /**
     * This endpoint returns all connections found through peer exchange
     */
    async networkConnectionsExchangeRaw(): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/network/connections/exchange`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This endpoint returns all connections found through peer exchange
     */
    async networkConnectionsExchange(): Promise<Array<string>> {
        const response = await this.networkConnectionsExchangeRaw();
        return await response.value();
    }

    /**
     * trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     */
    async networkConnectionsTrustRaw(): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/network/connections/trust`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     */
    async networkConnectionsTrust(): Promise<Array<string>> {
        const response = await this.networkConnectionsTrustRaw();
        return await response.value();
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsGetRaw(requestParameters: OutputsGetRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address) {
            queryParameters['address'] = requestParameters.address.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.hash) {
            queryParameters['hash'] = requestParameters.hash.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/outputs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsGet(requestParameters: OutputsGetRequest): Promise<any> {
        const response = await this.outputsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsPostRaw(requestParameters: OutputsPostRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.hash !== undefined) {
            queryParameters['hash'] = requestParameters.hash;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/outputs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     */
    async outputsPost(requestParameters: OutputsPostRequest): Promise<any> {
        const response = await this.outputsPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns pending (unconfirmed) transactions without verbose
     */
    async pendingTxsRaw(): Promise<runtime.ApiResponse<Array<InlineResponse2004>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/pendingTxs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InlineResponse2004FromJSON));
    }

    /**
     * Returns pending (unconfirmed) transactions without verbose
     */
    async pendingTxs(): Promise<Array<InlineResponse2004>> {
        const response = await this.pendingTxsRaw();
        return await response.value();
    }

    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     */
    async resendUnconfirmedTxnsRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/resendUnconfirmedTxns`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     */
    async resendUnconfirmedTxns(): Promise<void> {
        await this.resendUnconfirmedTxnsRaw();
    }

    /**
     * Returns the top skycoin holders.
     */
    async richlistRaw(requestParameters: RichlistRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.includeDistribution !== undefined) {
            queryParameters['include-distribution'] = requestParameters.includeDistribution;
        }

        if (requestParameters.n !== undefined) {
            queryParameters['n'] = requestParameters.n;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/richlist`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the top skycoin holders.
     */
    async richlist(requestParameters: RichlistRequest): Promise<any> {
        const response = await this.richlistRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a transaction identified by its txid hash with just id
     */
    async transactionRaw(requestParameters: TransactionRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.txid === null || requestParameters.txid === undefined) {
            throw new runtime.RequiredError('txid','Required parameter requestParameters.txid was null or undefined when calling transaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.txid !== undefined) {
            queryParameters['txid'] = requestParameters.txid;
        }

        if (requestParameters.encoded !== undefined) {
            queryParameters['encoded'] = requestParameters.encoded;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/transaction`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns a transaction identified by its txid hash with just id
     */
    async transaction(requestParameters: TransactionRequest): Promise<any> {
        const response = await this.transactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Broadcast a hex-encoded, serialized transaction to the network.
     */
    async transactionInjectRaw(requestParameters: TransactionInjectRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.rawtx === null || requestParameters.rawtx === undefined) {
            throw new runtime.RequiredError('rawtx','Required parameter requestParameters.rawtx was null or undefined when calling transactionInject.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.rawtx !== undefined && requestParameters.rawtx !== null) {
            headerParameters['rawtx'] = String(requestParameters.rawtx);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/transaction/inject`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Broadcast a hex-encoded, serialized transaction to the network.
     */
    async transactionInject(requestParameters: TransactionInjectRequest): Promise<any> {
        const response = await this.transactionInjectRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     */
    async transactionRawRaw(requestParameters: TransactionRawRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.txid !== undefined) {
            queryParameters['txid'] = requestParameters.txid;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/transaction/raw`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     */
    async transactionRaw(requestParameters: TransactionRawRequest): Promise<any> {
        const response = await this.transactionRawRaw(requestParameters);
        return await response.value();
    }

    /**
     * Decode and verify an encoded transaction
     */
    async transactionVerifyRaw(): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/transaction/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Decode and verify an encoded transaction
     */
    async transactionVerify(): Promise<any> {
        const response = await this.transactionVerifyRaw();
        return await response.value();
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsGetRaw(requestParameters: TransactionsGetRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        if (requestParameters.confirmed !== undefined) {
            queryParameters['confirmed'] = requestParameters.confirmed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsGet(requestParameters: TransactionsGetRequest): Promise<any> {
        const response = await this.transactionsGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsPostRaw(requestParameters: TransactionsPostRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addrs !== undefined) {
            queryParameters['addrs'] = requestParameters.addrs;
        }

        if (requestParameters.confirmed !== undefined) {
            queryParameters['confirmed'] = requestParameters.confirmed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns transactions that match the filters.
     */
    async transactionsPost(requestParameters: TransactionsPostRequest): Promise<any> {
        const response = await this.transactionsPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns an unspent output by ID.
     */
    async uxoutRaw(requestParameters: UxoutRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.uxid !== undefined) {
            queryParameters['uxid'] = requestParameters.uxid;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/uxout`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns an unspent output by ID.
     */
    async uxout(requestParameters: UxoutRequest): Promise<any> {
        const response = await this.uxoutRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verifies a Skycoin address.
     */
    async verifyAddressRaw(requestParameters: VerifyAddressRequest): Promise<runtime.ApiResponse<InlineResponse2007>> {
        if (requestParameters.address === null || requestParameters.address === undefined) {
            throw new runtime.RequiredError('address','Required parameter requestParameters.address was null or undefined when calling verifyAddress.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/address/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2007FromJSON(jsonValue));
    }

    /**
     * Verifies a Skycoin address.
     */
    async verifyAddress(requestParameters: VerifyAddressRequest): Promise<InlineResponse2007> {
        const response = await this.verifyAddressRaw(requestParameters);
        return await response.value();
    }

    /**
     * versionHandler returns the application version info
     */
    async versionRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/version`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * versionHandler returns the application version info
     */
    async version(): Promise<void> {
        await this.versionRaw();
    }

    /**
     * Returns a wallet by id.
     */
    async walletRaw(requestParameters: WalletRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling wallet.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns a wallet by id.
     */
    async wallet(requestParameters: WalletRequest): Promise<any> {
        const response = await this.walletRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     */
    async walletBalanceRaw(requestParameters: WalletBalanceRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletBalance.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet/balance`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     */
    async walletBalance(requestParameters: WalletBalanceRequest): Promise<any> {
        const response = await this.walletBalanceRaw(requestParameters);
        return await response.value();
    }

    /**
     * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
     */
    async walletCreateRaw(requestParameters: WalletCreateRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.seed === null || requestParameters.seed === undefined) {
            throw new runtime.RequiredError('seed','Required parameter requestParameters.seed was null or undefined when calling walletCreate.');
        }

        if (requestParameters.label === null || requestParameters.label === undefined) {
            throw new runtime.RequiredError('label','Required parameter requestParameters.label was null or undefined when calling walletCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.seed !== undefined && requestParameters.seed !== null) {
            headerParameters['seed'] = String(requestParameters.seed);
        }

        if (requestParameters.label !== undefined && requestParameters.label !== null) {
            headerParameters['label'] = String(requestParameters.label);
        }

        if (requestParameters.scan !== undefined && requestParameters.scan !== null) {
            headerParameters['scan'] = String(requestParameters.scan);
        }

        if (requestParameters.encrypt !== undefined && requestParameters.encrypt !== null) {
            headerParameters['encrypt'] = String(requestParameters.encrypt);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Loads wallet from seed, will scan ahead N address and load addresses till the last one that have coins.
     */
    async walletCreate(requestParameters: WalletCreateRequest): Promise<any> {
        const response = await this.walletCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Decrypts wallet.
     */
    async walletDecryptRaw(requestParameters: WalletDecryptRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletDecrypt.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling walletDecrypt.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/decrypt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Decrypts wallet.
     */
    async walletDecrypt(requestParameters: WalletDecryptRequest): Promise<any> {
        const response = await this.walletDecryptRaw(requestParameters);
        return await response.value();
    }

    /**
     * Encrypt wallet.
     */
    async walletEncryptRaw(requestParameters: WalletEncryptRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletEncrypt.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling walletEncrypt.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/encrypt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Encrypt wallet.
     */
    async walletEncrypt(requestParameters: WalletEncryptRequest): Promise<any> {
        const response = await this.walletEncryptRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the wallet directory path
     */
    async walletFolderRaw(requestParameters: WalletFolderRequest): Promise<runtime.ApiResponse<InlineResponse2006>> {
        if (requestParameters.addr === null || requestParameters.addr === undefined) {
            throw new runtime.RequiredError('addr','Required parameter requestParameters.addr was null or undefined when calling walletFolder.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.addr !== undefined) {
            queryParameters['addr'] = requestParameters.addr;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallets/folderName`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2006FromJSON(jsonValue));
    }

    /**
     * Returns the wallet directory path
     */
    async walletFolder(requestParameters: WalletFolderRequest): Promise<InlineResponse2006> {
        const response = await this.walletFolderRaw(requestParameters);
        return await response.value();
    }

    /**
     * Generates new addresses
     */
    async walletNewAddressRaw(requestParameters: WalletNewAddressRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletNewAddress.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.num !== undefined) {
            queryParameters['num'] = requestParameters.num;
        }

        if (requestParameters.password !== undefined) {
            queryParameters['password'] = requestParameters.password;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/newAddress`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Generates new addresses
     */
    async walletNewAddress(requestParameters: WalletNewAddressRequest): Promise<any> {
        const response = await this.walletNewAddressRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns the wallet directory path
     */
    async walletNewSeedRaw(requestParameters: WalletNewSeedRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.entropy !== undefined) {
            queryParameters['entropy'] = requestParameters.entropy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet/newSeed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns the wallet directory path
     */
    async walletNewSeed(requestParameters: WalletNewSeedRequest): Promise<any> {
        const response = await this.walletNewSeedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     */
    async walletRecoverRaw(requestParameters: WalletRecoverRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletRecover.');
        }

        if (requestParameters.seed === null || requestParameters.seed === undefined) {
            throw new runtime.RequiredError('seed','Required parameter requestParameters.seed was null or undefined when calling walletRecover.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.seed !== undefined && requestParameters.seed !== null) {
            headerParameters['seed'] = String(requestParameters.seed);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/wallet/recover`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     */
    async walletRecover(requestParameters: WalletRecoverRequest): Promise<any> {
        const response = await this.walletRecoverRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     */
    async walletSeedRaw(requestParameters: WalletSeedRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletSeed.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling walletSeed.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.password !== undefined) {
            queryParameters['password'] = requestParameters.password;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/seed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     */
    async walletSeed(requestParameters: WalletSeedRequest): Promise<any> {
        const response = await this.walletSeedRaw(requestParameters);
        return await response.value();
    }

    /**
     * Verifies a wallet seed.
     */
    async walletSeedVerifyRaw(requestParameters: WalletSeedVerifyRequest): Promise<runtime.ApiResponse<any>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.seed !== undefined && requestParameters.seed !== null) {
            headerParameters['seed'] = String(requestParameters.seed);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v2/wallet/seed/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Verifies a wallet seed.
     */
    async walletSeedVerify(requestParameters: WalletSeedVerifyRequest): Promise<any> {
        const response = await this.walletSeedVerifyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
     */
    async walletSpentRaw(requestParameters: WalletSpentRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletSpent.');
        }

        if (requestParameters.dst === null || requestParameters.dst === undefined) {
            throw new runtime.RequiredError('dst','Required parameter requestParameters.dst was null or undefined when calling walletSpent.');
        }

        if (requestParameters.coins === null || requestParameters.coins === undefined) {
            throw new runtime.RequiredError('coins','Required parameter requestParameters.coins was null or undefined when calling walletSpent.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling walletSpent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.dst !== undefined && requestParameters.dst !== null) {
            headerParameters['dst'] = String(requestParameters.dst);
        }

        if (requestParameters.coins !== undefined && requestParameters.coins !== null) {
            headerParameters['coins'] = String(requestParameters.coins);
        }

        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            headerParameters['password'] = String(requestParameters.password);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/spend`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Creates and broadcasts a transaction sending money from one of our wallets to destination address.
     */
    async walletSpent(requestParameters: WalletSpentRequest): Promise<any> {
        const response = await this.walletSpentRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a signed transaction
     */
    async walletTransactionRaw(requestParameters: WalletTransactionRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling walletTransaction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/transaction`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InlineObjectToJSON(requestParameters.body),
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Creates a signed transaction
     */
    async walletTransaction(requestParameters: WalletTransactionRequest): Promise<any> {
        const response = await this.walletTransactionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
     */
    async walletTransactionsRaw(requestParameters: WalletTransactionsRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletTransactions.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallet/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * Returns returns all unconfirmed transactions for all addresses in a given wallet verbose
     */
    async walletTransactions(requestParameters: WalletTransactionsRequest): Promise<any> {
        const response = await this.walletTransactionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Unloads wallet from the wallet service.
     */
    async walletUnloadRaw(requestParameters: WalletUnloadRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletUnload.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/unload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unloads wallet from the wallet service.
     */
    async walletUnload(requestParameters: WalletUnloadRequest): Promise<void> {
        await this.walletUnloadRaw(requestParameters);
    }

    /**
     * Update the wallet.
     */
    async walletUpdateRaw(requestParameters: WalletUpdateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling walletUpdate.');
        }

        if (requestParameters.label === null || requestParameters.label === undefined) {
            throw new runtime.RequiredError('label','Required parameter requestParameters.label was null or undefined when calling walletUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            headerParameters['id'] = String(requestParameters.id);
        }

        if (requestParameters.label !== undefined && requestParameters.label !== null) {
            headerParameters['label'] = String(requestParameters.label);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-CSRF-TOKEN"] = this.configuration.apiKey("X-CSRF-TOKEN"); // csrfAuth authentication
        }

        const response = await this.request({
            path: `/api/v1/wallet/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the wallet.
     */
    async walletUpdate(requestParameters: WalletUpdateRequest): Promise<void> {
        await this.walletUpdateRaw(requestParameters);
    }

    /**
     * Returns all loaded wallets
     */
    async walletsRaw(): Promise<runtime.ApiResponse<Array<InlineResponse2005>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/wallets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InlineResponse2005FromJSON));
    }

    /**
     * Returns all loaded wallets
     */
    async wallets(): Promise<Array<InlineResponse2005>> {
        const response = await this.walletsRaw();
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum NetworkConnectionsStatesEnum {
    Pending = 'pending',
    Connected = 'connected',
    Introduced = 'introduced'
}
/**
    * @export
    * @enum {string}
    */
export enum NetworkConnectionsDirectionEnum {
    Connected = 'connected',
    Introduced = 'introduced'
}
/**
    * @export
    * @enum {string}
    */
export enum WalletNewSeedEntropyEnum {
    _128 = '128',
    _256 = '256'
}
