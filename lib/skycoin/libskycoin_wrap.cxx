/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



#ifndef SWIG_V8_VERSION
#define SWIG_V8_VERSION 0x031110
#endif


#include <node.h>
//Older version of node.h does not include this
#include <node_version.h>


#include <v8.h>

#include <errno.h>
#include <limits.h>
#include <stdlib.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* ---------------------------------------------------------------------------
 * These typedefs and defines are used to deal with v8 API changes
 *
 * ---------------------------------------------------------------------------*/

// First v8 version that uses "SetWeak" and not "MakeWeak"

#define SWIGV8_SETWEAK_VERSION 0x032224

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031803)
#define SWIGV8_STRING_NEW2(cstr, len) v8::String::New(cstr, len)
#else
#define SWIGV8_STRING_NEW2(cstr, len) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), cstr, v8::String::kNormalString, len)
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031903)
typedef v8::Handle<v8::Value> SwigV8ReturnValue;
typedef v8::Arguments SwigV8Arguments;
typedef v8::AccessorInfo SwigV8PropertyCallbackInfo;
#define SWIGV8_RETURN(val) return scope.Close(val)
#define SWIGV8_RETURN_INFO(val, info) return scope.Close(val)
#else
typedef void SwigV8ReturnValue;
typedef v8::FunctionCallbackInfo<v8::Value> SwigV8Arguments;
typedef v8::PropertyCallbackInfo<v8::Value> SwigV8PropertyCallbackInfo;
#define SWIGV8_RETURN(val) args.GetReturnValue().Set(val); return
#define SWIGV8_RETURN_INFO(val, info) info.GetReturnValue().Set(val); return
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032117)
#define SWIGV8_HANDLESCOPE() v8::HandleScope scope
#define SWIGV8_HANDLESCOPE_ESC() v8::HandleScope scope
#define SWIGV8_ESCAPE(val) return scope.Close(val)
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032224)
#define SWIGV8_HANDLESCOPE() v8::HandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_HANDLESCOPE_ESC() v8::HandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_ESCAPE(val) return scope.Close(val)
#else
#define SWIGV8_HANDLESCOPE() v8::HandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_HANDLESCOPE_ESC() v8::EscapableHandleScope scope(v8::Isolate::GetCurrent());
#define SWIGV8_ESCAPE(val) return scope.Escape(val)
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032224)
#define SWIGV8_ADJUST_MEMORY(size) v8::V8::AdjustAmountOfExternalAllocatedMemory(size)
#define SWIGV8_CURRENT_CONTEXT() v8::Context::GetCurrent()
#define SWIGV8_THROW_EXCEPTION(err) v8::ThrowException(err)
#define SWIGV8_STRING_NEW(str) v8::String::New(str)
#define SWIGV8_SYMBOL_NEW(sym) v8::String::NewSymbol(sym)
#else
#define SWIGV8_ADJUST_MEMORY(size) v8::Isolate::GetCurrent()->AdjustAmountOfExternalAllocatedMemory(size)
#define SWIGV8_CURRENT_CONTEXT() v8::Isolate::GetCurrent()->GetCurrentContext()
#define SWIGV8_THROW_EXCEPTION(err) v8::Isolate::GetCurrent()->ThrowException(err)
#define SWIGV8_STRING_NEW(str) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), str)
#define SWIGV8_SYMBOL_NEW(sym) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), sym)
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032318)
#define SWIGV8_ARRAY_NEW() v8::Array::New()
#define SWIGV8_BOOLEAN_NEW(bool) v8::Boolean::New(bool)
#define SWIGV8_EXTERNAL_NEW(val) v8::External::New(val)
#define SWIGV8_FUNCTEMPLATE_NEW(func) v8::FunctionTemplate::New(func)
#define SWIGV8_FUNCTEMPLATE_NEW_VOID() v8::FunctionTemplate::New()
#define SWIGV8_INT32_NEW(num) v8::Int32::New(num)
#define SWIGV8_INTEGER_NEW(num) v8::Integer::New(num)
#define SWIGV8_INTEGER_NEW_UNS(num) v8::Integer::NewFromUnsigned(num)
#define SWIGV8_NUMBER_NEW(num) v8::Number::New(num)
#define SWIGV8_OBJECT_NEW() v8::Object::New()
#define SWIGV8_UNDEFINED() v8::Undefined()
#define SWIGV8_NULL() v8::Null()
#else
#define SWIGV8_ARRAY_NEW() v8::Array::New(v8::Isolate::GetCurrent())
#define SWIGV8_BOOLEAN_NEW(bool) v8::Boolean::New(v8::Isolate::GetCurrent(), bool)
#define SWIGV8_EXTERNAL_NEW(val) v8::External::New(v8::Isolate::GetCurrent(), val)
#define SWIGV8_FUNCTEMPLATE_NEW(func) v8::FunctionTemplate::New(v8::Isolate::GetCurrent(), func)
#define SWIGV8_FUNCTEMPLATE_NEW_VOID() v8::FunctionTemplate::New(v8::Isolate::GetCurrent())
#define SWIGV8_INT32_NEW(num) v8::Int32::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_INTEGER_NEW(num) v8::Integer::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_INTEGER_NEW_UNS(num) v8::Integer::NewFromUnsigned(v8::Isolate::GetCurrent(), num)
#define SWIGV8_NUMBER_NEW(num) v8::Number::New(v8::Isolate::GetCurrent(), num)
#define SWIGV8_OBJECT_NEW() v8::Object::New(v8::Isolate::GetCurrent())
#define SWIGV8_UNDEFINED() v8::Undefined(v8::Isolate::GetCurrent())
#define SWIGV8_NULL() v8::Null(v8::Isolate::GetCurrent())
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
#define SWIGV8_SET_CLASS_TEMPL(class_templ, class) class_templ = v8::Persistent<v8::FunctionTemplate>::New(class);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
#define SWIGV8_SET_CLASS_TEMPL(class_templ, class) class_templ = v8::Persistent<v8::FunctionTemplate>::New(v8::Isolate::GetCurrent(), class);
#else
#define SWIGV8_SET_CLASS_TEMPL(class_templ, class) class_templ.Reset(v8::Isolate::GetCurrent(), class);
#endif

#ifdef NODE_VERSION
#if NODE_VERSION_AT_LEAST(10, 12, 0)
#define SWIG_NODE_AT_LEAST_1012
#endif
#endif

//Necessary to check Node.js version because V8 API changes are backported in Node.js
#if (defined(NODE_VERSION) && !defined(SWIG_NODE_AT_LEAST_1012)) || \
    (!defined(NODE_VERSION) && (V8_MAJOR_VERSION-0) < 7)
#define SWIGV8_TO_OBJECT(handle) (handle)->ToObject()
#define SWIGV8_TO_STRING(handle) (handle)->ToString()
#define SWIGV8_NUMBER_VALUE(handle) (handle)->NumberValue()
#define SWIGV8_INTEGER_VALUE(handle) (handle)->IntegerValue()
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue()
#define SWIGV8_WRITE_UTF8(handle, buffer, len) (handle)->WriteUtf8(buffer, len)
#define SWIGV8_UTF8_LENGTH(handle) (handle)->Utf8Length()
#else
#define SWIGV8_TO_OBJECT(handle) (handle)->ToObject(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked()
#define SWIGV8_TO_STRING(handle) (handle)->ToString(SWIGV8_CURRENT_CONTEXT()).ToLocalChecked()
#define SWIGV8_NUMBER_VALUE(handle) (handle)->NumberValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#define SWIGV8_INTEGER_VALUE(handle) (handle)->IntegerValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#define SWIGV8_BOOLEAN_VALUE(handle) (handle)->BooleanValue(SWIGV8_CURRENT_CONTEXT()).ToChecked()
#define SWIGV8_WRITE_UTF8(handle, buffer, len) (handle)->WriteUtf8(v8::Isolate::GetCurrent(), buffer, len)
#define SWIGV8_UTF8_LENGTH(handle) (handle)->Utf8Length(v8::Isolate::GetCurrent())
#endif

/* ---------------------------------------------------------------------------
 * Error handling
 *
 * ---------------------------------------------------------------------------*/

#define SWIG_Error(code, msg)     SWIGV8_ErrorHandler.error(code, msg)
#define SWIG_exception(code, msg) do { SWIGV8_ErrorHandler.error(code, msg); SWIG_fail; } while (0)
#define SWIG_fail                 goto fail
#define SWIGV8_OVERLOAD false

SWIGINTERN void SWIG_V8_Raise(const char *msg) {
  SWIGV8_THROW_EXCEPTION(v8::Exception::Error(SWIGV8_STRING_NEW(msg)));
}

/*
  Note: There are two contexts for handling errors.
  A static V8ErrorHandler is used in not overloaded methods.
  For overloaded methods the throwing type checking mechanism is used
  during dispatching. As V8 exceptions can not be reset properly
  the trick is to use a dynamic ErrorHandler with same local name as the global
  one.

  - See definition of SWIG_Error above.
  - See code templates 'JS_function_dispatcher', 'JS_functionwrapper_overload',
    and 'JS_function_dispatch_case' in javascriptcode.swg

*/
class V8ErrorHandler {
public:
  virtual ~V8ErrorHandler() {}
  virtual void error(int code, const char *msg) {
    SWIG_V8_Raise(msg);
  }
};
// this is used in usually
SWIGRUNTIME V8ErrorHandler SWIGV8_ErrorHandler;

// instances of this are used in overloaded functions
class OverloadErrorHandler: public V8ErrorHandler {
public:
  virtual void error(int code, const char *msg) {
    err = v8::Exception::Error(SWIGV8_STRING_NEW(msg));
    if(code != SWIG_TypeError) {
        SWIGV8_THROW_EXCEPTION(err);
    }
  }
  v8::Handle<v8::Value> err;
};

/* ---------------------------------------------------------------------------
 * Basic Proxy object
 *
 * ---------------------------------------------------------------------------*/

// Note: to trigger the v8 gc more often one can tell v8 about the memory consumption
// TODO: we could add a v8 specific parameter to control this value
#define SWIGV8_AVG_OBJ_SIZE 1000

class SWIGV8_Proxy {
public:
  SWIGV8_Proxy(): swigCMemOwn(false), swigCObject(0), info(0) {
    SWIGV8_ADJUST_MEMORY(SWIGV8_AVG_OBJ_SIZE);
  };

  ~SWIGV8_Proxy() {
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
    handle.ClearWeak();
    handle.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
    handle.ClearWeak(v8::Isolate::GetCurrent());
    handle.Dispose(v8::Isolate::GetCurrent());
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    handle.ClearWeak();
    handle.Dispose();
#else    
    handle.ClearWeak();
    handle.Reset();
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    handle.Clear();
#endif

    SWIGV8_ADJUST_MEMORY(-SWIGV8_AVG_OBJ_SIZE);
  }

  bool swigCMemOwn;
  void *swigCObject;
  swig_type_info *info;
  v8::Persistent<v8::Object> handle;
};

class SWIGV8_ClientData {
public:
  v8::Persistent<v8::FunctionTemplate> class_templ;

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  void (*dtor) (v8::Persistent< v8::Value> object, void *parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  void (*dtor) (v8::Isolate *isolate, v8::Persistent< v8::Value> object, void *parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
  void (*dtor) (v8::Isolate *isolate, v8::Persistent< v8::Object > *object, SWIGV8_Proxy *proxy);
#elif (V8_MAJOR_VERSION-0) < 5
  void (*dtor) (const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data);
#else
  void (*dtor) (const v8::WeakCallbackInfo<SWIGV8_Proxy> &data);
#endif
};

SWIGRUNTIME v8::Persistent<v8::FunctionTemplate> SWIGV8_SWIGTYPE_Proxy_class_templ;

SWIGRUNTIME int SWIG_V8_ConvertInstancePtr(v8::Handle<v8::Object> objRef, void **ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE();

  if(objRef->InternalFieldCount() < 1) return SWIG_ERROR;

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031511)
  v8::Handle<v8::Value> cdataRef = objRef->GetInternalField(0);
  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(v8::External::Unwrap(cdataRef));
#else
  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(objRef->GetAlignedPointerFromInternalField(0));
#endif

  if(cdata == NULL) {
    return SWIG_ERROR;
  }
  if(cdata->info != info) {
    swig_cast_info *tc = SWIG_TypeCheckStruct(cdata->info, info);
    if (!tc && cdata->info->name) {
      tc = SWIG_TypeCheck(cdata->info->name, info);
    }
    bool type_valid = tc != 0;
    if(!type_valid) {
      return SWIG_TypeError;
    }
  }
  *ptr = cdata->swigCObject;
  if(flags & SWIG_POINTER_DISOWN) {
    cdata->swigCMemOwn = false;
  }
  return SWIG_OK;
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
SWIGRUNTIME void SWIGV8_Proxy_DefaultDtor(v8::Persistent< v8::Value > object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
SWIGRUNTIME void SWIGV8_Proxy_DefaultDtor(v8::Isolate *, v8::Persistent< v8::Value > object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
SWIGRUNTIME void SWIGV8_Proxy_DefaultDtor(v8::Isolate *, v8::Persistent< v8::Object > *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
SWIGRUNTIME void SWIGV8_Proxy_DefaultDtor(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
#else
SWIGRUNTIME void SWIGV8_Proxy_DefaultDtor(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
  SWIGV8_Proxy *proxy = data.GetParameter();
#endif

  delete proxy;
}

SWIGRUNTIME int SWIG_V8_GetInstancePtr(v8::Handle<v8::Value> valRef, void **ptr) {
  if(!valRef->IsObject()) {
    return SWIG_TypeError;
  }
  v8::Handle<v8::Object> objRef = SWIGV8_TO_OBJECT(valRef);

  if(objRef->InternalFieldCount() < 1) return SWIG_ERROR;

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031511)
  v8::Handle<v8::Value> cdataRef = objRef->GetInternalField(0);
  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(v8::External::Unwrap(cdataRef));
#else
  SWIGV8_Proxy *cdata = static_cast<SWIGV8_Proxy *>(objRef->GetAlignedPointerFromInternalField(0));
#endif

  if(cdata == NULL) {
    return SWIG_ERROR;
  }

  *ptr = cdata->swigCObject;

  return SWIG_OK;
}

SWIGRUNTIME void SWIGV8_SetPrivateData(v8::Handle<v8::Object> obj, void *ptr, swig_type_info *info, int flags) {
  SWIGV8_Proxy *cdata = new SWIGV8_Proxy();
  cdata->swigCObject = ptr;
  cdata->swigCMemOwn = (flags & SWIG_POINTER_OWN) ? 1 : 0;
  cdata->info = info;

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031511)
  obj->SetPointerInInternalField(0, cdata);
#else
  obj->SetAlignedPointerInInternalField(0, cdata);
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  cdata->handle = v8::Persistent<v8::Object>::New(obj);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  cdata->handle = v8::Persistent<v8::Object>::New(v8::Isolate::GetCurrent(), obj);
#else
  cdata->handle.Reset(v8::Isolate::GetCurrent(), obj);
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  // clientdata must be set for owned data as we need to register the dtor
  if(cdata->swigCMemOwn && (SWIGV8_ClientData*)info->clientdata) {
    cdata->handle.MakeWeak(cdata, ((SWIGV8_ClientData*)info->clientdata)->dtor);
  } else {
    cdata->handle.MakeWeak(cdata, SWIGV8_Proxy_DefaultDtor);
  }
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031918)
  if(cdata->swigCMemOwn && (SWIGV8_ClientData*)info->clientdata) {
    cdata->handle.MakeWeak(v8::Isolate::GetCurrent(), cdata, ((SWIGV8_ClientData*)info->clientdata)->dtor);
  } else {
    cdata->handle.MakeWeak(v8::Isolate::GetCurrent(), cdata, SWIGV8_Proxy_DefaultDtor);
  }
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
  if(cdata->swigCMemOwn && (SWIGV8_ClientData*)info->clientdata) {
    cdata->handle.MakeWeak(cdata, ((SWIGV8_ClientData*)info->clientdata)->dtor);
  } else {
    cdata->handle.MakeWeak(cdata, SWIGV8_Proxy_DefaultDtor);
  }
#elif (V8_MAJOR_VERSION-0) < 5
  if(cdata->swigCMemOwn && (SWIGV8_ClientData*)info->clientdata) {
    cdata->handle.SetWeak(cdata, ((SWIGV8_ClientData*)info->clientdata)->dtor);
  } else {
    cdata->handle.SetWeak(cdata, SWIGV8_Proxy_DefaultDtor);
  }
#else
  if(cdata->swigCMemOwn && (SWIGV8_ClientData*)info->clientdata) {
    cdata->handle.SetWeak(cdata, ((SWIGV8_ClientData*)info->clientdata)->dtor, v8::WeakCallbackType::kParameter);
  } else {
    cdata->handle.SetWeak(cdata, SWIGV8_Proxy_DefaultDtor, v8::WeakCallbackType::kParameter);
  }
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  cdata->handle.MarkIndependent();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
  cdata->handle.MarkIndependent(v8::Isolate::GetCurrent());
#else
  cdata->handle.MarkIndependent();
#endif

}

SWIGRUNTIME int SWIG_V8_ConvertPtr(v8::Handle<v8::Value> valRef, void **ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE();
  
  /* special case: JavaScript null => C NULL pointer */
  if(valRef->IsNull()) {
    *ptr=0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }
  if(!valRef->IsObject()) {
    return SWIG_TypeError;
  }
  v8::Handle<v8::Object> objRef = SWIGV8_TO_OBJECT(valRef);
  return SWIG_V8_ConvertInstancePtr(objRef, ptr, info, flags);
}

SWIGRUNTIME v8::Handle<v8::Value> SWIG_V8_NewPointerObj(void *ptr, swig_type_info *info, int flags) {
  SWIGV8_HANDLESCOPE_ESC();
  
  v8::Handle<v8::FunctionTemplate> class_templ;

  if (ptr == NULL) {
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031903)
    SWIGV8_ESCAPE(SWIGV8_NULL());
#else    
    v8::Local<v8::Primitive> result = SWIGV8_NULL();
    SWIGV8_ESCAPE(result);
#endif
  }

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031903)
  if(info->clientdata != 0) {
    class_templ = ((SWIGV8_ClientData*) info->clientdata)->class_templ;
  } else {
    class_templ = SWIGV8_SWIGTYPE_Proxy_class_templ;
  }
#else
  v8::Isolate *isolate = v8::Isolate::GetCurrent();

  if(info->clientdata != 0) {
    class_templ = v8::Local<v8::FunctionTemplate>::New(isolate, ((SWIGV8_ClientData*) info->clientdata)->class_templ);
  } else {
    class_templ = v8::Local<v8::FunctionTemplate>::New(isolate, SWIGV8_SWIGTYPE_Proxy_class_templ);
  }
#endif

//  v8::Handle<v8::Object> result = class_templ->InstanceTemplate()->NewInstance();
  v8::Local<v8::Object> result = class_templ->InstanceTemplate()->NewInstance();
  SWIGV8_SetPrivateData(result, ptr, info, flags);

  SWIGV8_ESCAPE(result);
}

#define SWIG_ConvertPtr(obj, ptr, info, flags)    SWIG_V8_ConvertPtr(obj, ptr, info, flags)
#define SWIG_NewPointerObj(ptr, info, flags)      SWIG_V8_NewPointerObj(ptr, info, flags)

#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_V8_ConvertInstancePtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_V8_NewPointerObj(thisvalue, type, flags)

#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_V8_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_V8_NewPointerObj(ptr, type, 0)

#define SWIG_GetInstancePtr(obj, ptr)    SWIG_V8_GetInstancePtr(obj, ptr)

SWIGRUNTIME SwigV8ReturnValue _SWIGV8_wrap_equals(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  void *arg1 = (void *) 0 ;
  void *arg2 = (void *) 0 ;
  bool result;
  int res1;
  int res2;

  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for equals.");

  res1 = SWIG_GetInstancePtr(args.Holder(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ERROR, "Could not get pointer from 'this' object for equals.");
  }
  res2 = SWIG_GetInstancePtr(args[0], &arg2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equals" "', argument " "1"" of type '" "void *""'");
  }

  result = (bool)(arg1 == arg2);
  jsresult =  SWIGV8_BOOLEAN_NEW(result);

  SWIGV8_RETURN(jsresult);
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}

SWIGRUNTIME SwigV8ReturnValue _wrap_getCPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  void *arg1 = (void *) 0 ;
  long result;
  int res1;

  res1 = SWIG_GetInstancePtr(args.Holder(), &arg1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "getCPtr" "', argument " "1"" of type '" "void *""'");
  }

  result = (long)arg1;
  jsresult = SWIGV8_NUMBER_NEW(result);

  SWIGV8_RETURN(jsresult);
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}

/* ---------------------------------------------------------------------------
 * PackedData object
 *
 * ---------------------------------------------------------------------------*/

class SwigV8PackedData {
public:
  SwigV8PackedData(void *data, size_t size, swig_type_info *type): data(data), size(size), type(type) {};

  ~SwigV8PackedData() {
  };

  void *data;
  size_t size;
  swig_type_info *type;

  v8::Persistent<v8::Object> handle;
};

SWIGRUNTIMEINLINE
int SwigV8Packed_Check(v8::Handle<v8::Value> valRef) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> objRef = SWIGV8_TO_OBJECT(valRef);
  if(objRef->InternalFieldCount() < 1) return false;
#if (V8_MAJOR_VERSION-0) < 5
  v8::Handle<v8::Value> flag = objRef->GetHiddenValue(SWIGV8_STRING_NEW("__swig__packed_data__"));
#else
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("__swig__packed_data__"));
  v8::Local<v8::Value> flag;
  if (!objRef->GetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey).ToLocal(&flag))
    return false;
#endif
  return (flag->IsBoolean() && SWIGV8_BOOLEAN_VALUE(flag));
}

SWIGRUNTIME
swig_type_info *SwigV8Packed_UnpackData(v8::Handle<v8::Value> valRef, void *ptr, size_t size) {
  if (SwigV8Packed_Check(valRef)) {
    SWIGV8_HANDLESCOPE();
    
    SwigV8PackedData *sobj;

    v8::Handle<v8::Object> objRef = SWIGV8_TO_OBJECT(valRef);

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031511)
    v8::Handle<v8::Value> cdataRef = objRef->GetInternalField(0);
    sobj = static_cast<SwigV8PackedData*>(v8::External::Unwrap(cdataRef));
#else
    sobj = static_cast<SwigV8PackedData*>(objRef->GetAlignedPointerFromInternalField(0));
#endif
    if (sobj == NULL || sobj->size != size) return 0;
    memcpy(ptr, sobj->data, size);
    return sobj->type;
  } else {
    return 0;
  }
}

SWIGRUNTIME
int SWIGV8_ConvertPacked(v8::Handle<v8::Value> valRef, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigV8Packed_UnpackData(valRef, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
SWIGRUNTIME void _wrap_SwigV8PackedData_delete(v8::Persistent< v8::Value > object, void *parameter) {
  SwigV8PackedData *cdata = static_cast<SwigV8PackedData *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
SWIGRUNTIME void _wrap_SwigV8PackedData_delete(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
  SwigV8PackedData *cdata = static_cast<SwigV8PackedData *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
SWIGRUNTIME void _wrap_SwigV8PackedData_delete(v8::Isolate *isolate, v8::Persistent<v8::Object> *object, SwigV8PackedData *cdata) {
#elif (V8_MAJOR_VERSION-0) < 5
SWIGRUNTIME void _wrap_SwigV8PackedData_delete(const v8::WeakCallbackData<v8::Object, SwigV8PackedData> &data) {
  v8::Local<v8::Object> object = data.GetValue();
  SwigV8PackedData *cdata = data.GetParameter();
#else
SWIGRUNTIME void _wrap_SwigV8PackedData_delete(const v8::WeakCallbackInfo<SwigV8PackedData> &data) {
  SwigV8PackedData *cdata = data.GetParameter();
#endif

  delete cdata;

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  object.Clear();
  object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  object.Clear();
  object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
  object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
  object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
  object.Clear();
#endif
}

SWIGRUNTIME
v8::Handle<v8::Value> SWIGV8_NewPackedObj(void *data, size_t size, swig_type_info *type) {
  SWIGV8_HANDLESCOPE_ESC();

  SwigV8PackedData *cdata = new SwigV8PackedData(data, size, type);
//  v8::Handle<v8::Object> obj = SWIGV8_OBJECT_NEW();
  v8::Local<v8::Object> obj = SWIGV8_OBJECT_NEW();

#if (V8_MAJOR_VERSION-0) < 5
  obj->SetHiddenValue(SWIGV8_STRING_NEW("__swig__packed_data__"), SWIGV8_BOOLEAN_NEW(true));
#else
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("__swig__packed_data__"));
  obj->SetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey, SWIGV8_BOOLEAN_NEW(true));
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031511)
  obj->SetPointerInInternalField(0, cdata);
#else
  obj->SetAlignedPointerInInternalField(0, cdata);
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  cdata->handle = v8::Persistent<v8::Object>::New(obj);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  cdata->handle = v8::Persistent<v8::Object>::New(v8::Isolate::GetCurrent(), obj);
#else
  cdata->handle.Reset(v8::Isolate::GetCurrent(), obj);
#endif


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  cdata->handle.MakeWeak(cdata, _wrap_SwigV8PackedData_delete);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031918)
  cdata->handle.MakeWeak(v8::Isolate::GetCurrent(), cdata, _wrap_SwigV8PackedData_delete);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
  cdata->handle.MakeWeak(cdata, _wrap_SwigV8PackedData_delete);
#elif (V8_MAJOR_VERSION-0) < 5
  cdata->handle.SetWeak(cdata, _wrap_SwigV8PackedData_delete);
//  v8::V8::SetWeak(&cdata->handle, cdata, _wrap_SwigV8PackedData_delete);
#else
  cdata->handle.SetWeak(cdata, _wrap_SwigV8PackedData_delete, v8::WeakCallbackType::kParameter);
#endif

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
  cdata->handle.MarkIndependent();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
  cdata->handle.MarkIndependent(v8::Isolate::GetCurrent());
#else
  cdata->handle.MarkIndependent();
#endif

  SWIGV8_ESCAPE(obj);
}

#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIGV8_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIGV8_NewPackedObj(ptr, sz, type)


/* ---------------------------------------------------------------------------
 * Support for IN/OUTPUT typemaps (see Lib/typemaps/inoutlist.swg)
 *
 * ---------------------------------------------------------------------------*/

SWIGRUNTIME

#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031903)
v8::Handle<v8::Value> SWIGV8_AppendOutput(v8::Handle<v8::Value> result, v8::Handle<v8::Value> obj) {
#else
v8::Handle<v8::Value> SWIGV8_AppendOutput(v8::Local<v8::Value> result, v8::Handle<v8::Value> obj) {
#endif
  SWIGV8_HANDLESCOPE_ESC();
  
  if (result->IsUndefined()) {
    result = SWIGV8_ARRAY_NEW();
  }
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031903)
  v8::Handle<v8::Array> arr = v8::Handle<v8::Array>::Cast(result);
#else  
  v8::Local<v8::Array> arr = v8::Local<v8::Array>::Cast(result);
#endif
  arr->Set(arr->Length(), obj);

  SWIGV8_ESCAPE(arr);
}



// Note: since 3.19 there are new CallBack types, since 03.21.9 the old ones have been removed
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031903)
typedef v8::InvocationCallback  SwigV8FunctionCallback;
typedef v8::AccessorGetter      SwigV8AccessorGetterCallback;
typedef v8::AccessorSetter      SwigV8AccessorSetterCallback;
typedef v8::AccessorInfo        SwigV8PropertyCallbackInfoVoid;
#elif (V8_MAJOR_VERSION-0) < 5
typedef v8::FunctionCallback            SwigV8FunctionCallback;
typedef v8::AccessorGetterCallback      SwigV8AccessorGetterCallback;
typedef v8::AccessorSetterCallback      SwigV8AccessorSetterCallback;
typedef v8::PropertyCallbackInfo<void>  SwigV8PropertyCallbackInfoVoid;
#else
typedef v8::FunctionCallback            SwigV8FunctionCallback;
typedef v8::AccessorNameGetterCallback  SwigV8AccessorGetterCallback;
typedef v8::AccessorNameSetterCallback  SwigV8AccessorSetterCallback;
typedef v8::PropertyCallbackInfo<void>  SwigV8PropertyCallbackInfoVoid;
#endif

/**
 * Creates a class template for a class with specified initialization function.
 */
SWIGRUNTIME v8::Handle<v8::FunctionTemplate> SWIGV8_CreateClassTemplate(const char* symbol) {
    SWIGV8_HANDLESCOPE_ESC();
    
    v8::Local<v8::FunctionTemplate> class_templ = SWIGV8_FUNCTEMPLATE_NEW_VOID();
    class_templ->SetClassName(SWIGV8_SYMBOL_NEW(symbol));

    v8::Handle<v8::ObjectTemplate> inst_templ = class_templ->InstanceTemplate();
    inst_templ->SetInternalFieldCount(1);

    v8::Handle<v8::ObjectTemplate> equals_templ = class_templ->PrototypeTemplate();
    equals_templ->Set(SWIGV8_SYMBOL_NEW("equals"), SWIGV8_FUNCTEMPLATE_NEW(_SWIGV8_wrap_equals));

    v8::Handle<v8::ObjectTemplate> cptr_templ = class_templ->PrototypeTemplate();
    cptr_templ->Set(SWIGV8_SYMBOL_NEW("getCPtr"), SWIGV8_FUNCTEMPLATE_NEW(_wrap_getCPtr));

    SWIGV8_ESCAPE(class_templ);
}

/**
 * Registers a class method with given name for a given class template.
 */
SWIGRUNTIME void SWIGV8_AddMemberFunction(v8::Handle<v8::FunctionTemplate> class_templ, const char* symbol,
  SwigV8FunctionCallback _func) {
    v8::Handle<v8::ObjectTemplate> proto_templ = class_templ->PrototypeTemplate();
    proto_templ->Set(SWIGV8_SYMBOL_NEW(symbol), SWIGV8_FUNCTEMPLATE_NEW(_func));
}

/**
 * Registers a class property with given name for a given class template.
 */
SWIGRUNTIME void SWIGV8_AddMemberVariable(v8::Handle<v8::FunctionTemplate> class_templ, const char* symbol,
  SwigV8AccessorGetterCallback getter, SwigV8AccessorSetterCallback setter) {
  v8::Handle<v8::ObjectTemplate> proto_templ = class_templ->InstanceTemplate();
  proto_templ->SetAccessor(SWIGV8_SYMBOL_NEW(symbol), getter, setter);
}

/**
 * Registers a class method with given name for a given object.
 */
SWIGRUNTIME void SWIGV8_AddStaticFunction(v8::Handle<v8::Object> obj, const char* symbol,
  const SwigV8FunctionCallback& _func) {
  obj->Set(SWIGV8_SYMBOL_NEW(symbol), SWIGV8_FUNCTEMPLATE_NEW(_func)->GetFunction());
}

/**
 * Registers a class method with given name for a given object.
 */
SWIGRUNTIME void SWIGV8_AddStaticVariable(v8::Handle<v8::Object> obj, const char* symbol,
  SwigV8AccessorGetterCallback getter, SwigV8AccessorSetterCallback setter) {
#if (V8_MAJOR_VERSION-0) < 5
  obj->SetAccessor(SWIGV8_SYMBOL_NEW(symbol), getter, setter);
#else
  obj->SetAccessor(SWIGV8_CURRENT_CONTEXT(), SWIGV8_SYMBOL_NEW(symbol), getter, setter);
#endif
}

#if (V8_MAJOR_VERSION-0) < 5
SWIGRUNTIME void JS_veto_set_variable(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid& info)
#else
SWIGRUNTIME void JS_veto_set_variable(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid& info)
#endif
{
    char buffer[256];
    char msg[512];
    int res;

#if (V8_MAJOR_VERSION-0) < 5
    property->WriteUtf8(buffer, 256);
    res = sprintf(msg, "Tried to write read-only variable: %s.", buffer);
#else
    v8::Local<v8::String> sproperty;
    if (property->ToString(SWIGV8_CURRENT_CONTEXT()).ToLocal(&sproperty)) {
      SWIGV8_WRITE_UTF8(sproperty, buffer, 256);
      res = sprintf(msg, "Tried to write read-only variable: %s.", buffer);
    }
    else {
      res = -1;
    }
#endif

    if(res<0) {
      SWIG_exception(SWIG_ERROR, "Tried to write read-only variable.");
    } else {
      SWIG_exception(SWIG_ERROR, msg);
    }
fail: ;
}



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_FeeCalculator swig_types[0]
#define SWIGTYPE_p_Fee_Calculator swig_types[1]
#define SWIGTYPE_p_GoComplex128_ swig_types[2]
#define SWIGTYPE_p_GoComplex64_ swig_types[3]
#define SWIGTYPE_p_GoInterface swig_types[4]
#define SWIGTYPE_p_GoInterface_ swig_types[5]
#define SWIGTYPE_p_GoSlice swig_types[6]
#define SWIGTYPE_p_GoSlice_ swig_types[7]
#define SWIGTYPE_p_GoString_ swig_types[8]
#define SWIGTYPE_p_Number swig_types[9]
#define SWIGTYPE_p_Signature swig_types[10]
#define SWIGTYPE_p_Wallet swig_types[11]
#define SWIGTYPE_p__GoString_ swig_types[12]
#define SWIGTYPE_p___SIZE_TYPE__ swig_types[13]
#define SWIGTYPE_p_a_16__unsigned_char swig_types[14]
#define SWIGTYPE_p_a_20__unsigned_char swig_types[15]
#define SWIGTYPE_p_a_32__unsigned_char swig_types[16]
#define SWIGTYPE_p_a_33__unsigned_char swig_types[17]
#define SWIGTYPE_p_a_4__unsigned_char swig_types[18]
#define SWIGTYPE_p_a_65__unsigned_char swig_types[19]
#define SWIGTYPE_p_a_sizeof_void_____64_8_1__1__char swig_types[20]
#define SWIGTYPE_p_api__NetworkConnectionsFilter swig_types[21]
#define SWIGTYPE_p_api__RichlistParams swig_types[22]
#define SWIGTYPE_p_api__TransactionInput swig_types[23]
#define SWIGTYPE_p_char swig_types[24]
#define SWIGTYPE_p_cipher_Addresses swig_types[25]
#define SWIGTYPE_p_cipher_Checksum swig_types[26]
#define SWIGTYPE_p_cipher_PubKey swig_types[27]
#define SWIGTYPE_p_cipher_PubKeys swig_types[28]
#define SWIGTYPE_p_cipher_Ripemd160 swig_types[29]
#define SWIGTYPE_p_cipher_SHA256 swig_types[30]
#define SWIGTYPE_p_cipher_SHA256s swig_types[31]
#define SWIGTYPE_p_cipher_SecKey swig_types[32]
#define SWIGTYPE_p_cipher_SecKeys swig_types[33]
#define SWIGTYPE_p_cipher_Sig swig_types[34]
#define SWIGTYPE_p_cipher__Address swig_types[35]
#define SWIGTYPE_p_cipher__BitcoinAddress swig_types[36]
#define SWIGTYPE_p_cli__SendAmount swig_types[37]
#define SWIGTYPE_p_coin_UxOutArray swig_types[38]
#define SWIGTYPE_p_coin__Block swig_types[39]
#define SWIGTYPE_p_coin__BlockBody swig_types[40]
#define SWIGTYPE_p_coin__BlockHeader swig_types[41]
#define SWIGTYPE_p_coin__SignedBlock swig_types[42]
#define SWIGTYPE_p_coin__Transaction swig_types[43]
#define SWIGTYPE_p_coin__TransactionOutput swig_types[44]
#define SWIGTYPE_p_coin__UxBody swig_types[45]
#define SWIGTYPE_p_coin__UxHead swig_types[46]
#define SWIGTYPE_p_coin__UxOut swig_types[47]
#define SWIGTYPE_p_double swig_types[48]
#define SWIGTYPE_p_encrypt__ScryptChacha20poly1305 swig_types[49]
#define SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int swig_types[50]
#define SWIGTYPE_p_float swig_types[51]
#define SWIGTYPE_p_httphelper__Address swig_types[52]
#define SWIGTYPE_p_httphelper__SHA256 swig_types[53]
#define SWIGTYPE_p_int swig_types[54]
#define SWIGTYPE_p_long_long swig_types[55]
#define SWIGTYPE_p_p_GoSlice_ swig_types[56]
#define SWIGTYPE_p_p_coin__Block swig_types[57]
#define SWIGTYPE_p_p_coin__BlockHeader swig_types[58]
#define SWIGTYPE_p_p_coin__Transaction swig_types[59]
#define SWIGTYPE_p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int swig_types[60]
#define SWIGTYPE_p_secp256k1go__Field swig_types[61]
#define SWIGTYPE_p_secp256k1go__XY swig_types[62]
#define SWIGTYPE_p_secp256k1go__XYZ swig_types[63]
#define SWIGTYPE_p_short swig_types[64]
#define SWIGTYPE_p_signed_char swig_types[65]
#define SWIGTYPE_p_transaction__UxBalance swig_types[66]
#define SWIGTYPE_p_uintptr_t swig_types[67]
#define SWIGTYPE_p_unsigned_char swig_types[68]
#define SWIGTYPE_p_unsigned_int swig_types[69]
#define SWIGTYPE_p_unsigned_long_long swig_types[70]
#define SWIGTYPE_p_unsigned_short swig_types[71]
#define SWIGTYPE_p_void swig_types[72]
#define SWIGTYPE_p_wallet__Balance swig_types[73]
#define SWIGTYPE_p_wallet__BalancePair swig_types[74]
#define SWIGTYPE_p_wallet__Entry swig_types[75]
#define SWIGTYPE_p_wallet__Note swig_types[76]
#define SWIGTYPE_p_wallet__ReadableNote swig_types[77]
static swig_type_info *swig_types[79];
static swig_module_info swig_module = {swig_types, 78, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */



#define SWIGVERSION 0x040000 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


#include <assert.h>


	#define SWIG_FILE_WITH_INIT
	#include "libskycoin.h"
	#include "swig.h"
	#include "skytypes.h"


	int equalSlices(GoSlice* slice1, GoSlice* slice2, int elem_size){
	  if(slice1->len != slice2->len)
		return 0;
	  return memcmp(slice1->data, slice2->data, slice1->len * elem_size) == 0;
	}
	int equalTransactions(coin__Transaction* t1, coin__Transaction* t2){
		if( t1->Length != t2->Length || t1->Type != t2->Type ){
			return 0;
		}
		if( memcmp(&t1->InnerHash, &t2->InnerHash, sizeof(cipher__SHA256)) != 0 )
			return 0;
		if(!equalSlices((GoSlice*)&t1->Sigs, (GoSlice*)&t2->Sigs, sizeof(cipher__Sig)))
			return 0;
		if(!equalSlices((GoSlice*)&t1->In, (GoSlice*)&t2->In, sizeof(cipher__SHA256)))
			return 0;
		if(!equalSlices((GoSlice*)&t1->Out, (GoSlice*)&t2->Out, sizeof(coin__TransactionOutput)))
			return 0;
		return 1;
	}
	int equalTransactionsArrays(coin__Transactions* pTxs1, coin__Transactions* pTxs2){
		if( pTxs1->len != pTxs2->len )
			return 0;
		coin__Transaction* pTx1 = pTxs1->data;
		coin__Transaction* pTx2 = pTxs2->data;
		int i;
		for(i = 0; i < pTxs1->len; i++){
			if(!equalTransactions(pTx1, pTx2))
				return 0;
			pTx1++;
			pTx2++;
		}
		return 1;
	}
	int equalBlockHeaders(coin__BlockHeader* bh1, coin__BlockHeader* bh2){
		if( bh1->Version != bh2->Version || bh1->Time != bh2->Time || 
			bh1->BkSeq != bh2->BkSeq || bh1->Fee != bh2->Fee)
			return 0;
		if( memcmp( &bh1->PrevHash, bh2->PrevHash, sizeof(bh2->PrevHash) ) != 0 )
			return 0;
		if( memcmp( &bh1->BodyHash, bh2->PrevHash, sizeof(bh2->BodyHash) ) != 0 )
			return 0;
		if( memcmp( &bh1->UxHash, bh2->PrevHash, sizeof(bh2->UxHash) ) != 0 )
			return 0;
		return 1;
	}


SWIGINTERN
int SWIG_AsVal_int (v8::Handle<v8::Value> valRef, int* val)
{
  if (!valRef->IsNumber()) {
    return SWIG_TypeError;
  }
  if(val) *val = SWIGV8_INTEGER_VALUE(valRef);

  return SWIG_OK;
}


SWIGINTERNINLINE
v8::Handle<v8::Value> SWIG_From_int  (int value)
{
  return SWIGV8_INT32_NEW(value);
}


static GoSlice *new_GoSlicePtr() { 
  return new GoSlice(); 
}

static GoSlice *copy_GoSlicePtr(GoSlice value) { 
  return new GoSlice(value); 
}

static void delete_GoSlicePtr(GoSlice *obj) { 
  if (obj) delete obj; 
}

static void GoSlicePtr_assign(GoSlice *obj, GoSlice value) {
  *obj = value;
}

static GoSlice GoSlicePtr_value(GoSlice *obj) {
  return *obj;
}


static GoUint8_ *new_GoUint8Ptr() { 
  return new GoUint8_(); 
}

static GoUint8_ *copy_GoUint8Ptr(GoUint8_ value) { 
  return new GoUint8_(value); 
}

static void delete_GoUint8Ptr(GoUint8_ *obj) { 
  if (obj) delete obj; 
}

static void GoUint8Ptr_assign(GoUint8_ *obj, GoUint8_ value) {
  *obj = value;
}

static GoUint8_ GoUint8Ptr_value(GoUint8_ *obj) {
  return *obj;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN
int SWIG_AsVal_double (v8::Handle<v8::Value> obj, double *val)
{
  if(!obj->IsNumber()) {
    return SWIG_TypeError;
  }
  if(val) *val = SWIGV8_NUMBER_VALUE(obj);

  return SWIG_OK;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN
int SWIG_AsVal_unsigned_SS_long (v8::Handle<v8::Value> obj, unsigned long *val)
{
  if(!obj->IsNumber()) {
    return SWIG_TypeError;
  }

  long longVal = (long) SWIGV8_NUMBER_VALUE(obj);

  if(longVal < 0) {
      return SWIG_OverflowError;
  }

  if(val) *val = longVal;

  return SWIG_OK;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_char (v8::Handle<v8::Value> obj, unsigned char *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned char >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE
v8::Handle<v8::Value> SWIG_From_long  (long value)
{
  return SWIGV8_NUMBER_NEW(value);
}


SWIGINTERNINLINE
v8::Handle<v8::Value> SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    SWIGV8_INTEGER_NEW_UNS(value) : SWIGV8_INTEGER_NEW(static_cast< long >(value));
}


SWIGINTERNINLINE v8::Handle<v8::Value>
SWIG_From_unsigned_SS_char  (unsigned char value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


static _GoString_ *new_GoStringPtr() { 
  return new _GoString_(); 
}

static _GoString_ *copy_GoStringPtr(_GoString_ value) { 
  return new _GoString_(value); 
}

static void delete_GoStringPtr(_GoString_ *obj) { 
  if (obj) delete obj; 
}

static void GoStringPtr_assign(_GoString_ *obj, _GoString_ value) {
  *obj = value;
}

static _GoString_ GoStringPtr_value(_GoString_ *obj) {
  return *obj;
}


static int *new_IntPtr() { 
  return new int(); 
}

static int *copy_IntPtr(int value) { 
  return new int(value); 
}

static void delete_IntPtr(int *obj) { 
  if (obj) delete obj; 
}

static void IntPtr_assign(int *obj, int value) {
  *obj = value;
}

static int IntPtr_value(int *obj) {
  return *obj;
}


static coin__Transaction *new_coin__TransactionPtr() { 
  return new coin__Transaction(); 
}

static coin__Transaction *copy_coin__TransactionPtr(coin__Transaction value) { 
  return new coin__Transaction(value); 
}

static void delete_coin__TransactionPtr(coin__Transaction *obj) { 
  if (obj) delete obj; 
}

static void coin__TransactionPtr_assign(coin__Transaction *obj, coin__Transaction value) {
  *obj = value;
}

static coin__Transaction coin__TransactionPtr_value(coin__Transaction *obj) {
  return *obj;
}


static AddressUxOuts_Handle *new_AddressUxOuts__HandlePtr() { 
  return new AddressUxOuts_Handle(); 
}

static AddressUxOuts_Handle *copy_AddressUxOuts__HandlePtr(AddressUxOuts_Handle value) { 
  return new AddressUxOuts_Handle(value); 
}

static void delete_AddressUxOuts__HandlePtr(AddressUxOuts_Handle *obj) { 
  if (obj) delete obj; 
}

static void AddressUxOuts__HandlePtr_assign(AddressUxOuts_Handle *obj, AddressUxOuts_Handle value) {
  *obj = value;
}

static AddressUxOuts_Handle AddressUxOuts__HandlePtr_value(AddressUxOuts_Handle *obj) {
  return *obj;
}


SWIGINTERN
int SWIG_AsVal_long (v8::Handle<v8::Value> obj, long* val)
{
  if (!obj->IsNumber()) {
    return SWIG_TypeError;
  }
  if(val) *val = (long) SWIGV8_INTEGER_VALUE(obj);

  return SWIG_OK;
}


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN
int SWIG_AsVal_long_SS_long (v8::Handle<v8::Value> obj, long long* val)
{
  if (!obj->IsNumber()) {
    return SWIG_TypeError;
  }
  if(val) *val = (long long) SWIGV8_INTEGER_VALUE(obj);

  return SWIG_OK;
}
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE
v8::Handle<v8::Value> SWIG_From_long_SS_long  (long long value)
{
  return SWIGV8_NUMBER_NEW(value);
}
#endif


static unsigned long long *new_GoUint64Ptr() { 
  return new unsigned long long(); 
}

static unsigned long long *copy_GoUint64Ptr(unsigned long long value) { 
  return new unsigned long long(value); 
}

static void delete_GoUint64Ptr(unsigned long long *obj) { 
  if (obj) delete obj; 
}

static void GoUint64Ptr_assign(unsigned long long *obj, unsigned long long value) {
  *obj = value;
}

static unsigned long long GoUint64Ptr_value(unsigned long long *obj) {
  return *obj;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN
int SWIG_AsVal_unsigned_SS_long_SS_long (v8::Handle<v8::Value> obj, unsigned long long *val)
{
  if(!obj->IsNumber()) {
    return SWIG_TypeError;
  }

  long long longVal = (long long) SWIGV8_NUMBER_VALUE(obj);

  if(longVal < 0) {
      return SWIG_OverflowError;
  }

  if(val) *val = longVal;

  return SWIG_OK;
}
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE
v8::Handle<v8::Value> SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    SWIGV8_INTEGER_NEW_UNS(value) : SWIGV8_INTEGER_NEW(static_cast< long >(value));
}
#endif


static long long *new_GointPtr() { 
  return new long long(); 
}

static long long *copy_GointPtr(long long value) { 
  return new long long(value); 
}

static void delete_GointPtr(long long *obj) { 
  if (obj) delete obj; 
}

static void GointPtr_assign(long long *obj, long long value) {
  *obj = value;
}

static long long GointPtr_value(long long *obj) {
  return *obj;
}


static unsigned short *new_GoUint16Ptr() { 
  return new unsigned short(); 
}

static unsigned short *copy_GoUint16Ptr(unsigned short value) { 
  return new unsigned short(value); 
}

static void delete_GoUint16Ptr(unsigned short *obj) { 
  if (obj) delete obj; 
}

static void GoUint16Ptr_assign(unsigned short *obj, unsigned short value) {
  *obj = value;
}

static unsigned short GoUint16Ptr_value(unsigned short *obj) {
  return *obj;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (v8::Handle<v8::Value> obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE v8::Handle<v8::Value>
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


static unsigned int *new_GoUint32Ptr() { 
  return new unsigned int(); 
}

static unsigned int *copy_GoUint32Ptr(unsigned int value) { 
  return new unsigned int(value); 
}

static void delete_GoUint32Ptr(unsigned int *obj) { 
  if (obj) delete obj; 
}

static void GoUint32Ptr_assign(unsigned int *obj, unsigned int value) {
  *obj = value;
}

static unsigned int GoUint32Ptr_value(unsigned int *obj) {
  return *obj;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (v8::Handle<v8::Value> obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE v8::Handle<v8::Value>
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


static cipher__Address *new_cipher__AddressPtr() { 
  return new cipher__Address(); 
}

static cipher__Address *copy_cipher__AddressPtr(cipher__Address value) { 
  return new cipher__Address(value); 
}

static void delete_cipher__AddressPtr(cipher__Address *obj) { 
  if (obj) delete obj; 
}

static void cipher__AddressPtr_assign(cipher__Address *obj, cipher__Address value) {
  *obj = value;
}

static cipher__Address cipher__AddressPtr_value(cipher__Address *obj) {
  return *obj;
}


static Transactions__Handle *new_Transactions__HandlePtr() { 
  return new Transactions__Handle(); 
}

static Transactions__Handle *copy_Transactions__HandlePtr(Transactions__Handle value) { 
  return new Transactions__Handle(value); 
}

static void delete_Transactions__HandlePtr(Transactions__Handle *obj) { 
  if (obj) delete obj; 
}

static void Transactions__HandlePtr_assign(Transactions__Handle *obj, Transactions__Handle value) {
  *obj = value;
}

static Transactions__Handle Transactions__HandlePtr_value(Transactions__Handle *obj) {
  return *obj;
}


static Transaction__Handle *new_Transaction__HandlePtr() { 
  return new Transaction__Handle(); 
}

static Transaction__Handle *copy_Transaction__HandlePtr(Transaction__Handle value) { 
  return new Transaction__Handle(value); 
}

static void delete_Transaction__HandlePtr(Transaction__Handle *obj) { 
  if (obj) delete obj; 
}

static void Transaction__HandlePtr_assign(Transaction__Handle *obj, Transaction__Handle value) {
  *obj = value;
}

static Transaction__Handle Transaction__HandlePtr_value(Transaction__Handle *obj) {
  return *obj;
}


static Block__Handle *new_Block__HandlePtr() { 
  return new Block__Handle(); 
}

static Block__Handle *copy_Block__HandlePtr(Block__Handle value) { 
  return new Block__Handle(value); 
}

static void delete_Block__HandlePtr(Block__Handle *obj) { 
  if (obj) delete obj; 
}

static void Block__HandlePtr_assign(Block__Handle *obj, Block__Handle value) {
  *obj = value;
}

static Block__Handle Block__HandlePtr_value(Block__Handle *obj) {
  return *obj;
}


static BlockHeader__Handle *new_BlockHeader__HandlePtr() { 
  return new BlockHeader__Handle(); 
}

static BlockHeader__Handle *copy_BlockHeader__HandlePtr(BlockHeader__Handle value) { 
  return new BlockHeader__Handle(value); 
}

static void delete_BlockHeader__HandlePtr(BlockHeader__Handle *obj) { 
  if (obj) delete obj; 
}

static void BlockHeader__HandlePtr_assign(BlockHeader__Handle *obj, BlockHeader__Handle value) {
  *obj = value;
}

static BlockHeader__Handle BlockHeader__HandlePtr_value(BlockHeader__Handle *obj) {
  return *obj;
}


static BlockBody__Handle *new_BlockBody__HandlePtr() { 
  return new BlockBody__Handle(); 
}

static BlockBody__Handle *copy_BlockBody__HandlePtr(BlockBody__Handle value) { 
  return new BlockBody__Handle(value); 
}

static void delete_BlockBody__HandlePtr(BlockBody__Handle *obj) { 
  if (obj) delete obj; 
}

static void BlockBody__HandlePtr_assign(BlockBody__Handle *obj, BlockBody__Handle value) {
  *obj = value;
}

static BlockBody__Handle BlockBody__HandlePtr_value(BlockBody__Handle *obj) {
  return *obj;
}


static Signature_Handle *new_Signature_HandlePtr() { 
  return new Signature_Handle(); 
}

static Signature_Handle *copy_Signature_HandlePtr(Signature_Handle value) { 
  return new Signature_Handle(value); 
}

static void delete_Signature_HandlePtr(Signature_Handle *obj) { 
  if (obj) delete obj; 
}

static void Signature_HandlePtr_assign(Signature_Handle *obj, Signature_Handle value) {
  *obj = value;
}

static Signature_Handle Signature_HandlePtr_value(Signature_Handle *obj) {
  return *obj;
}


static Number_Handle *new_Number_HandlePtr() { 
  return new Number_Handle(); 
}

static Number_Handle *copy_Number_HandlePtr(Number_Handle value) { 
  return new Number_Handle(value); 
}

static void delete_Number_HandlePtr(Number_Handle *obj) { 
  if (obj) delete obj; 
}

static void Number_HandlePtr_assign(Number_Handle *obj, Number_Handle value) {
  *obj = value;
}

static Number_Handle Number_HandlePtr_value(Number_Handle *obj) {
  return *obj;
}


static unsigned char *new_CharPtr() { 
  return new unsigned char(); 
}

static unsigned char *copy_CharPtr(unsigned char value) { 
  return new unsigned char(value); 
}

static void delete_CharPtr(unsigned char *obj) { 
  if (obj) delete obj; 
}

static void CharPtr_assign(unsigned char *obj, unsigned char value) {
  *obj = value;
}

static unsigned char CharPtr_value(unsigned char *obj) {
  return *obj;
}


static FeeCalculator *new_FeeCalculatorPtr() { 
  return new FeeCalculator(); 
}

static FeeCalculator *copy_FeeCalculatorPtr(FeeCalculator value) { 
  return new FeeCalculator(value); 
}

static void delete_FeeCalculatorPtr(FeeCalculator *obj) { 
  if (obj) delete obj; 
}

static void FeeCalculatorPtr_assign(FeeCalculator *obj, FeeCalculator value) {
  *obj = value;
}

static FeeCalculator FeeCalculatorPtr_value(FeeCalculator *obj) {
  return *obj;
}


static FeeCalcFunc *new_FeeCalcFuncPtr() { 
  return new FeeCalcFunc(); 
}

static FeeCalcFunc *copy_FeeCalcFuncPtr(FeeCalcFunc value) { 
  return new FeeCalcFunc(value); 
}

static void delete_FeeCalcFuncPtr(FeeCalcFunc *obj) { 
  if (obj) delete obj; 
}

static void FeeCalcFuncPtr_assign(FeeCalcFunc *obj, FeeCalcFunc value) {
  *obj = value;
}

static FeeCalcFunc FeeCalcFuncPtr_value(FeeCalcFunc *obj) {
  return *obj;
}


static coin__Block* *new_coin__BlockPtr() { 
  return new coin__Block*(); 
}

static coin__Block* *copy_coin__BlockPtr(coin__Block* value) { 
  return new coin__Block*(value); 
}

static void delete_coin__BlockPtr(coin__Block* *obj) { 
  if (obj) delete obj; 
}

static void coin__BlockPtr_assign(coin__Block* *obj, coin__Block* value) {
  *obj = value;
}

static coin__Block* coin__BlockPtr_value(coin__Block* *obj) {
  return *obj;
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(v8::Handle<v8::Value> valRef, char** cptr, size_t* psize, int *alloc)
{
  if(valRef->IsString()) {
    v8::Handle<v8::String> js_str = SWIGV8_TO_STRING(valRef);

    size_t len = SWIGV8_UTF8_LENGTH(js_str) + 1;
    char* cstr = new char[len];
    SWIGV8_WRITE_UTF8(js_str, cstr, len);
    
    if(alloc) *alloc = SWIG_NEWOBJ;
    if(psize) *psize = len;
    if(cptr) *cptr = cstr;
    
    return SWIG_OK;
  } else {
    if(valRef->IsObject()) {
      v8::Handle<v8::Object> obj = SWIGV8_TO_OBJECT(valRef);
      // try if the object is a wrapped char[]
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      if (pchar_descriptor) {
        void* vptr = 0;
        if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
          if (cptr) *cptr = (char *) vptr;
          if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
          if (alloc) *alloc = SWIG_OLDOBJ;
          return SWIG_OK;
        }
      }
      return SWIG_TypeError;
    } else {
      return SWIG_TypeError;
    }
  }
}




SWIGINTERN int _GoString__SetString(_GoString_ *self,char *str){
		self->p = str;
		self->n = strlen(str);
	}
SWIGINTERN char *_GoString__getString(_GoString_ *self){
		return (const char *)self->p;
	}

SWIGINTERNINLINE v8::Handle<v8::Value>
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      // TODO: handle extra long strings
      return SWIGV8_UNDEFINED();
    } else {
      v8::Handle<v8::String> js_str = SWIGV8_STRING_NEW2(carray, size);
      return js_str;
    }
  } else {
    return SWIGV8_UNDEFINED();
  }
}


SWIGINTERNINLINE v8::Handle<v8::Value> 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}

SWIGINTERN int _GoString__isEqual(_GoString_ *self,_GoString_ *string2){
  return (self->n == string2->n) &&
         (strcmp((char *)self->p, (char *)string2->p) == 0);
}
SWIGINTERN int GoSlice_isEqual(GoSlice *self,GoSlice *slice){
		return ((self->len == slice->len)) && (memcmp(self->data,slice->data, sizeof(GoSlice_))==0 );
	}
SWIGINTERN void GoSlice_convertString(GoSlice *self,_GoString_ data){
		self->data = data.p;
		self->len = strlen(data.p);
		self->cap = self->len;
	}

SWIGINTERN int
SWIG_AsCharArray(v8::Handle<v8::Value> obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (v8::Handle<v8::Value> obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}

SWIGINTERN void GoSlice_setAtChar(GoSlice *self,char p,long long i){
		((char *) self->data)[i] = p;
	}
SWIGINTERN void GoSlice_getString(GoSlice *self,_GoString_ *out){
	out->p = (char *)self->data;
	out->n = strlen((char *)self->data);
}
SWIGINTERN int GoSlice_getAtString(GoSlice *self,int index,_GoString_ *outs){
	int i;
	_GoString_ *iStr;
	char *out;
	for (i = 0, iStr = (_GoString_ *)self->data; i < self->len; ++i, ++iStr)
	{
		if (index == i)
		{
			out = _GoString__getString(iStr);
			_GoString__SetString(outs,out);
			return 0;
		}
	}
	return 1;
}

SWIGINTERN int
SWIG_AsVal_signed_SS_char (v8::Handle<v8::Value> obj, signed char *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SCHAR_MIN || v > SCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< signed char >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE v8::Handle<v8::Value>
SWIG_From_signed_SS_char  (signed char value)
{    
  return SWIG_From_long  (value);
}


/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined(__cplusplus) && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2))
#  define SWIG_isfinite(X) (__builtin_isfinite(X))
# elif defined(__clang__) && defined(__has_builtin)
#  if __has_builtin(__builtin_isfinite)
#   define SWIG_isfinite(X) (__builtin_isfinite(X))
#  endif
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_float (v8::Handle<v8::Value> obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< float >(v);
    }
  }  
  return res;
}


SWIGINTERN
v8::Handle<v8::Value> SWIG_From_double   (double val)
{
  return SWIGV8_NUMBER_NEW(val);
}


SWIGINTERNINLINE v8::Handle<v8::Value>
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}


#define SWIGV8_INIT skycoin_initialize


SWIGV8_ClientData _exports_cipher_PubKey_clientData;
SWIGV8_ClientData _exports_cipher_SecKey_clientData;
SWIGV8_ClientData _exports_cipher_Ripemd160_clientData;
SWIGV8_ClientData _exports_cipher_Sig_clientData;
SWIGV8_ClientData _exports_cipher_SHA256_clientData;
SWIGV8_ClientData _exports_cipher_Checksum_clientData;
SWIGV8_ClientData _exports_cipher_SecKeys_clientData;
SWIGV8_ClientData _exports_cipher_PubKeys_clientData;
SWIGV8_ClientData _exports_cipher_SHA256s_clientData;
SWIGV8_ClientData _exports_coin_UxOutArray_clientData;
SWIGV8_ClientData _exports_cipher_Addresses_clientData;
SWIGV8_ClientData _exports_Fee_Calculator_clientData;
SWIGV8_ClientData _exports__GoString__clientData;
SWIGV8_ClientData _exports_GoInterface_clientData;
SWIGV8_ClientData _exports_GoSlice_clientData;
SWIGV8_ClientData _exports_api__RichlistParams_clientData;
SWIGV8_ClientData _exports_api__NetworkConnectionsFilter_clientData;
SWIGV8_ClientData _exports_cipher__Address_clientData;
SWIGV8_ClientData _exports_cipher__BitcoinAddress_clientData;
SWIGV8_ClientData _exports_encrypt__ScryptChacha20poly1305_clientData;
SWIGV8_ClientData _exports_secp256k1go__Field_clientData;
SWIGV8_ClientData _exports_secp256k1go__XY_clientData;
SWIGV8_ClientData _exports_secp256k1go__XYZ_clientData;
SWIGV8_ClientData _exports_cli__SendAmount_clientData;
SWIGV8_ClientData _exports_coin__Transaction_clientData;
SWIGV8_ClientData _exports_coin__TransactionOutput_clientData;
SWIGV8_ClientData _exports_coin__BlockHeader_clientData;
SWIGV8_ClientData _exports_coin__BlockBody_clientData;
SWIGV8_ClientData _exports_coin__Block_clientData;
SWIGV8_ClientData _exports_coin__SignedBlock_clientData;
SWIGV8_ClientData _exports_coin__UxHead_clientData;
SWIGV8_ClientData _exports_coin__UxBody_clientData;
SWIGV8_ClientData _exports_coin__UxOut_clientData;
SWIGV8_ClientData _exports_httphelper__Address_clientData;
SWIGV8_ClientData _exports_httphelper__SHA256_clientData;
SWIGV8_ClientData _exports_wallet__Balance_clientData;
SWIGV8_ClientData _exports_wallet__BalancePair_clientData;
SWIGV8_ClientData _exports_wallet__Entry_clientData;
SWIGV8_ClientData _exports_wallet__Note_clientData;
SWIGV8_ClientData _exports_wallet__ReadableNote_clientData;
SWIGV8_ClientData _exports_transaction__UxBalance_clientData;
SWIGV8_ClientData _exports_api__TransactionInput_clientData;
SWIGV8_ClientData _exports_GoComplex64__clientData;
SWIGV8_ClientData _exports_GoComplex128__clientData;
SWIGV8_ClientData _exports_GoString__clientData;
SWIGV8_ClientData _exports_GoInterface__clientData;
SWIGV8_ClientData _exports_GoSlice__clientData;
SWIGV8_ClientData _exports_Number_clientData;
SWIGV8_ClientData _exports_Signature_clientData;
SWIGV8_ClientData _exports_Wallet_clientData;
SWIGV8_ClientData _exports_FeeCalculator_clientData;


static SwigV8ReturnValue _wrap_equalSlices(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  GoSlice *arg2 = (GoSlice *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_equalSlices.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equalSlices" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equalSlices" "', argument " "2"" of type '" "GoSlice *""'"); 
  }
  arg2 = reinterpret_cast< GoSlice * >(argp2);
  ecode3 = SWIG_AsVal_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "equalSlices" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  result = (int)equalSlices(arg1,arg2,arg3);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equalTransactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Transaction *arg1 = (coin__Transaction *) 0 ;
  coin__Transaction *arg2 = (coin__Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_equalTransactions.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equalTransactions" "', argument " "1"" of type '" "coin__Transaction *""'"); 
  }
  arg1 = reinterpret_cast< coin__Transaction * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_coin__Transaction, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equalTransactions" "', argument " "2"" of type '" "coin__Transaction *""'"); 
  }
  arg2 = reinterpret_cast< coin__Transaction * >(argp2);
  result = (int)equalTransactions(arg1,arg2);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equalTransactionsArrays(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Transactions *arg1 = (coin__Transactions *) 0 ;
  coin__Transactions *arg2 = (coin__Transactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_equalTransactionsArrays.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equalTransactionsArrays" "', argument " "1"" of type '" "coin__Transactions *""'"); 
  }
  arg1 = reinterpret_cast< coin__Transactions * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equalTransactionsArrays" "', argument " "2"" of type '" "coin__Transactions *""'"); 
  }
  arg2 = reinterpret_cast< coin__Transactions * >(argp2);
  result = (int)equalTransactionsArrays(arg1,arg2);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_equalBlockHeaders(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
  coin__BlockHeader *arg2 = (coin__BlockHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_equalBlockHeaders.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equalBlockHeaders" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
  }
  arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equalBlockHeaders" "', argument " "2"" of type '" "coin__BlockHeader *""'"); 
  }
  arg2 = reinterpret_cast< coin__BlockHeader * >(argp2);
  result = (int)equalBlockHeaders(arg1,arg2);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_GoSlicePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoSlicePtr.");
  
  result = (GoSlice *)new_GoSlicePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_GoSlicePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  GoSlice *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_GoSlicePtr.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "copy_GoSlicePtr" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "copy_GoSlicePtr" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  result = (GoSlice *)copy_GoSlicePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_GoSlicePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_GoSlicePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GoSlicePtr" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  delete_GoSlicePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoSlicePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  GoSlice arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoSlicePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlicePtr_assign" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoSlicePtr_assign" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GoSlicePtr_assign" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  GoSlicePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoSlicePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoSlice result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoSlicePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlicePtr_value" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  result = GoSlicePtr_value(arg1);
  jsresult = SWIG_NewPointerObj((new GoSlice(static_cast< const GoSlice& >(result))), SWIGTYPE_p_GoSlice, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_GoUint8Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint8_ *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoUint8Ptr.");
  
  result = (GoUint8_ *)new_GoUint8Ptr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_GoUint8Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint8_ arg1 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  GoUint8_ *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_GoUint8Ptr.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_char(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_GoUint8Ptr" "', argument " "1"" of type '" "GoUint8_""'");
  } 
  arg1 = static_cast< GoUint8_ >(val1);
  result = (GoUint8_ *)copy_GoUint8Ptr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_GoUint8Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint8_ *arg1 = (GoUint8_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_GoUint8Ptr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GoUint8Ptr" "', argument " "1"" of type '" "GoUint8_ *""'"); 
  }
  arg1 = reinterpret_cast< GoUint8_ * >(argp1);
  delete_GoUint8Ptr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint8Ptr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint8_ *arg1 = (GoUint8_ *) 0 ;
  GoUint8_ arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint8Ptr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint8Ptr_assign" "', argument " "1"" of type '" "GoUint8_ *""'"); 
  }
  arg1 = reinterpret_cast< GoUint8_ * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_char(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoUint8Ptr_assign" "', argument " "2"" of type '" "GoUint8_""'");
  } 
  arg2 = static_cast< GoUint8_ >(val2);
  GoUint8Ptr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint8Ptr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint8_ *arg1 = (GoUint8_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint8_ result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint8Ptr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint8Ptr_value" "', argument " "1"" of type '" "GoUint8_ *""'"); 
  }
  arg1 = reinterpret_cast< GoUint8_ * >(argp1);
  result = (GoUint8_)GoUint8Ptr_value(arg1);
  jsresult = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_GoStringPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoStringPtr.");
  
  result = (_GoString_ *)new_GoStringPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__GoString_, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_GoStringPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  _GoString_ *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_GoStringPtr.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p__GoString_,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "copy_GoStringPtr" "', argument " "1"" of type '" "_GoString_""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "copy_GoStringPtr" "', argument " "1"" of type '" "_GoString_""'");
    } else {
      arg1 = *(reinterpret_cast< _GoString_ * >(argp1));
    }
  }
  result = (_GoString_ *)copy_GoStringPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__GoString_, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_GoStringPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ *arg1 = (_GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_GoStringPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GoStringPtr" "', argument " "1"" of type '" "_GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< _GoString_ * >(argp1);
  delete_GoStringPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoStringPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ *arg1 = (_GoString_ *) 0 ;
  _GoString_ arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoStringPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoStringPtr_assign" "', argument " "1"" of type '" "_GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< _GoString_ * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p__GoString_,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoStringPtr_assign" "', argument " "2"" of type '" "_GoString_""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GoStringPtr_assign" "', argument " "2"" of type '" "_GoString_""'");
    } else {
      arg2 = *(reinterpret_cast< _GoString_ * >(argp2));
    }
  }
  GoStringPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoStringPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ *arg1 = (_GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  _GoString_ result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoStringPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoStringPtr_value" "', argument " "1"" of type '" "_GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< _GoString_ * >(argp1);
  result = GoStringPtr_value(arg1);
  jsresult = SWIG_NewPointerObj((new _GoString_(static_cast< const _GoString_& >(result))), SWIGTYPE_p__GoString_, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_IntPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  int *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_IntPtr.");
  
  result = (int *)new_IntPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_IntPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  int *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_IntPtr.");
  
  ecode1 = SWIG_AsVal_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_IntPtr" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = (int *)copy_IntPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_IntPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  int *arg1 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_IntPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IntPtr" "', argument " "1"" of type '" "int *""'"); 
  }
  arg1 = reinterpret_cast< int * >(argp1);
  delete_IntPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_IntPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  int *arg1 = (int *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_IntPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntPtr_assign" "', argument " "1"" of type '" "int *""'"); 
  }
  arg1 = reinterpret_cast< int * >(argp1);
  ecode2 = SWIG_AsVal_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IntPtr_assign" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  IntPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_IntPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  int *arg1 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_IntPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IntPtr_value" "', argument " "1"" of type '" "int *""'"); 
  }
  arg1 = reinterpret_cast< int * >(argp1);
  result = (int)IntPtr_value(arg1);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_coin__TransactionPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Transaction *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__TransactionPtr.");
  
  result = (coin__Transaction *)new_coin__TransactionPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__Transaction, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_coin__TransactionPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Transaction arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  coin__Transaction *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_coin__TransactionPtr.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_coin__Transaction,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "copy_coin__TransactionPtr" "', argument " "1"" of type '" "coin__Transaction""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "copy_coin__TransactionPtr" "', argument " "1"" of type '" "coin__Transaction""'");
    } else {
      arg1 = *(reinterpret_cast< coin__Transaction * >(argp1));
    }
  }
  result = (coin__Transaction *)copy_coin__TransactionPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__Transaction, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_coin__TransactionPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Transaction *arg1 = (coin__Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_coin__TransactionPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_coin__TransactionPtr" "', argument " "1"" of type '" "coin__Transaction *""'"); 
  }
  arg1 = reinterpret_cast< coin__Transaction * >(argp1);
  delete_coin__TransactionPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_coin__TransactionPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Transaction *arg1 = (coin__Transaction *) 0 ;
  coin__Transaction arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_coin__TransactionPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionPtr_assign" "', argument " "1"" of type '" "coin__Transaction *""'"); 
  }
  arg1 = reinterpret_cast< coin__Transaction * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_coin__Transaction,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__TransactionPtr_assign" "', argument " "2"" of type '" "coin__Transaction""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "coin__TransactionPtr_assign" "', argument " "2"" of type '" "coin__Transaction""'");
    } else {
      arg2 = *(reinterpret_cast< coin__Transaction * >(argp2));
    }
  }
  coin__TransactionPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_coin__TransactionPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Transaction *arg1 = (coin__Transaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  coin__Transaction result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_coin__TransactionPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionPtr_value" "', argument " "1"" of type '" "coin__Transaction *""'"); 
  }
  arg1 = reinterpret_cast< coin__Transaction * >(argp1);
  result = coin__TransactionPtr_value(arg1);
  jsresult = SWIG_NewPointerObj((new coin__Transaction(static_cast< const coin__Transaction& >(result))), SWIGTYPE_p_coin__Transaction, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_AddressUxOuts__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_AddressUxOuts__HandlePtr.");
  
  result = (AddressUxOuts_Handle *)new_AddressUxOuts__HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_AddressUxOuts__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  AddressUxOuts_Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_AddressUxOuts__HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_AddressUxOuts__HandlePtr" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  result = (AddressUxOuts_Handle *)copy_AddressUxOuts__HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_AddressUxOuts__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle *arg1 = (AddressUxOuts_Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_AddressUxOuts__HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AddressUxOuts__HandlePtr" "', argument " "1"" of type '" "AddressUxOuts_Handle *""'"); 
  }
  arg1 = reinterpret_cast< AddressUxOuts_Handle * >(argp1);
  delete_AddressUxOuts__HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_AddressUxOuts__HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle *arg1 = (AddressUxOuts_Handle *) 0 ;
  AddressUxOuts_Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_AddressUxOuts__HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddressUxOuts__HandlePtr_assign" "', argument " "1"" of type '" "AddressUxOuts_Handle *""'"); 
  }
  arg1 = reinterpret_cast< AddressUxOuts_Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AddressUxOuts__HandlePtr_assign" "', argument " "2"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg2 = static_cast< AddressUxOuts_Handle >(val2);
  AddressUxOuts__HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_AddressUxOuts__HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle *arg1 = (AddressUxOuts_Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  AddressUxOuts_Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_AddressUxOuts__HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddressUxOuts__HandlePtr_value" "', argument " "1"" of type '" "AddressUxOuts_Handle *""'"); 
  }
  arg1 = reinterpret_cast< AddressUxOuts_Handle * >(argp1);
  result = (AddressUxOuts_Handle)AddressUxOuts__HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_GoUint64Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned long long *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoUint64Ptr.");
  
  result = (unsigned long long *)new_GoUint64Ptr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_GoUint64Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned long long arg1 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  unsigned long long *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_GoUint64Ptr.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_GoUint64Ptr" "', argument " "1"" of type '" "unsigned long long""'");
  } 
  arg1 = static_cast< unsigned long long >(val1);
  result = (unsigned long long *)copy_GoUint64Ptr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_GoUint64Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned long long *arg1 = (unsigned long long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_GoUint64Ptr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GoUint64Ptr" "', argument " "1"" of type '" "unsigned long long *""'"); 
  }
  arg1 = reinterpret_cast< unsigned long long * >(argp1);
  delete_GoUint64Ptr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint64Ptr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned long long *arg1 = (unsigned long long *) 0 ;
  unsigned long long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint64Ptr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint64Ptr_assign" "', argument " "1"" of type '" "unsigned long long *""'"); 
  }
  arg1 = reinterpret_cast< unsigned long long * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoUint64Ptr_assign" "', argument " "2"" of type '" "unsigned long long""'");
  } 
  arg2 = static_cast< unsigned long long >(val2);
  GoUint64Ptr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint64Ptr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned long long *arg1 = (unsigned long long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint64Ptr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint64Ptr_value" "', argument " "1"" of type '" "unsigned long long *""'"); 
  }
  arg1 = reinterpret_cast< unsigned long long * >(argp1);
  result = (unsigned long long)GoUint64Ptr_value(arg1);
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_GointPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  long long *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GointPtr.");
  
  result = (long long *)new_GointPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_GointPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  long long arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_GointPtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_GointPtr" "', argument " "1"" of type '" "long long""'");
  } 
  arg1 = static_cast< long long >(val1);
  result = (long long *)copy_GointPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_GointPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  long long *arg1 = (long long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_GointPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GointPtr" "', argument " "1"" of type '" "long long *""'"); 
  }
  arg1 = reinterpret_cast< long long * >(argp1);
  delete_GointPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GointPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  long long *arg1 = (long long *) 0 ;
  long long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GointPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GointPtr_assign" "', argument " "1"" of type '" "long long *""'"); 
  }
  arg1 = reinterpret_cast< long long * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GointPtr_assign" "', argument " "2"" of type '" "long long""'");
  } 
  arg2 = static_cast< long long >(val2);
  GointPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GointPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  long long *arg1 = (long long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GointPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GointPtr_value" "', argument " "1"" of type '" "long long *""'"); 
  }
  arg1 = reinterpret_cast< long long * >(argp1);
  result = (long long)GointPtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_GoUint16Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned short *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoUint16Ptr.");
  
  result = (unsigned short *)new_GoUint16Ptr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_short, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_GoUint16Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned short arg1 ;
  unsigned short val1 ;
  int ecode1 = 0 ;
  unsigned short *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_GoUint16Ptr.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_short(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_GoUint16Ptr" "', argument " "1"" of type '" "unsigned short""'");
  } 
  arg1 = static_cast< unsigned short >(val1);
  result = (unsigned short *)copy_GoUint16Ptr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_short, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_GoUint16Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned short *arg1 = (unsigned short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_GoUint16Ptr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_short, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GoUint16Ptr" "', argument " "1"" of type '" "unsigned short *""'"); 
  }
  arg1 = reinterpret_cast< unsigned short * >(argp1);
  delete_GoUint16Ptr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint16Ptr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned short *arg1 = (unsigned short *) 0 ;
  unsigned short arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint16Ptr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_short, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint16Ptr_assign" "', argument " "1"" of type '" "unsigned short *""'"); 
  }
  arg1 = reinterpret_cast< unsigned short * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_short(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoUint16Ptr_assign" "', argument " "2"" of type '" "unsigned short""'");
  } 
  arg2 = static_cast< unsigned short >(val2);
  GoUint16Ptr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint16Ptr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned short *arg1 = (unsigned short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned short result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint16Ptr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_short, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint16Ptr_value" "', argument " "1"" of type '" "unsigned short *""'"); 
  }
  arg1 = reinterpret_cast< unsigned short * >(argp1);
  result = (unsigned short)GoUint16Ptr_value(arg1);
  jsresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_GoUint32Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned int *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoUint32Ptr.");
  
  result = (unsigned int *)new_GoUint32Ptr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_GoUint32Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_GoUint32Ptr.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_int(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_GoUint32Ptr" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (unsigned int *)copy_GoUint32Ptr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_GoUint32Ptr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned int *arg1 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_GoUint32Ptr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GoUint32Ptr" "', argument " "1"" of type '" "unsigned int *""'"); 
  }
  arg1 = reinterpret_cast< unsigned int * >(argp1);
  delete_GoUint32Ptr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint32Ptr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned int *arg1 = (unsigned int *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint32Ptr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint32Ptr_assign" "', argument " "1"" of type '" "unsigned int *""'"); 
  }
  arg1 = reinterpret_cast< unsigned int * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoUint32Ptr_assign" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  GoUint32Ptr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoUint32Ptr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned int *arg1 = (unsigned int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoUint32Ptr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoUint32Ptr_value" "', argument " "1"" of type '" "unsigned int *""'"); 
  }
  arg1 = reinterpret_cast< unsigned int * >(argp1);
  result = (unsigned int)GoUint32Ptr_value(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_cipher__AddressPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher__AddressPtr.");
  
  result = (cipher__Address *)new_cipher__AddressPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_cipher__AddressPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  cipher__Address *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_cipher__AddressPtr.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_cipher__Address,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "copy_cipher__AddressPtr" "', argument " "1"" of type '" "cipher__Address""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "copy_cipher__AddressPtr" "', argument " "1"" of type '" "cipher__Address""'");
    } else {
      arg1 = *(reinterpret_cast< cipher__Address * >(argp1));
    }
  }
  result = (cipher__Address *)copy_cipher__AddressPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_cipher__AddressPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_cipher__AddressPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_cipher__AddressPtr" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  delete_cipher__AddressPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_cipher__AddressPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  cipher__Address arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_cipher__AddressPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__AddressPtr_assign" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_cipher__Address,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher__AddressPtr_assign" "', argument " "2"" of type '" "cipher__Address""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cipher__AddressPtr_assign" "', argument " "2"" of type '" "cipher__Address""'");
    } else {
      arg2 = *(reinterpret_cast< cipher__Address * >(argp2));
    }
  }
  cipher__AddressPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_cipher__AddressPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  cipher__Address result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_cipher__AddressPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__AddressPtr_value" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  result = cipher__AddressPtr_value(arg1);
  jsresult = SWIG_NewPointerObj((new cipher__Address(static_cast< const cipher__Address& >(result))), SWIGTYPE_p_cipher__Address, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Transactions__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Transactions__HandlePtr.");
  
  result = (Transactions__Handle *)new_Transactions__HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_Transactions__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  Transactions__Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_Transactions__HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_Transactions__HandlePtr" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  result = (Transactions__Handle *)copy_Transactions__HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_Transactions__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle *arg1 = (Transactions__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_Transactions__HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Transactions__HandlePtr" "', argument " "1"" of type '" "Transactions__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transactions__Handle * >(argp1);
  delete_Transactions__HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Transactions__HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle *arg1 = (Transactions__Handle *) 0 ;
  Transactions__Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Transactions__HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transactions__HandlePtr_assign" "', argument " "1"" of type '" "Transactions__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transactions__Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Transactions__HandlePtr_assign" "', argument " "2"" of type '" "Transactions__Handle""'");
  } 
  arg2 = static_cast< Transactions__Handle >(val2);
  Transactions__HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Transactions__HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle *arg1 = (Transactions__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transactions__Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Transactions__HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transactions__HandlePtr_value" "', argument " "1"" of type '" "Transactions__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transactions__Handle * >(argp1);
  result = (Transactions__Handle)Transactions__HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Transaction__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Transaction__HandlePtr.");
  
  result = (Transaction__Handle *)new_Transaction__HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_Transaction__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  Transaction__Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_Transaction__HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_Transaction__HandlePtr" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  result = (Transaction__Handle *)copy_Transaction__HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_Transaction__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle *arg1 = (Transaction__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_Transaction__HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Transaction__HandlePtr" "', argument " "1"" of type '" "Transaction__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transaction__Handle * >(argp1);
  delete_Transaction__HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Transaction__HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle *arg1 = (Transaction__Handle *) 0 ;
  Transaction__Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Transaction__HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction__HandlePtr_assign" "', argument " "1"" of type '" "Transaction__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transaction__Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Transaction__HandlePtr_assign" "', argument " "2"" of type '" "Transaction__Handle""'");
  } 
  arg2 = static_cast< Transaction__Handle >(val2);
  Transaction__HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Transaction__HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle *arg1 = (Transaction__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transaction__Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Transaction__HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Transaction__HandlePtr_value" "', argument " "1"" of type '" "Transaction__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transaction__Handle * >(argp1);
  result = (Transaction__Handle)Transaction__HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Block__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Block__HandlePtr.");
  
  result = (Block__Handle *)new_Block__HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_Block__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  Block__Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_Block__HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_Block__HandlePtr" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  result = (Block__Handle *)copy_Block__HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_Block__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle *arg1 = (Block__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_Block__HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Block__HandlePtr" "', argument " "1"" of type '" "Block__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Block__Handle * >(argp1);
  delete_Block__HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Block__HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle *arg1 = (Block__Handle *) 0 ;
  Block__Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Block__HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Block__HandlePtr_assign" "', argument " "1"" of type '" "Block__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Block__Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Block__HandlePtr_assign" "', argument " "2"" of type '" "Block__Handle""'");
  } 
  arg2 = static_cast< Block__Handle >(val2);
  Block__HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Block__HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle *arg1 = (Block__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Block__Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Block__HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Block__HandlePtr_value" "', argument " "1"" of type '" "Block__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Block__Handle * >(argp1);
  result = (Block__Handle)Block__HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_BlockHeader__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_BlockHeader__HandlePtr.");
  
  result = (BlockHeader__Handle *)new_BlockHeader__HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_BlockHeader__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  BlockHeader__Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_BlockHeader__HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_BlockHeader__HandlePtr" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  result = (BlockHeader__Handle *)copy_BlockHeader__HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_BlockHeader__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle *arg1 = (BlockHeader__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_BlockHeader__HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BlockHeader__HandlePtr" "', argument " "1"" of type '" "BlockHeader__Handle *""'"); 
  }
  arg1 = reinterpret_cast< BlockHeader__Handle * >(argp1);
  delete_BlockHeader__HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_BlockHeader__HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle *arg1 = (BlockHeader__Handle *) 0 ;
  BlockHeader__Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_BlockHeader__HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BlockHeader__HandlePtr_assign" "', argument " "1"" of type '" "BlockHeader__Handle *""'"); 
  }
  arg1 = reinterpret_cast< BlockHeader__Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BlockHeader__HandlePtr_assign" "', argument " "2"" of type '" "BlockHeader__Handle""'");
  } 
  arg2 = static_cast< BlockHeader__Handle >(val2);
  BlockHeader__HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_BlockHeader__HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle *arg1 = (BlockHeader__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  BlockHeader__Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_BlockHeader__HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BlockHeader__HandlePtr_value" "', argument " "1"" of type '" "BlockHeader__Handle *""'"); 
  }
  arg1 = reinterpret_cast< BlockHeader__Handle * >(argp1);
  result = (BlockHeader__Handle)BlockHeader__HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_BlockBody__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_BlockBody__HandlePtr.");
  
  result = (BlockBody__Handle *)new_BlockBody__HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_BlockBody__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  BlockBody__Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_BlockBody__HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_BlockBody__HandlePtr" "', argument " "1"" of type '" "BlockBody__Handle""'");
  } 
  arg1 = static_cast< BlockBody__Handle >(val1);
  result = (BlockBody__Handle *)copy_BlockBody__HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_BlockBody__HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle *arg1 = (BlockBody__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_BlockBody__HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BlockBody__HandlePtr" "', argument " "1"" of type '" "BlockBody__Handle *""'"); 
  }
  arg1 = reinterpret_cast< BlockBody__Handle * >(argp1);
  delete_BlockBody__HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_BlockBody__HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle *arg1 = (BlockBody__Handle *) 0 ;
  BlockBody__Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_BlockBody__HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BlockBody__HandlePtr_assign" "', argument " "1"" of type '" "BlockBody__Handle *""'"); 
  }
  arg1 = reinterpret_cast< BlockBody__Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BlockBody__HandlePtr_assign" "', argument " "2"" of type '" "BlockBody__Handle""'");
  } 
  arg2 = static_cast< BlockBody__Handle >(val2);
  BlockBody__HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_BlockBody__HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle *arg1 = (BlockBody__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  BlockBody__Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_BlockBody__HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BlockBody__HandlePtr_value" "', argument " "1"" of type '" "BlockBody__Handle *""'"); 
  }
  arg1 = reinterpret_cast< BlockBody__Handle * >(argp1);
  result = (BlockBody__Handle)BlockBody__HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Signature_HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Signature_Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Signature_HandlePtr.");
  
  result = (Signature_Handle *)new_Signature_HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_Signature_HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Signature_Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  Signature_Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_Signature_HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_Signature_HandlePtr" "', argument " "1"" of type '" "Signature_Handle""'");
  } 
  arg1 = static_cast< Signature_Handle >(val1);
  result = (Signature_Handle *)copy_Signature_HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_Signature_HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Signature_Handle *arg1 = (Signature_Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_Signature_HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Signature_HandlePtr" "', argument " "1"" of type '" "Signature_Handle *""'"); 
  }
  arg1 = reinterpret_cast< Signature_Handle * >(argp1);
  delete_Signature_HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Signature_HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Signature_Handle *arg1 = (Signature_Handle *) 0 ;
  Signature_Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Signature_HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Signature_HandlePtr_assign" "', argument " "1"" of type '" "Signature_Handle *""'"); 
  }
  arg1 = reinterpret_cast< Signature_Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Signature_HandlePtr_assign" "', argument " "2"" of type '" "Signature_Handle""'");
  } 
  arg2 = static_cast< Signature_Handle >(val2);
  Signature_HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Signature_HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Signature_Handle *arg1 = (Signature_Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Signature_Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Signature_HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Signature_HandlePtr_value" "', argument " "1"" of type '" "Signature_Handle *""'"); 
  }
  arg1 = reinterpret_cast< Signature_Handle * >(argp1);
  result = (Signature_Handle)Signature_HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_Number_HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Number_Handle *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Number_HandlePtr.");
  
  result = (Number_Handle *)new_Number_HandlePtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_Number_HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Number_Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  Number_Handle *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_Number_HandlePtr.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_Number_HandlePtr" "', argument " "1"" of type '" "Number_Handle""'");
  } 
  arg1 = static_cast< Number_Handle >(val1);
  result = (Number_Handle *)copy_Number_HandlePtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long_long, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_Number_HandlePtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Number_Handle *arg1 = (Number_Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_Number_HandlePtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Number_HandlePtr" "', argument " "1"" of type '" "Number_Handle *""'"); 
  }
  arg1 = reinterpret_cast< Number_Handle * >(argp1);
  delete_Number_HandlePtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Number_HandlePtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Number_Handle *arg1 = (Number_Handle *) 0 ;
  Number_Handle arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Number_HandlePtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Number_HandlePtr_assign" "', argument " "1"" of type '" "Number_Handle *""'"); 
  }
  arg1 = reinterpret_cast< Number_Handle * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Number_HandlePtr_assign" "', argument " "2"" of type '" "Number_Handle""'");
  } 
  arg2 = static_cast< Number_Handle >(val2);
  Number_HandlePtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_Number_HandlePtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Number_Handle *arg1 = (Number_Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Number_Handle result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_Number_HandlePtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Number_HandlePtr_value" "', argument " "1"" of type '" "Number_Handle *""'"); 
  }
  arg1 = reinterpret_cast< Number_Handle * >(argp1);
  result = (Number_Handle)Number_HandlePtr_value(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_CharPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned char *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_CharPtr.");
  
  result = (unsigned char *)new_CharPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_CharPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned char arg1 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  unsigned char *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_CharPtr.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_char(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "copy_CharPtr" "', argument " "1"" of type '" "unsigned char""'");
  } 
  arg1 = static_cast< unsigned char >(val1);
  result = (unsigned char *)copy_CharPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_CharPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned char *arg1 = (unsigned char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_CharPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CharPtr" "', argument " "1"" of type '" "unsigned char *""'"); 
  }
  arg1 = reinterpret_cast< unsigned char * >(argp1);
  delete_CharPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CharPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned char *arg1 = (unsigned char *) 0 ;
  unsigned char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char val2 ;
  int ecode2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CharPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CharPtr_assign" "', argument " "1"" of type '" "unsigned char *""'"); 
  }
  arg1 = reinterpret_cast< unsigned char * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_char(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CharPtr_assign" "', argument " "2"" of type '" "unsigned char""'");
  } 
  arg2 = static_cast< unsigned char >(val2);
  CharPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_CharPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  unsigned char *arg1 = (unsigned char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_CharPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CharPtr_value" "', argument " "1"" of type '" "unsigned char *""'"); 
  }
  arg1 = reinterpret_cast< unsigned char * >(argp1);
  result = (unsigned char)CharPtr_value(arg1);
  jsresult = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_FeeCalculatorPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalculator *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_FeeCalculatorPtr.");
  
  result = (FeeCalculator *)new_FeeCalculatorPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FeeCalculator, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_FeeCalculatorPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalculator arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  FeeCalculator *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_FeeCalculatorPtr.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_FeeCalculator,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "copy_FeeCalculatorPtr" "', argument " "1"" of type '" "FeeCalculator""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "copy_FeeCalculatorPtr" "', argument " "1"" of type '" "FeeCalculator""'");
    } else {
      arg1 = *(reinterpret_cast< FeeCalculator * >(argp1));
    }
  }
  result = (FeeCalculator *)copy_FeeCalculatorPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FeeCalculator, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_FeeCalculatorPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalculator *arg1 = (FeeCalculator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_FeeCalculatorPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_FeeCalculator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FeeCalculatorPtr" "', argument " "1"" of type '" "FeeCalculator *""'"); 
  }
  arg1 = reinterpret_cast< FeeCalculator * >(argp1);
  delete_FeeCalculatorPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_FeeCalculatorPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalculator *arg1 = (FeeCalculator *) 0 ;
  FeeCalculator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_FeeCalculatorPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_FeeCalculator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalculatorPtr_assign" "', argument " "1"" of type '" "FeeCalculator *""'"); 
  }
  arg1 = reinterpret_cast< FeeCalculator * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_FeeCalculator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FeeCalculatorPtr_assign" "', argument " "2"" of type '" "FeeCalculator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FeeCalculatorPtr_assign" "', argument " "2"" of type '" "FeeCalculator""'");
    } else {
      arg2 = *(reinterpret_cast< FeeCalculator * >(argp2));
    }
  }
  FeeCalculatorPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_FeeCalculatorPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalculator *arg1 = (FeeCalculator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FeeCalculator result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_FeeCalculatorPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_FeeCalculator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalculatorPtr_value" "', argument " "1"" of type '" "FeeCalculator *""'"); 
  }
  arg1 = reinterpret_cast< FeeCalculator * >(argp1);
  result = FeeCalculatorPtr_value(arg1);
  jsresult = SWIG_NewPointerObj((new FeeCalculator(static_cast< const FeeCalculator& >(result))), SWIGTYPE_p_FeeCalculator, SWIG_POINTER_OWN |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_FeeCalcFuncPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalcFunc *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_FeeCalcFuncPtr.");
  
  result = (FeeCalcFunc *)new_FeeCalcFuncPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_FeeCalcFuncPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalcFunc arg1 = (FeeCalcFunc) 0 ;
  FeeCalcFunc *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_FeeCalcFuncPtr.");
  
  {
    int res = SWIG_ConvertFunctionPtr(args[0], (void**)(&arg1), SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "copy_FeeCalcFuncPtr" "', argument " "1"" of type '" "FeeCalcFunc""'"); 
    }
  }
  result = (FeeCalcFunc *)copy_FeeCalcFuncPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_FeeCalcFuncPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalcFunc *arg1 = (FeeCalcFunc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_FeeCalcFuncPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FeeCalcFuncPtr" "', argument " "1"" of type '" "FeeCalcFunc *""'"); 
  }
  arg1 = reinterpret_cast< FeeCalcFunc * >(argp1);
  delete_FeeCalcFuncPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_FeeCalcFuncPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalcFunc *arg1 = (FeeCalcFunc *) 0 ;
  FeeCalcFunc arg2 = (FeeCalcFunc) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_FeeCalcFuncPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalcFuncPtr_assign" "', argument " "1"" of type '" "FeeCalcFunc *""'"); 
  }
  arg1 = reinterpret_cast< FeeCalcFunc * >(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(args[1], (void**)(&arg2), SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "FeeCalcFuncPtr_assign" "', argument " "2"" of type '" "FeeCalcFunc""'"); 
    }
  }
  FeeCalcFuncPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_FeeCalcFuncPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  FeeCalcFunc *arg1 = (FeeCalcFunc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FeeCalcFunc result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_FeeCalcFuncPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalcFuncPtr_value" "', argument " "1"" of type '" "FeeCalcFunc *""'"); 
  }
  arg1 = reinterpret_cast< FeeCalcFunc * >(argp1);
  result = (FeeCalcFunc)FeeCalcFuncPtr_value(arg1);
  jsresult = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int);
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_new_coin__BlockPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Block **result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__BlockPtr.");
  
  result = (coin__Block **)new_coin__BlockPtr();
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_coin__Block, 0 |  0 );
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_copy_coin__BlockPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Block *arg1 = (coin__Block *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  coin__Block **result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_copy_coin__BlockPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__Block, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "copy_coin__BlockPtr" "', argument " "1"" of type '" "coin__Block *""'"); 
  }
  arg1 = reinterpret_cast< coin__Block * >(argp1);
  result = (coin__Block **)copy_coin__BlockPtr(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_coin__Block, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_delete_coin__BlockPtr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Block **arg1 = (coin__Block **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_delete_coin__BlockPtr.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_p_coin__Block, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_coin__BlockPtr" "', argument " "1"" of type '" "coin__Block **""'"); 
  }
  arg1 = reinterpret_cast< coin__Block ** >(argp1);
  delete_coin__BlockPtr(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_coin__BlockPtr_assign(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Block **arg1 = (coin__Block **) 0 ;
  coin__Block *arg2 = (coin__Block *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_coin__BlockPtr_assign.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_p_coin__Block, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockPtr_assign" "', argument " "1"" of type '" "coin__Block **""'"); 
  }
  arg1 = reinterpret_cast< coin__Block ** >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_coin__Block, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__BlockPtr_assign" "', argument " "2"" of type '" "coin__Block *""'"); 
  }
  arg2 = reinterpret_cast< coin__Block * >(argp2);
  coin__BlockPtr_assign(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_coin__BlockPtr_value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__Block **arg1 = (coin__Block **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  coin__Block *result = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_coin__BlockPtr_value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_p_coin__Block, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockPtr_value" "', argument " "1"" of type '" "coin__Block **""'"); 
  }
  arg1 = reinterpret_cast< coin__Block ** >(argp1);
  result = (coin__Block *)coin__BlockPtr_value(arg1);
  jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__Block, 0 |  0 );
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_PubKey_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_PubKey_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_PubKey *arg1 = (cipher_PubKey *) 0 ;
    GoUint8 *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_PubKey, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_PubKey_data_set" "', argument " "1"" of type '" "cipher_PubKey *""'"); 
    }
    arg1 = reinterpret_cast< cipher_PubKey * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_PubKey_data_set" "', argument " "2"" of type '" "GoUint8 [33]""'"); 
    } 
    arg2 = reinterpret_cast< GoUint8 * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)33; ++ii) *(GoUint8 *)&arg1->data[ii] = *((GoUint8 *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""data""' of type '""GoUint8 [33]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_PubKey_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_PubKey_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_PubKey *arg1 = (cipher_PubKey *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8 *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_PubKey, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_PubKey_data_get" "', argument " "1"" of type '" "cipher_PubKey *""'"); 
    }
    arg1 = reinterpret_cast< cipher_PubKey * >(argp1);
    result = (GoUint8 *)(GoUint8 *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_PubKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_PubKey *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_PubKey.");
  result = (cipher_PubKey *)new cipher_PubKey();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_PubKey, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_PubKey(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_PubKey(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_PubKey(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_PubKey(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_PubKey(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_PubKey * arg1 = (cipher_PubKey *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_SecKey_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_SecKey_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_SecKey *arg1 = (cipher_SecKey *) 0 ;
    GoUint8 *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SecKey, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SecKey_data_set" "', argument " "1"" of type '" "cipher_SecKey *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SecKey * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_SecKey_data_set" "', argument " "2"" of type '" "GoUint8 [32]""'"); 
    } 
    arg2 = reinterpret_cast< GoUint8 * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(GoUint8 *)&arg1->data[ii] = *((GoUint8 *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""data""' of type '""GoUint8 [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_SecKey_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_SecKey_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_SecKey *arg1 = (cipher_SecKey *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8 *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SecKey, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SecKey_data_get" "', argument " "1"" of type '" "cipher_SecKey *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SecKey * >(argp1);
    result = (GoUint8 *)(GoUint8 *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_SecKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_SecKey *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_SecKey.");
  result = (cipher_SecKey *)new cipher_SecKey();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_SecKey, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_SecKey(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_SecKey(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_SecKey(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_SecKey(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_SecKey(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_SecKey * arg1 = (cipher_SecKey *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_Ripemd160_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_Ripemd160_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_Ripemd160 *arg1 = (cipher_Ripemd160 *) 0 ;
    GoUint8 *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Ripemd160, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Ripemd160_data_set" "', argument " "1"" of type '" "cipher_Ripemd160 *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Ripemd160 * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_Ripemd160_data_set" "', argument " "2"" of type '" "GoUint8 [20]""'"); 
    } 
    arg2 = reinterpret_cast< GoUint8 * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)20; ++ii) *(GoUint8 *)&arg1->data[ii] = *((GoUint8 *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""data""' of type '""GoUint8 [20]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_Ripemd160_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_Ripemd160_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_Ripemd160 *arg1 = (cipher_Ripemd160 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8 *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Ripemd160, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Ripemd160_data_get" "', argument " "1"" of type '" "cipher_Ripemd160 *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Ripemd160 * >(argp1);
    result = (GoUint8 *)(GoUint8 *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_Ripemd160(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_Ripemd160 *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_Ripemd160.");
  result = (cipher_Ripemd160 *)new cipher_Ripemd160();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_Ripemd160, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_Ripemd160(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_Ripemd160(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_Ripemd160(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_Ripemd160(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_Ripemd160(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_Ripemd160 * arg1 = (cipher_Ripemd160 *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_Sig_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_Sig_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_Sig *arg1 = (cipher_Sig *) 0 ;
    GoUint8 *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Sig, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Sig_data_set" "', argument " "1"" of type '" "cipher_Sig *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Sig * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_Sig_data_set" "', argument " "2"" of type '" "GoUint8 [65]""'"); 
    } 
    arg2 = reinterpret_cast< GoUint8 * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)65; ++ii) *(GoUint8 *)&arg1->data[ii] = *((GoUint8 *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""data""' of type '""GoUint8 [65]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_Sig_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_Sig_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_Sig *arg1 = (cipher_Sig *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8 *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Sig, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Sig_data_get" "', argument " "1"" of type '" "cipher_Sig *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Sig * >(argp1);
    result = (GoUint8 *)(GoUint8 *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_Sig(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_Sig *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_Sig.");
  result = (cipher_Sig *)new cipher_Sig();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_Sig, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_Sig(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_Sig(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_Sig(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_Sig(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_Sig(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_Sig * arg1 = (cipher_Sig *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_SHA256_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_SHA256_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_SHA256 *arg1 = (cipher_SHA256 *) 0 ;
    GoUint8 *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SHA256, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SHA256_data_set" "', argument " "1"" of type '" "cipher_SHA256 *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SHA256 * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_SHA256_data_set" "', argument " "2"" of type '" "GoUint8 [32]""'"); 
    } 
    arg2 = reinterpret_cast< GoUint8 * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(GoUint8 *)&arg1->data[ii] = *((GoUint8 *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""data""' of type '""GoUint8 [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_SHA256_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_SHA256_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_SHA256 *arg1 = (cipher_SHA256 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8 *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SHA256, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SHA256_data_get" "', argument " "1"" of type '" "cipher_SHA256 *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SHA256 * >(argp1);
    result = (GoUint8 *)(GoUint8 *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_SHA256(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_SHA256 *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_SHA256.");
  result = (cipher_SHA256 *)new cipher_SHA256();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_SHA256, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_SHA256(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_SHA256(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_SHA256(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_SHA256(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_SHA256(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_SHA256 * arg1 = (cipher_SHA256 *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_Checksum_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_Checksum_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_Checksum *arg1 = (cipher_Checksum *) 0 ;
    GoUint8 *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Checksum, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Checksum_data_set" "', argument " "1"" of type '" "cipher_Checksum *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Checksum * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_Checksum_data_set" "', argument " "2"" of type '" "GoUint8 [4]""'"); 
    } 
    arg2 = reinterpret_cast< GoUint8 * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)4; ++ii) *(GoUint8 *)&arg1->data[ii] = *((GoUint8 *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""data""' of type '""GoUint8 [4]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_Checksum_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_Checksum_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_Checksum *arg1 = (cipher_Checksum *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8 *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Checksum, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Checksum_data_get" "', argument " "1"" of type '" "cipher_Checksum *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Checksum * >(argp1);
    result = (GoUint8 *)(GoUint8 *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_Checksum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_Checksum *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_Checksum.");
  result = (cipher_Checksum *)new cipher_Checksum();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_Checksum, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_Checksum(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_Checksum(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_Checksum(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_Checksum(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_Checksum(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_Checksum * arg1 = (cipher_Checksum *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_SecKeys_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_SecKeys_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_SecKeys *arg1 = (cipher_SecKeys *) 0 ;
    cipher_SecKey *arg2 = (cipher_SecKey *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SecKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SecKeys_data_set" "', argument " "1"" of type '" "cipher_SecKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SecKeys * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher_SecKey, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_SecKeys_data_set" "', argument " "2"" of type '" "cipher_SecKey *""'"); 
    }
    arg2 = reinterpret_cast< cipher_SecKey * >(argp2);
    if (arg1) (arg1)->data = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_SecKeys_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_SecKeys_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_SecKeys *arg1 = (cipher_SecKeys *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher_SecKey *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SecKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SecKeys_data_get" "', argument " "1"" of type '" "cipher_SecKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SecKeys * >(argp1);
    result = (cipher_SecKey *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher_SecKey, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_SecKeys_count_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_SecKeys_count_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_SecKeys *arg1 = (cipher_SecKeys *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SecKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SecKeys_count_set" "', argument " "1"" of type '" "cipher_SecKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SecKeys * >(argp1);
    ecode2 = SWIG_AsVal_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cipher_SecKeys_count_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
    if (arg1) (arg1)->count = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_SecKeys_count_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_SecKeys_count_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_SecKeys *arg1 = (cipher_SecKeys *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SecKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SecKeys_count_get" "', argument " "1"" of type '" "cipher_SecKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SecKeys * >(argp1);
    result = (int) ((arg1)->count);
    jsresult = SWIG_From_int(static_cast< int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_SecKeys(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_SecKeys *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_SecKeys.");
  result = (cipher_SecKeys *)new cipher_SecKeys();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_SecKeys, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_SecKeys(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_SecKeys(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_SecKeys(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_SecKeys(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_SecKeys(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_SecKeys * arg1 = (cipher_SecKeys *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_PubKeys_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_PubKeys_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_PubKeys *arg1 = (cipher_PubKeys *) 0 ;
    cipher_PubKey *arg2 = (cipher_PubKey *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_PubKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_PubKeys_data_set" "', argument " "1"" of type '" "cipher_PubKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_PubKeys * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher_PubKey, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_PubKeys_data_set" "', argument " "2"" of type '" "cipher_PubKey *""'"); 
    }
    arg2 = reinterpret_cast< cipher_PubKey * >(argp2);
    if (arg1) (arg1)->data = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_PubKeys_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_PubKeys_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_PubKeys *arg1 = (cipher_PubKeys *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher_PubKey *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_PubKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_PubKeys_data_get" "', argument " "1"" of type '" "cipher_PubKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_PubKeys * >(argp1);
    result = (cipher_PubKey *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher_PubKey, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_PubKeys_count_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_PubKeys_count_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_PubKeys *arg1 = (cipher_PubKeys *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_PubKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_PubKeys_count_set" "', argument " "1"" of type '" "cipher_PubKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_PubKeys * >(argp1);
    ecode2 = SWIG_AsVal_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cipher_PubKeys_count_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
    if (arg1) (arg1)->count = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_PubKeys_count_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_PubKeys_count_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_PubKeys *arg1 = (cipher_PubKeys *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_PubKeys, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_PubKeys_count_get" "', argument " "1"" of type '" "cipher_PubKeys *""'"); 
    }
    arg1 = reinterpret_cast< cipher_PubKeys * >(argp1);
    result = (int) ((arg1)->count);
    jsresult = SWIG_From_int(static_cast< int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_PubKeys(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_PubKeys *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_PubKeys.");
  result = (cipher_PubKeys *)new cipher_PubKeys();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_PubKeys, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_PubKeys(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_PubKeys(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_PubKeys(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_PubKeys(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_PubKeys(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_PubKeys * arg1 = (cipher_PubKeys *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_SHA256s_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_SHA256s_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_SHA256s *arg1 = (cipher_SHA256s *) 0 ;
    cipher_SHA256 *arg2 = (cipher_SHA256 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SHA256s, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SHA256s_data_set" "', argument " "1"" of type '" "cipher_SHA256s *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SHA256s * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher_SHA256, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_SHA256s_data_set" "', argument " "2"" of type '" "cipher_SHA256 *""'"); 
    }
    arg2 = reinterpret_cast< cipher_SHA256 * >(argp2);
    if (arg1) (arg1)->data = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_SHA256s_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_SHA256s_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_SHA256s *arg1 = (cipher_SHA256s *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher_SHA256 *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SHA256s, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SHA256s_data_get" "', argument " "1"" of type '" "cipher_SHA256s *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SHA256s * >(argp1);
    result = (cipher_SHA256 *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher_SHA256, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_SHA256s_count_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_SHA256s_count_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_SHA256s *arg1 = (cipher_SHA256s *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SHA256s, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SHA256s_count_set" "', argument " "1"" of type '" "cipher_SHA256s *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SHA256s * >(argp1);
    ecode2 = SWIG_AsVal_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cipher_SHA256s_count_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
    if (arg1) (arg1)->count = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_SHA256s_count_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_SHA256s_count_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_SHA256s *arg1 = (cipher_SHA256s *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_SHA256s, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_SHA256s_count_get" "', argument " "1"" of type '" "cipher_SHA256s *""'"); 
    }
    arg1 = reinterpret_cast< cipher_SHA256s * >(argp1);
    result = (int) ((arg1)->count);
    jsresult = SWIG_From_int(static_cast< int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_SHA256s(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_SHA256s *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_SHA256s.");
  result = (cipher_SHA256s *)new cipher_SHA256s();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_SHA256s, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_SHA256s(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_SHA256s(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_SHA256s(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_SHA256s(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_SHA256s(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_SHA256s * arg1 = (cipher_SHA256s *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin_UxOutArray_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin_UxOutArray_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin_UxOutArray *arg1 = (coin_UxOutArray *) 0 ;
    coin__UxOut *arg2 = (coin__UxOut *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin_UxOutArray, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin_UxOutArray_data_set" "', argument " "1"" of type '" "coin_UxOutArray *""'"); 
    }
    arg1 = reinterpret_cast< coin_UxOutArray * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_coin__UxOut, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin_UxOutArray_data_set" "', argument " "2"" of type '" "coin__UxOut *""'"); 
    }
    arg2 = reinterpret_cast< coin__UxOut * >(argp2);
    if (arg1) (arg1)->data = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin_UxOutArray_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin_UxOutArray_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin_UxOutArray *arg1 = (coin_UxOutArray *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__UxOut *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin_UxOutArray, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin_UxOutArray_data_get" "', argument " "1"" of type '" "coin_UxOutArray *""'"); 
    }
    arg1 = reinterpret_cast< coin_UxOutArray * >(argp1);
    result = (coin__UxOut *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__UxOut, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin_UxOutArray_count_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin_UxOutArray_count_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin_UxOutArray *arg1 = (coin_UxOutArray *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin_UxOutArray, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin_UxOutArray_count_set" "', argument " "1"" of type '" "coin_UxOutArray *""'"); 
    }
    arg1 = reinterpret_cast< coin_UxOutArray * >(argp1);
    ecode2 = SWIG_AsVal_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin_UxOutArray_count_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
    if (arg1) (arg1)->count = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin_UxOutArray_count_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin_UxOutArray_count_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin_UxOutArray *arg1 = (coin_UxOutArray *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin_UxOutArray, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin_UxOutArray_count_get" "', argument " "1"" of type '" "coin_UxOutArray *""'"); 
    }
    arg1 = reinterpret_cast< coin_UxOutArray * >(argp1);
    result = (int) ((arg1)->count);
    jsresult = SWIG_From_int(static_cast< int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin_UxOutArray(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin_UxOutArray *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin_UxOutArray.");
  result = (coin_UxOutArray *)new coin_UxOutArray();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin_UxOutArray, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin_UxOutArray(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin_UxOutArray(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin_UxOutArray(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin_UxOutArray(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin_UxOutArray(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin_UxOutArray * arg1 = (coin_UxOutArray *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_Addresses_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_Addresses_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_Addresses *arg1 = (cipher_Addresses *) 0 ;
    cipher__Address *arg2 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Addresses, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Addresses_data_set" "', argument " "1"" of type '" "cipher_Addresses *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Addresses * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher__Address, SWIG_POINTER_DISOWN |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher_Addresses_data_set" "', argument " "2"" of type '" "cipher__Address *""'"); 
    }
    arg2 = reinterpret_cast< cipher__Address * >(argp2);
    if (arg1) (arg1)->data = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_Addresses_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_Addresses_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_Addresses *arg1 = (cipher_Addresses *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher__Address *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Addresses, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Addresses_data_get" "', argument " "1"" of type '" "cipher_Addresses *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Addresses * >(argp1);
    result = (cipher__Address *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher_Addresses_count_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher_Addresses_count_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher_Addresses *arg1 = (cipher_Addresses *) 0 ;
    int arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Addresses, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Addresses_count_set" "', argument " "1"" of type '" "cipher_Addresses *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Addresses * >(argp1);
    ecode2 = SWIG_AsVal_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cipher_Addresses_count_set" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
    if (arg1) (arg1)->count = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher_Addresses_count_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher_Addresses_count_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher_Addresses *arg1 = (cipher_Addresses *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher_Addresses, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher_Addresses_count_get" "', argument " "1"" of type '" "cipher_Addresses *""'"); 
    }
    arg1 = reinterpret_cast< cipher_Addresses * >(argp1);
    result = (int) ((arg1)->count);
    jsresult = SWIG_From_int(static_cast< int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher_Addresses(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher_Addresses *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher_Addresses.");
  result = (cipher_Addresses *)new cipher_Addresses();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher_Addresses, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher_Addresses(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher_Addresses(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher_Addresses(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher_Addresses(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher_Addresses(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher_Addresses * arg1 = (cipher_Addresses *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Fee_Calculator_callback_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Fee_Calculator_callback_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Fee_Calculator *arg1 = (Fee_Calculator *) 0 ;
    FeeCalcFunc arg2 = (FeeCalcFunc) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Fee_Calculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fee_Calculator_callback_set" "', argument " "1"" of type '" "Fee_Calculator *""'"); 
    }
    arg1 = reinterpret_cast< Fee_Calculator * >(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(value, (void**)(&arg2), SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "Fee_Calculator_callback_set" "', argument " "2"" of type '" "FeeCalcFunc""'"); 
      }
    }
    if (arg1) (arg1)->callback = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Fee_Calculator_callback_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Fee_Calculator_callback_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Fee_Calculator *arg1 = (Fee_Calculator *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    FeeCalcFunc result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Fee_Calculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fee_Calculator_callback_get" "', argument " "1"" of type '" "Fee_Calculator *""'"); 
    }
    arg1 = reinterpret_cast< Fee_Calculator * >(argp1);
    result = (FeeCalcFunc) ((arg1)->callback);
    jsresult = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int);
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Fee_Calculator_context_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Fee_Calculator_context_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Fee_Calculator *arg1 = (Fee_Calculator *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Fee_Calculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fee_Calculator_context_set" "', argument " "1"" of type '" "Fee_Calculator *""'"); 
    }
    arg1 = reinterpret_cast< Fee_Calculator * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Fee_Calculator_context_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->context = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Fee_Calculator_context_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Fee_Calculator_context_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Fee_Calculator *arg1 = (Fee_Calculator *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Fee_Calculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Fee_Calculator_context_get" "', argument " "1"" of type '" "Fee_Calculator *""'"); 
    }
    arg1 = reinterpret_cast< Fee_Calculator * >(argp1);
    result = (void *) ((arg1)->context);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_Fee_Calculator(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  Fee_Calculator *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Fee_Calculator.");
  result = (Fee_Calculator *)new Fee_Calculator();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Fee_Calculator, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_Fee_Calculator(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_Fee_Calculator(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_Fee_Calculator(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_Fee_Calculator(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_Fee_Calculator(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            Fee_Calculator * arg1 = (Fee_Calculator *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


static SwigV8ReturnValue _wrap__GoString__SetString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ *arg1 = (_GoString_ *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap__GoString__SetString.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GoString__SetString" "', argument " "1"" of type '" "_GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< _GoString_ * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(args[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_GoString__SetString" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)_GoString__SetString(arg1,arg2);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap__GoString__getString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ *arg1 = (_GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap__GoString__getString.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GoString__getString" "', argument " "1"" of type '" "_GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< _GoString_ * >(argp1);
  result = (char *)_GoString__getString(arg1);
  jsresult = SWIG_FromCharPtr((const char *)result);
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap__GoString__isEqual(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  _GoString_ *arg1 = (_GoString_ *) 0 ;
  _GoString_ *arg2 = (_GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap__GoString__isEqual.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GoString__isEqual" "', argument " "1"" of type '" "_GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< _GoString_ * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_GoString__isEqual" "', argument " "2"" of type '" "_GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< _GoString_ * >(argp2);
  result = (int)_GoString__isEqual(arg1,arg2);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap__GoString__p_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap__GoString__p_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    _GoString_ *arg1 = (_GoString_ *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GoString__p_set" "', argument " "1"" of type '" "_GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< _GoString_ * >(argp1);
    res2 = SWIG_AsCharPtrAndSize(value, &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "_GoString__p_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);
    if (arg2) {
      size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >(arg2))) + 1;
      arg1->p = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg2, sizeof(char)*(size)));
    } else {
      arg1->p = 0;
    }
    
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap__GoString__p_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap__GoString__p_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    _GoString_ *arg1 = (_GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    char *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GoString__p_get" "', argument " "1"" of type '" "_GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< _GoString_ * >(argp1);
    result = (char *) ((arg1)->p);
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap__GoString__n_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap__GoString__n_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    _GoString_ *arg1 = (_GoString_ *) 0 ;
    ptrdiff_t arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GoString__n_set" "', argument " "1"" of type '" "_GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< _GoString_ * >(argp1);
    ecode2 = SWIG_AsVal_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "_GoString__n_set" "', argument " "2"" of type '" "ptrdiff_t""'");
    } 
    arg2 = static_cast< ptrdiff_t >(val2);
    if (arg1) (arg1)->n = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap__GoString__n_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap__GoString__n_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    _GoString_ *arg1 = (_GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    ptrdiff_t result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p__GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "_GoString__n_get" "', argument " "1"" of type '" "_GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< _GoString_ * >(argp1);
    result =  ((arg1)->n);
    jsresult = SWIG_From_long(static_cast< long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new__GoString_(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  _GoString_ *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new__GoString_.");
  result = (_GoString_ *)new _GoString_();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p__GoString_, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete__GoString_(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete__GoString_(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete__GoString_(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete__GoString_(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete__GoString_(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            _GoString_ * arg1 = (_GoString_ *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoInterface_t_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoInterface_t_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoInterface *arg1 = (GoInterface *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface_t_set" "', argument " "1"" of type '" "GoInterface *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoInterface_t_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->t = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoInterface_t_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoInterface_t_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoInterface *arg1 = (GoInterface *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface_t_get" "', argument " "1"" of type '" "GoInterface *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface * >(argp1);
    result = (void *) ((arg1)->t);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoInterface_v_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoInterface_v_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoInterface *arg1 = (GoInterface *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface_v_set" "', argument " "1"" of type '" "GoInterface *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoInterface_v_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->v = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoInterface_v_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoInterface_v_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoInterface *arg1 = (GoInterface *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface_v_get" "', argument " "1"" of type '" "GoInterface *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface * >(argp1);
    result = (void *) ((arg1)->v);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_GoInterface(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  GoInterface *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoInterface.");
  result = (GoInterface *)new GoInterface();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_GoInterface, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_GoInterface(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_GoInterface(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_GoInterface(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_GoInterface(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_GoInterface(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            GoInterface * arg1 = (GoInterface *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


static SwigV8ReturnValue _wrap_GoSlice_isEqual(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  GoSlice *arg2 = (GoSlice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoSlice_isEqual.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_isEqual" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoSlice_isEqual" "', argument " "2"" of type '" "GoSlice *""'"); 
  }
  arg2 = reinterpret_cast< GoSlice * >(argp2);
  result = (int)GoSlice_isEqual(arg1,arg2);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoSlice_convertString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  _GoString_ arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoString temp2 ;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoSlice_convertString.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_convertString" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (_GoString_)temp2;
  }
  GoSlice_convertString(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoSlice_setAtChar(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  char arg2 ;
  long long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  long long val3 ;
  int ecode3 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoSlice_setAtChar.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_setAtChar" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  ecode2 = SWIG_AsVal_char(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoSlice_setAtChar" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_long_SS_long(args[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GoSlice_setAtChar" "', argument " "3"" of type '" "long long""'");
  } 
  arg3 = static_cast< long long >(val3);
  GoSlice_setAtChar(arg1,arg2,arg3);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoSlice_getString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  _GoString_ *arg2 = (_GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoSlice_getString.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_getString" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  res2 = SWIG_ConvertPtr(args[0], &argp2,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoSlice_getString" "', argument " "2"" of type '" "_GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< _GoString_ * >(argp2);
  GoSlice_getString(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_GoSlice_getAtString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  int arg2 ;
  _GoString_ *arg3 = (_GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_GoSlice_getAtString.");
  
  res1 = SWIG_ConvertPtr(args.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_getAtString" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  ecode2 = SWIG_AsVal_int(args[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoSlice_getAtString" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(args[1], &argp3,SWIGTYPE_p__GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "GoSlice_getAtString" "', argument " "3"" of type '" "_GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< _GoString_ * >(argp3);
  result = (int)GoSlice_getAtString(arg1,arg2,arg3);
  jsresult = SWIG_From_int(static_cast< int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoSlice_data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoSlice_data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoSlice *arg1 = (GoSlice *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_data_set" "', argument " "1"" of type '" "GoSlice *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoSlice_data_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->data = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoSlice_data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoSlice_data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoSlice *arg1 = (GoSlice *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_data_get" "', argument " "1"" of type '" "GoSlice *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice * >(argp1);
    result = (void *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoSlice_len_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoSlice_len_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoSlice *arg1 = (GoSlice *) 0 ;
    GoInt arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_len_set" "', argument " "1"" of type '" "GoSlice *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoSlice_len_set" "', argument " "2"" of type '" "GoInt""'");
    } 
    arg2 = static_cast< GoInt >(val2);
    if (arg1) (arg1)->len = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoSlice_len_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoSlice_len_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoSlice *arg1 = (GoSlice *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_len_get" "', argument " "1"" of type '" "GoSlice *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice * >(argp1);
    result = (GoInt) ((arg1)->len);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoSlice_cap_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoSlice_cap_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoSlice *arg1 = (GoSlice *) 0 ;
    GoInt arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_cap_set" "', argument " "1"" of type '" "GoSlice *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoSlice_cap_set" "', argument " "2"" of type '" "GoInt""'");
    } 
    arg2 = static_cast< GoInt >(val2);
    if (arg1) (arg1)->cap = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoSlice_cap_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoSlice_cap_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoSlice *arg1 = (GoSlice *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice_cap_get" "', argument " "1"" of type '" "GoSlice *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice * >(argp1);
    result = (GoInt) ((arg1)->cap);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_GoSlice(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  GoSlice *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoSlice.");
  result = (GoSlice *)new GoSlice();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_GoSlice, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_GoSlice(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_GoSlice(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_GoSlice(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_GoSlice(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_GoSlice(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            GoSlice * arg1 = (GoSlice *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


static SwigV8ReturnValue _wrap_SKY_fee_VerifyTransactionFee(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoUint64 arg2 ;
  GoUint32 arg3 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_fee_VerifyTransactionFee.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_fee_VerifyTransactionFee" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_fee_VerifyTransactionFee" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_fee_VerifyTransactionFee" "', argument " "3"" of type '" "GoUint32""'");
  } 
  arg3 = static_cast< GoUint32 >(val3);
  result = (GoUint32)SKY_fee_VerifyTransactionFee(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_fee_VerifyTransactionFeeForHours(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoUint64 arg2 ;
  GoUint32 arg3 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_fee_VerifyTransactionFeeForHours.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_fee_VerifyTransactionFeeForHours" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_fee_VerifyTransactionFeeForHours" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_fee_VerifyTransactionFeeForHours" "', argument " "3"" of type '" "GoUint32""'");
  } 
  arg3 = static_cast< GoUint32 >(val3);
  result = (GoUint32)SKY_fee_VerifyTransactionFeeForHours(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_fee_RequiredFee(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoUint32 arg2 ;
  GoUint64 *arg3 = (GoUint64 *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_fee_RequiredFee.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_fee_RequiredFee" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_fee_RequiredFee" "', argument " "2"" of type '" "GoUint32""'");
  } 
  arg2 = static_cast< GoUint32 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_fee_RequiredFee" "', argument " "3"" of type '" "GoUint64 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint64 * >(argp3);
  result = (GoUint32)SKY_fee_RequiredFee(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_fee_RemainingHours(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoUint32 arg2 ;
  GoUint64 *arg3 = (GoUint64 *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_fee_RemainingHours.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_fee_RemainingHours" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_fee_RemainingHours" "', argument " "2"" of type '" "GoUint32""'");
  } 
  arg2 = static_cast< GoUint32 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_fee_RemainingHours" "', argument " "3"" of type '" "GoUint64 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint64 * >(argp3);
  result = (GoUint32)SKY_fee_RemainingHours(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_fee_TransactionFee(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoUint64 arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  GoUint64 *arg4 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_fee_TransactionFee.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_fee_TransactionFee" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_fee_TransactionFee" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_fee_TransactionFee" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_fee_TransactionFee" "', argument " "4"" of type '" "GoUint64 *""'"); 
  }
  arg4 = reinterpret_cast< GoUint64 * >(argp4);
  result = (GoUint32)SKY_fee_TransactionFee(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_JsonEncode_Handle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_JsonEncode_Handle.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_JsonEncode_Handle" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_JsonEncode_Handle" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_JsonEncode_Handle(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Progress_GetCurrent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Progress_GetCurrent.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Progress_GetCurrent" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_Handle_Progress_GetCurrent" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_Handle_Progress_GetCurrent(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Block_GetHeadSeq(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Block_GetHeadSeq.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Block_GetHeadSeq" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_Handle_Block_GetHeadSeq" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_Handle_Block_GetHeadSeq(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Block_GetHeadHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Block_GetHeadHash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Block_GetHeadHash" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_Handle_Block_GetHeadHash" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_Handle_Block_GetHeadHash(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Block_GetPreviousBlockHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Block_GetPreviousBlockHash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Block_GetPreviousBlockHash" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_Handle_Block_GetPreviousBlockHash" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_Handle_Block_GetPreviousBlockHash(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Blocks_GetAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoUint64 arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Blocks_GetAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Blocks_GetAt" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_Handle_Blocks_GetAt" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_Handle_Blocks_GetAt" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_Handle_Blocks_GetAt(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Blocks_GetCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Blocks_GetCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Blocks_GetCount" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_Handle_Blocks_GetCount" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_Handle_Blocks_GetCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Connections_GetCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Connections_GetCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Connections_GetCount" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_Handle_Connections_GetCount" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_Handle_Connections_GetCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Strings_GetCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Strings__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Strings_GetCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Strings_GetCount" "', argument " "1"" of type '" "Strings__Handle""'");
  } 
  arg1 = static_cast< Strings__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_Handle_Strings_GetCount" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_Handle_Strings_GetCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Strings_Sort(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Strings__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Strings_Sort.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Strings_Sort" "', argument " "1"" of type '" "Strings__Handle""'");
  } 
  arg1 = static_cast< Strings__Handle >(val1);
  result = (GoUint32)SKY_Handle_Strings_Sort(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_Handle_Strings_GetAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Strings__Handle arg1 ;
  GoInt arg2 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_Handle_Strings_GetAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_Handle_Strings_GetAt" "', argument " "1"" of type '" "Strings__Handle""'");
  } 
  arg1 = static_cast< Strings__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_Handle_Strings_GetAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_Handle_Strings_GetAt" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  result = (GoUint32)SKY_Handle_Strings_GetAt(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_Client_GetWalletDir(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_Client_GetWalletDir.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_Client_GetWalletDir" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_Client_GetWalletDir" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_Client_GetWalletDir(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_Client_GetWalletFileName(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  WalletResponse__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_Client_GetWalletFileName.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_Client_GetWalletFileName" "', argument " "1"" of type '" "WalletResponse__Handle""'");
  } 
  arg1 = static_cast< WalletResponse__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_Client_GetWalletFileName" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_Client_GetWalletFileName(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_Client_GetWalletLabel(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  WalletResponse__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_Client_GetWalletLabel.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_Client_GetWalletLabel" "', argument " "1"" of type '" "WalletResponse__Handle""'");
  } 
  arg1 = static_cast< WalletResponse__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_Client_GetWalletLabel" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_Client_GetWalletLabel(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_Client_GetWalletFullPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  WalletResponse__Handle arg2 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_Client_GetWalletFullPath.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_Client_GetWalletFullPath" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Handle_Client_GetWalletFullPath" "', argument " "2"" of type '" "WalletResponse__Handle""'");
  } 
  arg2 = static_cast< WalletResponse__Handle >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Handle_Client_GetWalletFullPath" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  result = (GoUint32)SKY_api_Handle_Client_GetWalletFullPath(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_GetWalletMeta(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoStringMap_ *arg2 = (GoStringMap_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_GetWalletMeta.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_GetWalletMeta" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_GetWalletMeta" "', argument " "2"" of type '" "GoStringMap_ *""'"); 
  }
  arg2 = reinterpret_cast< GoStringMap_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_GetWalletMeta(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_GetWalletEntriesCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_GetWalletEntriesCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_GetWalletEntriesCount" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_GetWalletEntriesCount" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_api_Handle_GetWalletEntriesCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_Client_GetWalletResponseEntriesCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  WalletResponse__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_Client_GetWalletResponseEntriesCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_Client_GetWalletResponseEntriesCount" "', argument " "1"" of type '" "WalletResponse__Handle""'");
  } 
  arg1 = static_cast< WalletResponse__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_Client_GetWalletResponseEntriesCount" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_api_Handle_Client_GetWalletResponseEntriesCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_WalletGetEntry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoUint32 arg2 ;
  cipher__Address *arg3 = (cipher__Address *) 0 ;
  cipher__PubKey *arg4 = (cipher__PubKey *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_WalletGetEntry.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_WalletGetEntry" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Handle_WalletGetEntry" "', argument " "2"" of type '" "GoUint32""'");
  } 
  arg2 = static_cast< GoUint32 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Handle_WalletGetEntry" "', argument " "3"" of type '" "cipher__Address *""'"); 
  }
  arg3 = reinterpret_cast< cipher__Address * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_api_Handle_WalletGetEntry" "', argument " "4"" of type '" "cipher__PubKey *""'"); 
  }
  arg4 = reinterpret_cast< cipher__PubKey * >(argp4);
  result = (GoUint32)SKY_api_Handle_WalletGetEntry(arg1,arg2,arg3,(unsigned char (*)[33])arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_WalletResponseGetEntry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  WalletResponse__Handle arg1 ;
  GoUint32 arg2 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  GoString_ *arg4 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_WalletResponseGetEntry.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_WalletResponseGetEntry" "', argument " "1"" of type '" "WalletResponse__Handle""'");
  } 
  arg1 = static_cast< WalletResponse__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Handle_WalletResponseGetEntry" "', argument " "2"" of type '" "GoUint32""'");
  } 
  arg2 = static_cast< GoUint32 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Handle_WalletResponseGetEntry" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_api_Handle_WalletResponseGetEntry" "', argument " "4"" of type '" "GoString_ *""'"); 
  }
  arg4 = reinterpret_cast< GoString_ * >(argp4);
  result = (GoUint32)SKY_api_Handle_WalletResponseGetEntry(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_WalletResponseIsEncrypted(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  WalletResponse__Handle arg1 ;
  GoUint8 *arg2 = (GoUint8 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_WalletResponseIsEncrypted.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_WalletResponseIsEncrypted" "', argument " "1"" of type '" "WalletResponse__Handle""'");
  } 
  arg1 = static_cast< WalletResponse__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_WalletResponseIsEncrypted" "', argument " "2"" of type '" "GoUint8 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint8 * >(argp2);
  result = (GoUint32)SKY_api_Handle_WalletResponseIsEncrypted(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_WalletResponseGetCryptoType(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  WalletResponse__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_WalletResponseGetCryptoType.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_WalletResponseGetCryptoType" "', argument " "1"" of type '" "WalletResponse__Handle""'");
  } 
  arg1 = static_cast< WalletResponse__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_WalletResponseGetCryptoType" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_WalletResponseGetCryptoType(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_WalletsResponseGetCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallets__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_WalletsResponseGetCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_WalletsResponseGetCount" "', argument " "1"" of type '" "Wallets__Handle""'");
  } 
  arg1 = static_cast< Wallets__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_WalletsResponseGetCount" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_api_Handle_WalletsResponseGetCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_WalletsResponseGetAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallets__Handle arg1 ;
  GoUint32 arg2 ;
  WalletResponse__Handle *arg3 = (WalletResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_WalletsResponseGetAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_WalletsResponseGetAt" "', argument " "1"" of type '" "Wallets__Handle""'");
  } 
  arg1 = static_cast< Wallets__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Handle_WalletsResponseGetAt" "', argument " "2"" of type '" "GoUint32""'");
  } 
  arg2 = static_cast< GoUint32 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Handle_WalletsResponseGetAt" "', argument " "3"" of type '" "WalletResponse__Handle *""'"); 
  }
  arg3 = reinterpret_cast< WalletResponse__Handle * >(argp3);
  result = (GoUint32)SKY_api_Handle_WalletsResponseGetAt(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_GetWalletFolderAddress(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_GetWalletFolderAddress.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_GetWalletFolderAddress" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_GetWalletFolderAddress" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_GetWalletFolderAddress(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_GetWalletSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_GetWalletSeed.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_GetWalletSeed" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_GetWalletSeed" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_GetWalletSeed(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_GetWalletLastSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_GetWalletLastSeed.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_GetWalletLastSeed" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_GetWalletLastSeed" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Handle_GetWalletLastSeed(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Handle_GetBuildInfoData(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BuildInfo_Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  GoString_ *arg4 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Handle_GetBuildInfoData.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Handle_GetBuildInfoData" "', argument " "1"" of type '" "BuildInfo_Handle""'");
  } 
  arg1 = static_cast< BuildInfo_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Handle_GetBuildInfoData" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Handle_GetBuildInfoData" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_api_Handle_GetBuildInfoData" "', argument " "4"" of type '" "GoString_ *""'"); 
  }
  arg4 = reinterpret_cast< GoString_ * >(argp4);
  result = (GoUint32)SKY_api_Handle_GetBuildInfoData(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Address_UnmarshalJSON(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Address *arg1 = (httphelper__Address *) 0 ;
  GoSlice arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Address_UnmarshalJSON.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_httphelper__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Address_UnmarshalJSON" "', argument " "1"" of type '" "httphelper__Address *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Address * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Address_UnmarshalJSON" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_httphelper_Address_UnmarshalJSON" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  result = (GoUint32)SKY_httphelper_Address_UnmarshalJSON(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Address_MarshalJSON(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Address *arg1 = (httphelper__Address *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Address_MarshalJSON.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_httphelper__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Address_MarshalJSON" "', argument " "1"" of type '" "httphelper__Address *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Address * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Address_MarshalJSON" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_httphelper_Address_MarshalJSON(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Coins_UnmarshalJSON(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Coins *arg1 = (httphelper__Coins *) 0 ;
  GoSlice arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Coins_UnmarshalJSON.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Coins_UnmarshalJSON" "', argument " "1"" of type '" "httphelper__Coins *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Coins * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Coins_UnmarshalJSON" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_httphelper_Coins_UnmarshalJSON" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  result = (GoUint32)SKY_httphelper_Coins_UnmarshalJSON(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Coins_MarshalJSON(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Coins *arg1 = (httphelper__Coins *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Coins_MarshalJSON.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Coins_MarshalJSON" "', argument " "1"" of type '" "httphelper__Coins *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Coins * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Coins_MarshalJSON" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_httphelper_Coins_MarshalJSON(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Coins_Value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Coins *arg1 = (httphelper__Coins *) 0 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Coins_Value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Coins_Value" "', argument " "1"" of type '" "httphelper__Coins *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Coins * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Coins_Value" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_httphelper_Coins_Value(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Hours_UnmarshalJSON(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Hours *arg1 = (httphelper__Hours *) 0 ;
  GoSlice arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Hours_UnmarshalJSON.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Hours_UnmarshalJSON" "', argument " "1"" of type '" "httphelper__Hours *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Hours * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Hours_UnmarshalJSON" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_httphelper_Hours_UnmarshalJSON" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  result = (GoUint32)SKY_httphelper_Hours_UnmarshalJSON(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Hours_MarshalJSON(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Hours *arg1 = (httphelper__Hours *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Hours_MarshalJSON.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Hours_MarshalJSON" "', argument " "1"" of type '" "httphelper__Hours *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Hours * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Hours_MarshalJSON" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_httphelper_Hours_MarshalJSON(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_httphelper_Hours_Value(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  httphelper__Hours *arg1 = (httphelper__Hours *) 0 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_httphelper_Hours_Value.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_httphelper_Hours_Value" "', argument " "1"" of type '" "httphelper__Hours *""'"); 
  }
  arg1 = reinterpret_cast< httphelper__Hours * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_httphelper_Hours_Value" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_httphelper_Hours_Value(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_util_AddUint64(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoUint64 arg2 ;
  GoUint64 *arg3 = (GoUint64 *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_util_AddUint64.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_util_AddUint64" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_util_AddUint64" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_util_AddUint64" "', argument " "3"" of type '" "GoUint64 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint64 * >(argp3);
  result = (GoUint32)SKY_util_AddUint64(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_util_Uint64ToInt64(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoInt64 *arg2 = (GoInt64 *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_util_Uint64ToInt64.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_util_Uint64ToInt64" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_util_Uint64ToInt64" "', argument " "2"" of type '" "GoInt64 *""'"); 
  }
  arg2 = reinterpret_cast< GoInt64 * >(argp2);
  result = (GoUint32)SKY_util_Uint64ToInt64(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_util_Int64ToUint64(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoInt64 arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_util_Int64ToUint64.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_util_Int64ToUint64" "', argument " "1"" of type '" "GoInt64""'");
  } 
  arg1 = static_cast< GoInt64 >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_util_Int64ToUint64" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_util_Int64ToUint64(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_util_IntToUint32(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoInt arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_util_IntToUint32.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_util_IntToUint32" "', argument " "1"" of type '" "GoInt""'");
  } 
  arg1 = static_cast< GoInt >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_util_IntToUint32" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_util_IntToUint32(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_AddPrivateKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_AddPrivateKey.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cli_AddPrivateKey" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  result = (GoUint32)SKY_cli_AddPrivateKey(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_AddPrivateKeyToFile(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString arg2 ;
  PasswordReader__Handle arg3 ;
  GoString temp1 ;
  GoString temp2 ;
  long long val3 ;
  int ecode3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_AddPrivateKeyToFile.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_cli_AddPrivateKeyToFile" "', argument " "3"" of type '" "PasswordReader__Handle""'");
  } 
  arg3 = static_cast< PasswordReader__Handle >(val3);
  result = (GoUint32)SKY_cli_AddPrivateKeyToFile(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_CreateOptionsHandle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  GoUint8 arg4 ;
  GoString arg5 ;
  GoString arg6 ;
  GoUint64 arg7 ;
  Options__Handle *arg8 = (Options__Handle *) 0 ;
  GoString temp1 ;
  GoString temp2 ;
  GoString temp3 ;
  unsigned char val4 ;
  int ecode4 = 0 ;
  GoString temp5 ;
  GoString temp6 ;
  unsigned long long val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_CreateOptionsHandle.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  ecode4 = SWIG_AsVal_unsigned_SS_char(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SKY_wallet_CreateOptionsHandle" "', argument " "4"" of type '" "GoUint8""'");
  } 
  arg4 = static_cast< GoUint8 >(val4);
  {
    temp5.p = NULL;
    temp5.n = 0;
    arg5 = (GoString)temp5;
  }
  {
    temp6.p = NULL;
    temp6.n = 0;
    arg6 = (GoString)temp6;
  }
  ecode7 = SWIG_AsVal_unsigned_SS_long_SS_long(args[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "SKY_wallet_CreateOptionsHandle" "', argument " "7"" of type '" "GoUint64""'");
  } 
  arg7 = static_cast< GoUint64 >(val7);
  res8 = SWIG_ConvertPtr(args[7], &argp8,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "SKY_wallet_CreateOptionsHandle" "', argument " "8"" of type '" "Options__Handle *""'"); 
  }
  arg8 = reinterpret_cast< Options__Handle * >(argp8);
  result = (GoUint32)SKY_wallet_CreateOptionsHandle(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Entry_Verify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  wallet__Entry *arg1 = (wallet__Entry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Entry_Verify.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_wallet_Entry_Verify" "', argument " "1"" of type '" "wallet__Entry *""'"); 
  }
  arg1 = reinterpret_cast< wallet__Entry * >(argp1);
  result = (GoUint32)SKY_wallet_Entry_Verify(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Entry_VerifyPublic(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  wallet__Entry *arg1 = (wallet__Entry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Entry_VerifyPublic.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_wallet_Entry_VerifyPublic" "', argument " "1"" of type '" "wallet__Entry *""'"); 
  }
  arg1 = reinterpret_cast< wallet__Entry * >(argp1);
  result = (GoUint32)SKY_wallet_Entry_VerifyPublic(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_logging_EnableColors(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_logging_EnableColors.");
  
  result = (GoUint32)SKY_logging_EnableColors();
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_logging_DisableColors(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_logging_DisableColors.");
  
  result = (GoUint32)SKY_logging_DisableColors();
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_logging_Disable(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_logging_Disable.");
  
  result = (GoUint32)SKY_logging_Disable();
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_CLI_Run(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  CLI__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_CLI_Run.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cli_CLI_Run" "', argument " "1"" of type '" "CLI__Handle""'");
  } 
  arg1 = static_cast< CLI__Handle >(val1);
  result = (GoUint32)SKY_cli_CLI_Run(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_Config_GetCoin(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Config__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_Config_GetCoin.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cli_Config_GetCoin" "', argument " "1"" of type '" "Config__Handle""'");
  } 
  arg1 = static_cast< Config__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_Config_GetCoin" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cli_Config_GetCoin(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_Config_GetRPCAddress(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Config__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_Config_GetRPCAddress.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cli_Config_GetRPCAddress" "', argument " "1"" of type '" "Config__Handle""'");
  } 
  arg1 = static_cast< Config__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_Config_GetRPCAddress" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cli_Config_GetRPCAddress(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_Getenv(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_Getenv.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_Getenv" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cli_Getenv(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_Setenv(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString arg2 ;
  GoString temp1 ;
  GoString temp2 ;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_Setenv.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  result = (GoUint32)SKY_cli_Setenv(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_NewBalance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoUint64 arg2 ;
  wallet__Balance *arg3 = (wallet__Balance *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_NewBalance.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_NewBalance" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_wallet_NewBalance" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_NewBalance" "', argument " "3"" of type '" "wallet__Balance *""'"); 
  }
  arg3 = reinterpret_cast< wallet__Balance * >(argp3);
  result = (GoUint32)SKY_wallet_NewBalance(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_NewBalanceFromUxOut(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  coin__UxOut *arg2 = (coin__UxOut *) 0 ;
  wallet__Balance *arg3 = (wallet__Balance *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_NewBalanceFromUxOut.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_NewBalanceFromUxOut" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_coin__UxOut, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_NewBalanceFromUxOut" "', argument " "2"" of type '" "coin__UxOut *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxOut * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_NewBalanceFromUxOut" "', argument " "3"" of type '" "wallet__Balance *""'"); 
  }
  arg3 = reinterpret_cast< wallet__Balance * >(argp3);
  result = (GoUint32)SKY_wallet_NewBalanceFromUxOut(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Balance_Add(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  wallet__Balance *arg1 = (wallet__Balance *) 0 ;
  wallet__Balance *arg2 = (wallet__Balance *) 0 ;
  wallet__Balance *arg3 = (wallet__Balance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Balance_Add.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_wallet_Balance_Add" "', argument " "1"" of type '" "wallet__Balance *""'"); 
  }
  arg1 = reinterpret_cast< wallet__Balance * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Balance_Add" "', argument " "2"" of type '" "wallet__Balance *""'"); 
  }
  arg2 = reinterpret_cast< wallet__Balance * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_Balance_Add" "', argument " "3"" of type '" "wallet__Balance *""'"); 
  }
  arg3 = reinterpret_cast< wallet__Balance * >(argp3);
  result = (GoUint32)SKY_wallet_Balance_Add(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Balance_Sub(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  wallet__Balance *arg1 = (wallet__Balance *) 0 ;
  wallet__Balance *arg2 = (wallet__Balance *) 0 ;
  wallet__Balance *arg3 = (wallet__Balance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Balance_Sub.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_wallet_Balance_Sub" "', argument " "1"" of type '" "wallet__Balance *""'"); 
  }
  arg1 = reinterpret_cast< wallet__Balance * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Balance_Sub" "', argument " "2"" of type '" "wallet__Balance *""'"); 
  }
  arg2 = reinterpret_cast< wallet__Balance * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_Balance_Sub" "', argument " "3"" of type '" "wallet__Balance *""'"); 
  }
  arg3 = reinterpret_cast< wallet__Balance * >(argp3);
  result = (GoUint32)SKY_wallet_Balance_Sub(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Balance_Equals(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  wallet__Balance *arg1 = (wallet__Balance *) 0 ;
  wallet__Balance *arg2 = (wallet__Balance *) 0 ;
  GoUint8 *arg3 = (GoUint8 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Balance_Equals.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_wallet_Balance_Equals" "', argument " "1"" of type '" "wallet__Balance *""'"); 
  }
  arg1 = reinterpret_cast< wallet__Balance * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Balance_Equals" "', argument " "2"" of type '" "wallet__Balance *""'"); 
  }
  arg2 = reinterpret_cast< wallet__Balance * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_Balance_Equals" "', argument " "3"" of type '" "GoUint8 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint8 * >(argp3);
  result = (GoUint32)SKY_wallet_Balance_Equals(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Balance_IsZero(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  wallet__Balance *arg1 = (wallet__Balance *) 0 ;
  GoUint8 *arg2 = (GoUint8 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Balance_IsZero.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_wallet_Balance_IsZero" "', argument " "1"" of type '" "wallet__Balance *""'"); 
  }
  arg1 = reinterpret_cast< wallet__Balance * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Balance_IsZero" "', argument " "2"" of type '" "GoUint8 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint8 * >(argp2);
  result = (GoUint32)SKY_wallet_Balance_IsZero(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_certutil_NewTLSCertPair(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString arg2 ;
  GoSlice arg3 ;
  coin__UxArray *arg4 = (coin__UxArray *) 0 ;
  coin__UxArray *arg5 = (coin__UxArray *) 0 ;
  GoString temp1 ;
  GoString temp2 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_certutil_NewTLSCertPair.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_certutil_NewTLSCertPair" "', argument " "3"" of type '" "GoSlice""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_certutil_NewTLSCertPair" "', argument " "3"" of type '" "GoSlice""'");
    } else {
      arg3 = *(reinterpret_cast< GoSlice * >(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_certutil_NewTLSCertPair" "', argument " "4"" of type '" "coin__UxArray *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxArray * >(argp4);
  res5 = SWIG_ConvertPtr(args[4], &argp5,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SKY_certutil_NewTLSCertPair" "', argument " "5"" of type '" "coin__UxArray *""'"); 
  }
  arg5 = reinterpret_cast< coin__UxArray * >(argp5);
  result = (GoUint32)SKY_certutil_NewTLSCertPair(arg1,arg2,arg3,arg4,arg5);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_DecodeBase58BitcoinAddress(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  cipher__BitcoinAddress *arg2 = (cipher__BitcoinAddress *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_DecodeBase58BitcoinAddress.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_DecodeBase58BitcoinAddress" "', argument " "2"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg2 = reinterpret_cast< cipher__BitcoinAddress * >(argp2);
  result = (GoUint32)SKY_cipher_DecodeBase58BitcoinAddress(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddressFromPubKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  cipher__BitcoinAddress *arg2 = (cipher__BitcoinAddress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddressFromPubKey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddressFromPubKey" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinAddressFromPubKey" "', argument " "2"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg2 = reinterpret_cast< cipher__BitcoinAddress * >(argp2);
  SKY_cipher_BitcoinAddressFromPubKey((unsigned char (*)[33])arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddressFromSecKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  cipher__BitcoinAddress *arg2 = (cipher__BitcoinAddress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddressFromSecKey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddressFromSecKey" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinAddressFromSecKey" "', argument " "2"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg2 = reinterpret_cast< cipher__BitcoinAddress * >(argp2);
  result = (GoUint32)SKY_cipher_BitcoinAddressFromSecKey((unsigned char (*)[32])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinWalletImportFormatFromSeckey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinWalletImportFormatFromSeckey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinWalletImportFormatFromSeckey" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinWalletImportFormatFromSeckey" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  SKY_cipher_BitcoinWalletImportFormatFromSeckey((unsigned char (*)[32])arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddressFromBytes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__BitcoinAddress *arg2 = (cipher__BitcoinAddress *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddressFromBytes.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddressFromBytes" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_BitcoinAddressFromBytes" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinAddressFromBytes" "', argument " "2"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg2 = reinterpret_cast< cipher__BitcoinAddress * >(argp2);
  result = (GoUint32)SKY_cipher_BitcoinAddressFromBytes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SecKeyFromBitcoinWalletImportFormat(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  cipher__SecKey *arg2 = (cipher__SecKey *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SecKeyFromBitcoinWalletImportFormat.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SecKeyFromBitcoinWalletImportFormat" "', argument " "2"" of type '" "cipher__SecKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SecKey * >(argp2);
  result = (GoUint32)SKY_cipher_SecKeyFromBitcoinWalletImportFormat(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddress_Null(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint8 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddress_Null.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddress_Null" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
  result = (GoUint8)SKY_cipher_BitcoinAddress_Null(arg1);
  jsresult = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddress_Bytes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddress_Bytes.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddress_Bytes" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinAddress_Bytes" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  SKY_cipher_BitcoinAddress_Bytes(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddress_Verify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
  cipher__PubKey *arg2 = (cipher__PubKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddress_Verify.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddress_Verify" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinAddress_Verify" "', argument " "2"" of type '" "cipher__PubKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__PubKey * >(argp2);
  result = (GoUint32)SKY_cipher_BitcoinAddress_Verify(arg1,(unsigned char (*)[33])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddress_String(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddress_String.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddress_String" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinAddress_String" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  SKY_cipher_BitcoinAddress_String(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_BitcoinAddress_Checksum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
  cipher__Checksum *arg2 = (cipher__Checksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_BitcoinAddress_Checksum.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_BitcoinAddress_Checksum" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
  }
  arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_4__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_BitcoinAddress_Checksum" "', argument " "2"" of type '" "cipher__Checksum *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Checksum * >(argp2);
  SKY_cipher_BitcoinAddress_Checksum(arg1,(unsigned char (*)[4])arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_transaction_ChooseSpendsMaximizeUxOuts(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoUint64 arg2 ;
  GoUint64 arg3 ;
  coin__UxArray *arg4 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_transaction_ChooseSpendsMaximizeUxOuts.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_transaction_ChooseSpendsMaximizeUxOuts" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_transaction_ChooseSpendsMaximizeUxOuts" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_transaction_ChooseSpendsMaximizeUxOuts" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_transaction_ChooseSpendsMaximizeUxOuts" "', argument " "3"" of type '" "GoUint64""'");
  } 
  arg3 = static_cast< GoUint64 >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_transaction_ChooseSpendsMaximizeUxOuts" "', argument " "4"" of type '" "coin__UxArray *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxArray * >(argp4);
  result = (GoUint32)SKY_transaction_ChooseSpendsMaximizeUxOuts(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_transaction_ChooseSpendsMinimizeUxOuts(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoUint64 arg2 ;
  GoUint64 arg3 ;
  coin__UxArray *arg4 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_transaction_ChooseSpendsMinimizeUxOuts.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_transaction_ChooseSpendsMinimizeUxOuts" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_transaction_ChooseSpendsMinimizeUxOuts" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_transaction_ChooseSpendsMinimizeUxOuts" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_transaction_ChooseSpendsMinimizeUxOuts" "', argument " "3"" of type '" "GoUint64""'");
  } 
  arg3 = static_cast< GoUint64 >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_transaction_ChooseSpendsMinimizeUxOuts" "', argument " "4"" of type '" "coin__UxArray *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxArray * >(argp4);
  result = (GoUint32)SKY_transaction_ChooseSpendsMinimizeUxOuts(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_transaction_NewUxBalance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  coin__UxOut *arg2 = (coin__UxOut *) 0 ;
  transaction__UxBalance *arg3 = (transaction__UxBalance *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_transaction_NewUxBalance.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_transaction_NewUxBalance" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_coin__UxOut, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_transaction_NewUxBalance" "', argument " "2"" of type '" "coin__UxOut *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxOut * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_transaction_NewUxBalance" "', argument " "3"" of type '" "transaction__UxBalance *""'"); 
  }
  arg3 = reinterpret_cast< transaction__UxBalance * >(argp3);
  result = (GoUint32)SKY_transaction_NewUxBalance(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_transaction_NewUxBalances(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_transaction_NewUxBalances.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_transaction_NewUxBalances" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_transaction_NewUxBalances" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_transaction_NewUxBalances" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_transaction_NewUxBalances(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_GenerateWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  Options__Handle *arg2 = (Options__Handle *) 0 ;
  GoUint64 arg3 ;
  Wallet__Handle *arg4 = (Wallet__Handle *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_GenerateWallet.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_GenerateWallet" "', argument " "2"" of type '" "Options__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Options__Handle * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_cli_GenerateWallet" "', argument " "3"" of type '" "GoUint64""'");
  } 
  arg3 = static_cast< GoUint64 >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_cli_GenerateWallet" "', argument " "4"" of type '" "Wallet__Handle *""'"); 
  }
  arg4 = reinterpret_cast< Wallet__Handle * >(argp4);
  result = (GoUint32)SKY_cli_GenerateWallet(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_MakeAlphanumericSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString_ *arg1 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_MakeAlphanumericSeed.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_MakeAlphanumericSeed" "', argument " "1"" of type '" "GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< GoString_ * >(argp1);
  result = (GoUint32)SKY_cli_MakeAlphanumericSeed(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_testutil_MakeAddress(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_testutil_MakeAddress.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_testutil_MakeAddress" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  result = (GoUint32)SKY_testutil_MakeAddress(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_LoadConfig(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Config__Handle *arg1 = (Config__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_LoadConfig.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_LoadConfig" "', argument " "1"" of type '" "Config__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Config__Handle * >(argp1);
  result = (GoUint32)SKY_cli_LoadConfig(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_Config_FullWalletPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Config__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_Config_FullWalletPath.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cli_Config_FullWalletPath" "', argument " "1"" of type '" "Config__Handle""'");
  } 
  arg1 = static_cast< Config__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_Config_FullWalletPath" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cli_Config_FullWalletPath(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_Config_FullDBPath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Config__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_Config_FullDBPath.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cli_Config_FullDBPath" "', argument " "1"" of type '" "Config__Handle""'");
  } 
  arg1 = static_cast< Config__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_Config_FullDBPath" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cli_Config_FullDBPath(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_NewCLI(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Config__Handle arg1 ;
  CLI__Handle *arg2 = (CLI__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_NewCLI.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cli_NewCLI" "', argument " "1"" of type '" "Config__Handle""'");
  } 
  arg1 = static_cast< Config__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_NewCLI" "', argument " "2"" of type '" "CLI__Handle *""'"); 
  }
  arg2 = reinterpret_cast< CLI__Handle * >(argp2);
  result = (GoUint32)SKY_cli_NewCLI(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_NewPasswordReader(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  PasswordReader__Handle *arg2 = (PasswordReader__Handle *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_NewPasswordReader.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_NewPasswordReader" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cli_NewPasswordReader" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_NewPasswordReader" "', argument " "2"" of type '" "PasswordReader__Handle *""'"); 
  }
  arg2 = reinterpret_cast< PasswordReader__Handle * >(argp2);
  SKY_cli_NewPasswordReader(arg1,arg2);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_PasswordFromBytes_Password(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_PasswordFromBytes_Password.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_PasswordFromBytes_Password" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_PasswordFromBytes_Password" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_cli_PasswordFromBytes_Password(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_PasswordFromTerm_Password(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_PasswordFromTerm_Password.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_PasswordFromTerm_Password" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  result = (GoUint32)SKY_cli_PasswordFromTerm_Password(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_apputil_CatchInterruptPanic(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_apputil_CatchInterruptPanic.");
  
  result = (GoUint32)SKY_apputil_CatchInterruptPanic();
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_apputil_CatchDebug(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_apputil_CatchDebug.");
  
  result = (GoUint32)SKY_apputil_CatchDebug();
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_apputil_PrintProgramStatus(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_apputil_PrintProgramStatus.");
  
  result = (GoUint32)SKY_apputil_PrintProgramStatus();
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_RandByte(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoInt arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_RandByte.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_cipher_RandByte" "', argument " "1"" of type '" "GoInt""'");
  } 
  arg1 = static_cast< GoInt >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_RandByte" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_cipher_RandByte(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_NewPubKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__PubKey *arg2 = (cipher__PubKey *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_NewPubKey.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_NewPubKey" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_NewPubKey" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_NewPubKey" "', argument " "2"" of type '" "cipher__PubKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__PubKey * >(argp2);
  result = (GoUint32)SKY_cipher_NewPubKey(arg1,(unsigned char (*)[33])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_PubKeyFromHex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  cipher__PubKey *arg2 = (cipher__PubKey *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_PubKeyFromHex.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_PubKeyFromHex" "', argument " "2"" of type '" "cipher__PubKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__PubKey * >(argp2);
  result = (GoUint32)SKY_cipher_PubKeyFromHex(arg1,(unsigned char (*)[33])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_PubKeyFromSecKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  cipher__PubKey *arg2 = (cipher__PubKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_PubKeyFromSecKey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_PubKeyFromSecKey" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_PubKeyFromSecKey" "', argument " "2"" of type '" "cipher__PubKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__PubKey * >(argp2);
  result = (GoUint32)SKY_cipher_PubKeyFromSecKey((unsigned char (*)[32])arg1,(unsigned char (*)[33])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_PubKeyFromSig(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Sig *arg1 = (cipher__Sig *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  cipher__PubKey *arg3 = (cipher__PubKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_PubKeyFromSig.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_PubKeyFromSig" "', argument " "1"" of type '" "cipher__Sig *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Sig * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_PubKeyFromSig" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_PubKeyFromSig" "', argument " "3"" of type '" "cipher__PubKey *""'"); 
  }
  arg3 = reinterpret_cast< cipher__PubKey * >(argp3);
  result = (GoUint32)SKY_cipher_PubKeyFromSig((unsigned char (*)[65])arg1,(unsigned char (*)[32])arg2,(unsigned char (*)[33])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_PubKey_Verify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_PubKey_Verify.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_PubKey_Verify" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  result = (GoUint32)SKY_cipher_PubKey_Verify((unsigned char (*)[33])arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_PubKey_Hex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_PubKey_Hex.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_PubKey_Hex" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_PubKey_Hex" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cipher_PubKey_Hex((unsigned char (*)[33])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_PubKeyRipemd160(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  cipher__Ripemd160 *arg2 = (cipher__Ripemd160 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_PubKeyRipemd160.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_PubKeyRipemd160" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_20__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_PubKeyRipemd160" "', argument " "2"" of type '" "cipher__Ripemd160 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Ripemd160 * >(argp2);
  result = (GoUint32)SKY_cipher_PubKeyRipemd160((unsigned char (*)[33])arg1,(unsigned char (*)[20])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_NewSecKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__SecKey *arg2 = (cipher__SecKey *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_NewSecKey.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_NewSecKey" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_NewSecKey" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_NewSecKey" "', argument " "2"" of type '" "cipher__SecKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SecKey * >(argp2);
  result = (GoUint32)SKY_cipher_NewSecKey(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SecKeyFromHex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  cipher__SecKey *arg2 = (cipher__SecKey *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SecKeyFromHex.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SecKeyFromHex" "', argument " "2"" of type '" "cipher__SecKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SecKey * >(argp2);
  result = (GoUint32)SKY_cipher_SecKeyFromHex(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SecKey_Verify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SecKey_Verify.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SecKey_Verify" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  result = (GoUint32)SKY_cipher_SecKey_Verify((unsigned char (*)[32])arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SecKey_Hex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SecKey_Hex.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SecKey_Hex" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SecKey_Hex" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cipher_SecKey_Hex((unsigned char (*)[32])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_ECDH(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  cipher__SecKey *arg2 = (cipher__SecKey *) 0 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_ECDH.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_ECDH" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_ECDH" "', argument " "2"" of type '" "cipher__SecKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SecKey * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_ECDH" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_cipher_ECDH((unsigned char (*)[33])arg1,(unsigned char (*)[32])arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_NewSig(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__Sig *arg2 = (cipher__Sig *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_NewSig.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_NewSig" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_NewSig" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_NewSig" "', argument " "2"" of type '" "cipher__Sig *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Sig * >(argp2);
  result = (GoUint32)SKY_cipher_NewSig(arg1,(unsigned char (*)[65])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SigFromHex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  cipher__Sig *arg2 = (cipher__Sig *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SigFromHex.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SigFromHex" "', argument " "2"" of type '" "cipher__Sig *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Sig * >(argp2);
  result = (GoUint32)SKY_cipher_SigFromHex(arg1,(unsigned char (*)[65])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Sig_Hex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Sig *arg1 = (cipher__Sig *) 0 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Sig_Hex.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Sig_Hex" "', argument " "1"" of type '" "cipher__Sig *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Sig * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Sig_Hex" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cipher_Sig_Hex((unsigned char (*)[65])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SignHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SHA256 *arg1 = (cipher__SHA256 *) 0 ;
  cipher__SecKey *arg2 = (cipher__SecKey *) 0 ;
  cipher__Sig *arg3 = (cipher__Sig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SignHash.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SignHash" "', argument " "1"" of type '" "cipher__SHA256 *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SHA256 * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SignHash" "', argument " "2"" of type '" "cipher__SecKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SecKey * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_SignHash" "', argument " "3"" of type '" "cipher__Sig *""'"); 
  }
  arg3 = reinterpret_cast< cipher__Sig * >(argp3);
  result = (GoUint32)SKY_cipher_SignHash((unsigned char (*)[32])arg1,(unsigned char (*)[32])arg2,(unsigned char (*)[65])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_VerifyAddressSignedHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  cipher__Sig *arg2 = (cipher__Sig *) 0 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_VerifyAddressSignedHash.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_VerifyAddressSignedHash" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_VerifyAddressSignedHash" "', argument " "2"" of type '" "cipher__Sig *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Sig * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_VerifyAddressSignedHash" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_cipher_VerifyAddressSignedHash(arg1,(unsigned char (*)[65])arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_VerifyPubKeySignedHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  cipher__Sig *arg2 = (cipher__Sig *) 0 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_VerifyPubKeySignedHash.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_VerifyPubKeySignedHash" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_VerifyPubKeySignedHash" "', argument " "2"" of type '" "cipher__Sig *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Sig * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_VerifyPubKeySignedHash" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_cipher_VerifyPubKeySignedHash((unsigned char (*)[33])arg1,(unsigned char (*)[65])arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_GenerateKeyPair(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  cipher__SecKey *arg2 = (cipher__SecKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_GenerateKeyPair.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_GenerateKeyPair" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_GenerateKeyPair" "', argument " "2"" of type '" "cipher__SecKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SecKey * >(argp2);
  result = (GoUint32)SKY_cipher_GenerateKeyPair((unsigned char (*)[33])arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_GenerateDeterministicKeyPair(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__PubKey *arg2 = (cipher__PubKey *) 0 ;
  cipher__SecKey *arg3 = (cipher__SecKey *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_GenerateDeterministicKeyPair.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_GenerateDeterministicKeyPair" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_GenerateDeterministicKeyPair" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_GenerateDeterministicKeyPair" "', argument " "2"" of type '" "cipher__PubKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__PubKey * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_GenerateDeterministicKeyPair" "', argument " "3"" of type '" "cipher__SecKey *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SecKey * >(argp3);
  result = (GoUint32)SKY_cipher_GenerateDeterministicKeyPair(arg1,(unsigned char (*)[33])arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_DeterministicKeyPairIterator(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  cipher__PubKey *arg3 = (cipher__PubKey *) 0 ;
  cipher__SecKey *arg4 = (cipher__SecKey *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_DeterministicKeyPairIterator.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_DeterministicKeyPairIterator" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_DeterministicKeyPairIterator" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_DeterministicKeyPairIterator" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_DeterministicKeyPairIterator" "', argument " "3"" of type '" "cipher__PubKey *""'"); 
  }
  arg3 = reinterpret_cast< cipher__PubKey * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_cipher_DeterministicKeyPairIterator" "', argument " "4"" of type '" "cipher__SecKey *""'"); 
  }
  arg4 = reinterpret_cast< cipher__SecKey * >(argp4);
  result = (GoUint32)SKY_cipher_DeterministicKeyPairIterator(arg1,arg2,(unsigned char (*)[33])arg3,(unsigned char (*)[32])arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_GenerateDeterministicKeyPairs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoInt arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_GenerateDeterministicKeyPairs.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_GenerateDeterministicKeyPairs" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_GenerateDeterministicKeyPairs" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_cipher_GenerateDeterministicKeyPairs" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_GenerateDeterministicKeyPairs" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_cipher_GenerateDeterministicKeyPairs(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_GenerateDeterministicKeyPairsSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoInt arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  coin__UxArray *arg4 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_GenerateDeterministicKeyPairsSeed.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_GenerateDeterministicKeyPairsSeed" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_GenerateDeterministicKeyPairsSeed" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_cipher_GenerateDeterministicKeyPairsSeed" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_GenerateDeterministicKeyPairsSeed" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_cipher_GenerateDeterministicKeyPairsSeed" "', argument " "4"" of type '" "coin__UxArray *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxArray * >(argp4);
  result = (GoUint32)SKY_cipher_GenerateDeterministicKeyPairsSeed(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_CheckSecKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_CheckSecKey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_CheckSecKey" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  result = (GoUint32)SKY_cipher_CheckSecKey((unsigned char (*)[32])arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_CheckSecKeyHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_CheckSecKeyHash.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_CheckSecKeyHash" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_CheckSecKeyHash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_cipher_CheckSecKeyHash((unsigned char (*)[32])arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_secp256k1_PubkeyFromSeckey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_secp256k1_PubkeyFromSeckey.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_secp256k1_PubkeyFromSeckey" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_secp256k1_PubkeyFromSeckey" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_secp256k1_PubkeyFromSeckey" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_secp256k1_PubkeyFromSeckey(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_secp256k1_VerifyPubkey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  GoInt result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_secp256k1_VerifyPubkey.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_secp256k1_VerifyPubkey" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_secp256k1_VerifyPubkey" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  result = (GoInt)SKY_secp256k1_VerifyPubkey(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_secp256k1_VerifySecKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  GoInt result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_secp256k1_VerifySecKey.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_secp256k1_VerifySecKey" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_secp256k1_VerifySecKey" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  result = (GoInt)SKY_secp256k1_VerifySecKey(arg1);
  jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_secp256k1_ECDH(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoSlice arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_secp256k1_ECDH.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_secp256k1_ECDH" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_secp256k1_ECDH" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_secp256k1_ECDH" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_secp256k1_ECDH" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_secp256k1_ECDH" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_secp256k1_ECDH(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_file_InitDataDir(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_file_InitDataDir.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_file_InitDataDir" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_file_InitDataDir(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_file_UserHome(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString_ *arg1 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_file_UserHome.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_file_UserHome" "', argument " "1"" of type '" "GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< GoString_ * >(argp1);
  result = (GoUint32)SKY_file_UserHome(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_file_ResolveResourceDirectory(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_file_ResolveResourceDirectory.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_file_ResolveResourceDirectory" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_file_ResolveResourceDirectory(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_file_DetermineResourcePath(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  GoString_ *arg4 = (GoString_ *) 0 ;
  GoString temp1 ;
  GoString temp2 ;
  GoString temp3 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_file_DetermineResourcePath.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_file_DetermineResourcePath" "', argument " "4"" of type '" "GoString_ *""'"); 
  }
  arg4 = reinterpret_cast< GoString_ * >(argp4);
  result = (GoUint32)SKY_file_DetermineResourcePath(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_NewWalletResponse(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  WalletResponse__Handle *arg2 = (WalletResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_NewWalletResponse.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_NewWalletResponse" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_NewWalletResponse" "', argument " "2"" of type '" "WalletResponse__Handle *""'"); 
  }
  arg2 = reinterpret_cast< WalletResponse__Handle * >(argp2);
  result = (GoUint32)SKY_api_NewWalletResponse(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_map_Get(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoStringMap_ *arg1 = (GoStringMap_ *) 0 ;
  GoString arg2 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_map_Get.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_map_Get" "', argument " "1"" of type '" "GoStringMap_ *""'"); 
  }
  arg1 = reinterpret_cast< GoStringMap_ * >(argp1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_map_Get" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  result = (GoUint32)SKY_map_Get(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_map_HasKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoStringMap_ *arg1 = (GoStringMap_ *) 0 ;
  GoString arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoString temp2 ;
  GoUint8 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_map_HasKey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_map_HasKey" "', argument " "1"" of type '" "GoStringMap_ *""'"); 
  }
  arg1 = reinterpret_cast< GoStringMap_ * >(argp1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  result = (GoUint8)SKY_map_HasKey(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_map_Close(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoStringMap_ *arg1 = (GoStringMap_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_map_Close.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_map_Close" "', argument " "1"" of type '" "GoStringMap_ *""'"); 
  }
  arg1 = reinterpret_cast< GoStringMap_ * >(argp1);
  result = (GoUint32)SKY_map_Close(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_NewBlock(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  GoUint64 arg2 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  Transactions__Handle arg4 ;
  FeeCalculator *arg5 = (FeeCalculator *) 0 ;
  Block__Handle *arg6 = (Block__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_NewBlock.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_NewBlock" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_NewBlock" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_NewBlock" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  ecode4 = SWIG_AsVal_long_SS_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SKY_coin_NewBlock" "', argument " "4"" of type '" "Transactions__Handle""'");
  } 
  arg4 = static_cast< Transactions__Handle >(val4);
  res5 = SWIG_ConvertPtr(args[4], &argp5,SWIGTYPE_p_FeeCalculator, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SKY_coin_NewBlock" "', argument " "5"" of type '" "FeeCalculator *""'"); 
  }
  arg5 = reinterpret_cast< FeeCalculator * >(argp5);
  res6 = SWIG_ConvertPtr(args[5], &argp6,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SKY_coin_NewBlock" "', argument " "6"" of type '" "Block__Handle *""'"); 
  }
  arg6 = reinterpret_cast< Block__Handle * >(argp6);
  result = (GoUint32)SKY_coin_NewBlock(arg1,arg2,(unsigned char (*)[32])arg3,arg4,arg5,arg6);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_SignedBlock_VerifySignature(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__SignedBlock *arg1 = (coin__SignedBlock *) 0 ;
  cipher__PubKey *arg2 = (cipher__PubKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_SignedBlock_VerifySignature.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__SignedBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_SignedBlock_VerifySignature" "', argument " "1"" of type '" "coin__SignedBlock *""'"); 
  }
  arg1 = reinterpret_cast< coin__SignedBlock * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_SignedBlock_VerifySignature" "', argument " "2"" of type '" "cipher__PubKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__PubKey * >(argp2);
  result = (GoUint32)SKY_coin_SignedBlock_VerifySignature(arg1,(unsigned char (*)[33])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_NewGenesisBlock(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  GoUint64 arg2 ;
  GoUint64 arg3 ;
  Block__Handle *arg4 = (Block__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_NewGenesisBlock.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_NewGenesisBlock" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_NewGenesisBlock" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_NewGenesisBlock" "', argument " "3"" of type '" "GoUint64""'");
  } 
  arg3 = static_cast< GoUint64 >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_coin_NewGenesisBlock" "', argument " "4"" of type '" "Block__Handle *""'"); 
  }
  arg4 = reinterpret_cast< Block__Handle * >(argp4);
  result = (GoUint32)SKY_coin_NewGenesisBlock(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Block_HashHeader(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Block_HashHeader.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Block_HashHeader" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Block_HashHeader" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_Block_HashHeader(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Block_Time(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Block_Time.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Block_Time" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Block_Time" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_coin_Block_Time(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Block_Seq(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Block_Seq.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Block_Seq" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Block_Seq" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_coin_Block_Seq(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Block_HashBody(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Block_HashBody.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Block_HashBody" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Block_HashBody" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_Block_HashBody(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Block_Size(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Block_Size.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Block_Size" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Block_Size" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_coin_Block_Size(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_NewBlockHeader(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  GoUint64 arg3 ;
  GoUint64 arg4 ;
  BlockBody__Handle arg5 ;
  coin__BlockHeader *arg6 = (coin__BlockHeader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  unsigned long long val4 ;
  int ecode4 = 0 ;
  long long val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_NewBlockHeader.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_NewBlockHeader" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
  }
  arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_NewBlockHeader" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_NewBlockHeader" "', argument " "3"" of type '" "GoUint64""'");
  } 
  arg3 = static_cast< GoUint64 >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_long_SS_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SKY_coin_NewBlockHeader" "', argument " "4"" of type '" "GoUint64""'");
  } 
  arg4 = static_cast< GoUint64 >(val4);
  ecode5 = SWIG_AsVal_long_SS_long(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SKY_coin_NewBlockHeader" "', argument " "5"" of type '" "BlockBody__Handle""'");
  } 
  arg5 = static_cast< BlockBody__Handle >(val5);
  res6 = SWIG_ConvertPtr(args[5], &argp6,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SKY_coin_NewBlockHeader" "', argument " "6"" of type '" "coin__BlockHeader *""'"); 
  }
  arg6 = reinterpret_cast< coin__BlockHeader * >(argp6);
  result = (GoUint32)SKY_coin_NewBlockHeader(arg1,(unsigned char (*)[32])arg2,arg3,arg4,arg5,arg6);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_Hash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_Hash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_Hash" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_Hash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_Hash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_Bytes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_Bytes.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_BlockHeader_Bytes" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
  }
  arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_Bytes" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_Bytes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockBody_Hash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockBody_Hash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockBody_Hash" "', argument " "1"" of type '" "BlockBody__Handle""'");
  } 
  arg1 = static_cast< BlockBody__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockBody_Hash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_BlockBody_Hash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockBody_Size(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle *arg1 = (BlockBody__Handle *) 0 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockBody_Size.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_BlockBody_Size" "', argument " "1"" of type '" "BlockBody__Handle *""'"); 
  }
  arg1 = reinterpret_cast< BlockBody__Handle * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockBody_Size" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_coin_BlockBody_Size(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockBody_Bytes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockBody_Bytes.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockBody_Bytes" "', argument " "1"" of type '" "BlockBody__Handle""'");
  } 
  arg1 = static_cast< BlockBody__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockBody_Bytes" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_BlockBody_Bytes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_CreateUnspents(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
  Transaction__Handle arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_CreateUnspents.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_CreateUnspents" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
  }
  arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_CreateUnspents" "', argument " "2"" of type '" "Transaction__Handle""'");
  } 
  arg2 = static_cast< Transaction__Handle >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_CreateUnspents" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_coin_CreateUnspents(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_CreateUnspent(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
  Transaction__Handle arg2 ;
  GoInt arg3 ;
  coin__UxOut *arg4 = (coin__UxOut *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_CreateUnspent.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_CreateUnspent" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
  }
  arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_CreateUnspent" "', argument " "2"" of type '" "Transaction__Handle""'");
  } 
  arg2 = static_cast< Transaction__Handle >(val2);
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_CreateUnspent" "', argument " "3"" of type '" "GoInt""'");
  } 
  arg3 = static_cast< GoInt >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_coin__UxOut, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_coin_CreateUnspent" "', argument " "4"" of type '" "coin__UxOut *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxOut * >(argp4);
  result = (GoUint32)SKY_coin_CreateUnspent(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_GetBlockObject(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  coin__Block **arg2 = (coin__Block **) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_GetBlockObject.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_GetBlockObject" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_p_coin__Block, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_GetBlockObject" "', argument " "2"" of type '" "coin__Block **""'"); 
  }
  arg2 = reinterpret_cast< coin__Block ** >(argp2);
  result = (GoUint32)SKY_coin_GetBlockObject(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_GetBlockBody(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  BlockBody__Handle *arg2 = (BlockBody__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_GetBlockBody.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_GetBlockBody" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_GetBlockBody" "', argument " "2"" of type '" "BlockBody__Handle *""'"); 
  }
  arg2 = reinterpret_cast< BlockBody__Handle * >(argp2);
  result = (GoUint32)SKY_coin_GetBlockBody(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_NewEmptyBlock(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  Block__Handle *arg2 = (Block__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_NewEmptyBlock.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_NewEmptyBlock" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_NewEmptyBlock" "', argument " "2"" of type '" "Block__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Block__Handle * >(argp2);
  result = (GoUint32)SKY_coin_NewEmptyBlock(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Block_GetBlockHeader(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Block__Handle arg1 ;
  BlockHeader__Handle *arg2 = (BlockHeader__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Block_GetBlockHeader.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Block_GetBlockHeader" "', argument " "1"" of type '" "Block__Handle""'");
  } 
  arg1 = static_cast< Block__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Block_GetBlockHeader" "', argument " "2"" of type '" "BlockHeader__Handle *""'"); 
  }
  arg2 = reinterpret_cast< BlockHeader__Handle * >(argp2);
  result = (GoUint32)SKY_coin_Block_GetBlockHeader(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_GetBlockHeaderObject(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  coin__BlockHeader **arg2 = (coin__BlockHeader **) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_GetBlockHeaderObject.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_GetBlockHeaderObject" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_p_coin__BlockHeader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_GetBlockHeaderObject" "', argument " "2"" of type '" "coin__BlockHeader **""'"); 
  }
  arg2 = reinterpret_cast< coin__BlockHeader ** >(argp2);
  result = (GoUint32)SKY_coin_GetBlockHeaderObject(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_Time(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_Time.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_Time" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_Time" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_Time(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_BkSeq(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_BkSeq.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_BkSeq" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_BkSeq" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_BkSeq(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_UxHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_UxHash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_UxHash" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_UxHash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_UxHash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_Fee(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_Fee.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_Fee" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_Fee" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_Fee(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockBody_Transactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockBody__Handle arg1 ;
  Transactions__Handle *arg2 = (Transactions__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockBody_Transactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockBody_Transactions" "', argument " "1"" of type '" "BlockBody__Handle""'");
  } 
  arg1 = static_cast< BlockBody__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockBody_Transactions" "', argument " "2"" of type '" "Transactions__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Transactions__Handle * >(argp2);
  result = (GoUint32)SKY_coin_BlockBody_Transactions(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_SetTime(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint64 arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_SetTime.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_SetTime" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_BlockHeader_SetTime" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  result = (GoUint32)SKY_coin_BlockHeader_SetTime(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_SetBkSeq(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint64 arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_SetBkSeq.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_SetBkSeq" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_BlockHeader_SetBkSeq" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  result = (GoUint32)SKY_coin_BlockHeader_SetBkSeq(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_SetFee(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint64 arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_SetFee.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_SetFee" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_BlockHeader_SetFee" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  result = (GoUint32)SKY_coin_BlockHeader_SetFee(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_SetVersion(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint32 arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_SetVersion.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_SetVersion" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_BlockHeader_SetVersion" "', argument " "2"" of type '" "GoUint32""'");
  } 
  arg2 = static_cast< GoUint32 >(val2);
  result = (GoUint32)SKY_coin_BlockHeader_SetVersion(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_Version(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_Version.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_Version" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_Version" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_Version(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_BlockHeader_PrevHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  BlockHeader__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_BlockHeader_PrevHash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_BlockHeader_PrevHash" "', argument " "1"" of type '" "BlockHeader__Handle""'");
  } 
  arg1 = static_cast< BlockHeader__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_BlockHeader_PrevHash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_BlockHeader_PrevHash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_droplet_FromString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_droplet_FromString.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_droplet_FromString" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_droplet_FromString(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_droplet_ToString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_droplet_ToString.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_droplet_ToString" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_droplet_ToString" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_droplet_ToString(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_CryptoTypeFromString(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_CryptoTypeFromString.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_CryptoTypeFromString" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_wallet_CryptoTypeFromString(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_DecodeBase58Address(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_DecodeBase58Address.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_DecodeBase58Address" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  result = (GoUint32)SKY_cipher_DecodeBase58Address(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_AddressFromBytes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_AddressFromBytes.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_AddressFromBytes" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_AddressFromBytes" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_AddressFromBytes" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  result = (GoUint32)SKY_cipher_AddressFromBytes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_AddressFromPubKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__PubKey *arg1 = (cipher__PubKey *) 0 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_AddressFromPubKey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_AddressFromPubKey" "', argument " "1"" of type '" "cipher__PubKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__PubKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_AddressFromPubKey" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  result = (GoUint32)SKY_cipher_AddressFromPubKey((unsigned char (*)[33])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_AddressFromSecKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SecKey *arg1 = (cipher__SecKey *) 0 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_AddressFromSecKey.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_AddressFromSecKey" "', argument " "1"" of type '" "cipher__SecKey *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SecKey * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_AddressFromSecKey" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  result = (GoUint32)SKY_cipher_AddressFromSecKey((unsigned char (*)[32])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Address_Null(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  GoUint8 *arg2 = (GoUint8 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Address_Null.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Address_Null" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Address_Null" "', argument " "2"" of type '" "GoUint8 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint8 * >(argp2);
  result = (GoUint32)SKY_cipher_Address_Null(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Address_Bytes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Address_Bytes.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Address_Bytes" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Address_Bytes" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_cipher_Address_Bytes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Address_Verify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  cipher__PubKey *arg2 = (cipher__PubKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Address_Verify.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Address_Verify" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_33__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Address_Verify" "', argument " "2"" of type '" "cipher__PubKey *""'"); 
  }
  arg2 = reinterpret_cast< cipher__PubKey * >(argp2);
  result = (GoUint32)SKY_cipher_Address_Verify(arg1,(unsigned char (*)[33])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Address_String(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Address_String.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Address_String" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Address_String" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cipher_Address_String(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Address_Checksum(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Address *arg1 = (cipher__Address *) 0 ;
  cipher__Checksum *arg2 = (cipher__Checksum *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Address_Checksum.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Address_Checksum" "', argument " "1"" of type '" "cipher__Address *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Address * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_4__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Address_Checksum" "', argument " "2"" of type '" "cipher__Checksum *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Checksum * >(argp2);
  result = (GoUint32)SKY_cipher_Address_Checksum(arg1,(unsigned char (*)[4])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Ripemd160_Set(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__Ripemd160 *arg1 = (cipher__Ripemd160 *) 0 ;
  GoSlice arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Ripemd160_Set.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_20__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Ripemd160_Set" "', argument " "1"" of type '" "cipher__Ripemd160 *""'"); 
  }
  arg1 = reinterpret_cast< cipher__Ripemd160 * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Ripemd160_Set" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_Ripemd160_Set" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  result = (GoUint32)SKY_cipher_Ripemd160_Set((unsigned char (*)[20])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_HashRipemd160(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__Ripemd160 *arg2 = (cipher__Ripemd160 *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_HashRipemd160.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_HashRipemd160" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_HashRipemd160" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_20__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_HashRipemd160" "', argument " "2"" of type '" "cipher__Ripemd160 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Ripemd160 * >(argp2);
  result = (GoUint32)SKY_cipher_HashRipemd160(arg1,(unsigned char (*)[20])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SHA256_Set(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SHA256 *arg1 = (cipher__SHA256 *) 0 ;
  GoSlice arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SHA256_Set.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SHA256_Set" "', argument " "1"" of type '" "cipher__SHA256 *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SHA256 * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SHA256_Set" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_SHA256_Set" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  result = (GoUint32)SKY_cipher_SHA256_Set((unsigned char (*)[32])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SHA256_Hex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SHA256 *arg1 = (cipher__SHA256 *) 0 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SHA256_Hex.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SHA256_Hex" "', argument " "1"" of type '" "cipher__SHA256 *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SHA256 * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SHA256_Hex" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cipher_SHA256_Hex((unsigned char (*)[32])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SHA256_Xor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SHA256 *arg1 = (cipher__SHA256 *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SHA256_Xor.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SHA256_Xor" "', argument " "1"" of type '" "cipher__SHA256 *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SHA256 * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SHA256_Xor" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_SHA256_Xor" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_cipher_SHA256_Xor((unsigned char (*)[32])arg1,(unsigned char (*)[32])arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SumSHA256(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SumSHA256.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SumSHA256" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_SumSHA256" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SumSHA256" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_cipher_SumSHA256(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SHA256FromHex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SHA256FromHex.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SHA256FromHex" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_cipher_SHA256FromHex(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_DoubleSHA256(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_DoubleSHA256.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_DoubleSHA256" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cipher_DoubleSHA256" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_DoubleSHA256" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_cipher_DoubleSHA256(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_AddSHA256(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SHA256 *arg1 = (cipher__SHA256 *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_AddSHA256.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_AddSHA256" "', argument " "1"" of type '" "cipher__SHA256 *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SHA256 * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_AddSHA256" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cipher_AddSHA256" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_cipher_AddSHA256((unsigned char (*)[32])arg1,(unsigned char (*)[32])arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_Merkle(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice *arg1 = (GoSlice *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_Merkle.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_Merkle" "', argument " "1"" of type '" "GoSlice *""'"); 
  }
  arg1 = reinterpret_cast< GoSlice * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_Merkle" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_cipher_Merkle(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cipher_SHA256_Null(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  cipher__SHA256 *arg1 = (cipher__SHA256 *) 0 ;
  GoUint8 *arg2 = (GoUint8 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cipher_SHA256_Null.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cipher_SHA256_Null" "', argument " "1"" of type '" "cipher__SHA256 *""'"); 
  }
  arg1 = reinterpret_cast< cipher__SHA256 * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cipher_SHA256_Null" "', argument " "2"" of type '" "GoUint8 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint8 * >(argp2);
  result = (GoUint32)SKY_cipher_SHA256_Null((unsigned char (*)[32])arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_NewError(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoInterface arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_NewError.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoInterface,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_wallet_NewError" "', argument " "1"" of type '" "GoInterface""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_wallet_NewError" "', argument " "1"" of type '" "GoInterface""'");
    } else {
      arg1 = *(reinterpret_cast< GoInterface * >(argp1));
    }
  }
  result = (GoUint32)SKY_wallet_NewError(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_NewWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  Options__Handle arg2 ;
  Wallet__Handle *arg3 = (Wallet__Handle *) 0 ;
  GoString temp1 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_NewWallet.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_wallet_NewWallet" "', argument " "2"" of type '" "Options__Handle""'");
  } 
  arg2 = static_cast< Options__Handle >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_NewWallet" "', argument " "3"" of type '" "Wallet__Handle *""'"); 
  }
  arg3 = reinterpret_cast< Wallet__Handle * >(argp3);
  result = (GoUint32)SKY_wallet_NewWallet(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Lock(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoSlice arg2 ;
  GoString arg3 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  GoString temp3 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Lock.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Lock" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_Lock" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_wallet_Wallet_Lock" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  result = (GoUint32)SKY_wallet_Wallet_Lock(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Unlock(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoSlice arg2 ;
  Wallet__Handle *arg3 = (Wallet__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Unlock.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Unlock" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_Unlock" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_wallet_Wallet_Unlock" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_Wallet_Unlock" "', argument " "3"" of type '" "Wallet__Handle *""'"); 
  }
  arg3 = reinterpret_cast< Wallet__Handle * >(argp3);
  result = (GoUint32)SKY_wallet_Wallet_Unlock(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Load(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  Wallet__Handle *arg2 = (Wallet__Handle *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Load.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Load" "', argument " "2"" of type '" "Wallet__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Wallet__Handle * >(argp2);
  result = (GoUint32)SKY_wallet_Load(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Save(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Save.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Save" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  result = (GoUint32)SKY_wallet_Wallet_Save(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Validate(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Validate.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Validate" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  result = (GoUint32)SKY_wallet_Wallet_Validate(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Type(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Type.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Type" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_Type" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_wallet_Wallet_Type(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Version(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Version.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Version" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_Version" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_wallet_Wallet_Version(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Filename(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Filename.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Filename" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_Filename" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_wallet_Wallet_Filename(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_Label(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_Label.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_Label" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_Label" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_wallet_Wallet_Label(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_IsEncrypted(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoUint8 *arg2 = (GoUint8 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_IsEncrypted.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_IsEncrypted" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_IsEncrypted" "', argument " "2"" of type '" "GoUint8 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint8 * >(argp2);
  result = (GoUint32)SKY_wallet_Wallet_IsEncrypted(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_GenerateAddresses(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  GoUint64 arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_GenerateAddresses.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_GenerateAddresses" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_wallet_Wallet_GenerateAddresses" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_Wallet_GenerateAddresses" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_wallet_Wallet_GenerateAddresses(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_GetAddresses(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_GetAddresses.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_GetAddresses" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_GetAddresses" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_wallet_Wallet_GetAddresses(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_GetEntry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  wallet__Entry *arg3 = (wallet__Entry *) 0 ;
  GoUint8 *arg4 = (GoUint8 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_GetEntry.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_GetEntry" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_GetEntry" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_wallet__Entry, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_Wallet_GetEntry" "', argument " "3"" of type '" "wallet__Entry *""'"); 
  }
  arg3 = reinterpret_cast< wallet__Entry * >(argp3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_wallet_Wallet_GetEntry" "', argument " "4"" of type '" "GoUint8 *""'"); 
  }
  arg4 = reinterpret_cast< GoUint8 * >(argp4);
  result = (GoUint32)SKY_wallet_Wallet_GetEntry(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_Wallet_AddEntry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Wallet__Handle arg1 ;
  wallet__Entry *arg2 = (wallet__Entry *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_Wallet_AddEntry.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_Wallet_AddEntry" "', argument " "1"" of type '" "Wallet__Handle""'");
  } 
  arg1 = static_cast< Wallet__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_wallet__Entry, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_Wallet_AddEntry" "', argument " "2"" of type '" "wallet__Entry *""'"); 
  }
  arg2 = reinterpret_cast< wallet__Entry * >(argp2);
  result = (GoUint32)SKY_wallet_Wallet_AddEntry(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_NewCreateTransactionResponse(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoSlice arg2 ;
  CreateTransactionResponse__Handle *arg3 = (CreateTransactionResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_NewCreateTransactionResponse.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_NewCreateTransactionResponse" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_NewCreateTransactionResponse" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_NewCreateTransactionResponse" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_NewCreateTransactionResponse" "', argument " "3"" of type '" "CreateTransactionResponse__Handle *""'"); 
  }
  arg3 = reinterpret_cast< CreateTransactionResponse__Handle * >(argp3);
  result = (GoUint32)SKY_api_NewCreateTransactionResponse(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_NewCreatedTransaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoSlice arg2 ;
  CreatedTransaction__Handle *arg3 = (CreatedTransaction__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_NewCreatedTransaction.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_NewCreatedTransaction" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_NewCreatedTransaction" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_NewCreatedTransaction" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_NewCreatedTransaction" "', argument " "3"" of type '" "CreatedTransaction__Handle *""'"); 
  }
  arg3 = reinterpret_cast< CreatedTransaction__Handle * >(argp3);
  result = (GoUint32)SKY_api_NewCreatedTransaction(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_CreatedTransaction_ToTransaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  CreatedTransaction__Handle arg1 ;
  Transaction__Handle *arg2 = (Transaction__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_CreatedTransaction_ToTransaction.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_CreatedTransaction_ToTransaction" "', argument " "1"" of type '" "CreatedTransaction__Handle""'");
  } 
  arg1 = static_cast< CreatedTransaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_CreatedTransaction_ToTransaction" "', argument " "2"" of type '" "Transaction__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Transaction__Handle * >(argp2);
  result = (GoUint32)SKY_api_CreatedTransaction_ToTransaction(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_NewCreatedTransactionOutput(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  CreatedTransactionOutput__Handle *arg3 = (CreatedTransactionOutput__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_NewCreatedTransactionOutput.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_api_NewCreatedTransactionOutput" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
  }
  arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_NewCreatedTransactionOutput" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_NewCreatedTransactionOutput" "', argument " "3"" of type '" "CreatedTransactionOutput__Handle *""'"); 
  }
  arg3 = reinterpret_cast< CreatedTransactionOutput__Handle * >(argp3);
  result = (GoUint32)SKY_api_NewCreatedTransactionOutput(arg1,(unsigned char (*)[32])arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_NewCreatedTransactionInput(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  api__TransactionInput *arg1 = (api__TransactionInput *) 0 ;
  CreatedTransactionInput__Handle *arg2 = (CreatedTransactionInput__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_NewCreatedTransactionInput.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_api__TransactionInput, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_api_NewCreatedTransactionInput" "', argument " "1"" of type '" "api__TransactionInput *""'"); 
  }
  arg1 = reinterpret_cast< api__TransactionInput * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_NewCreatedTransactionInput" "', argument " "2"" of type '" "CreatedTransactionInput__Handle *""'"); 
  }
  arg2 = reinterpret_cast< CreatedTransactionInput__Handle * >(argp2);
  result = (GoUint32)SKY_api_NewCreatedTransactionInput(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_NewReadableEntry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  wallet__Entry *arg2 = (wallet__Entry *) 0 ;
  ReadableEntry__Handle *arg3 = (ReadableEntry__Handle *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_NewReadableEntry.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_wallet__Entry, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_NewReadableEntry" "', argument " "2"" of type '" "wallet__Entry *""'"); 
  }
  arg2 = reinterpret_cast< wallet__Entry * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_wallet_NewReadableEntry" "', argument " "3"" of type '" "ReadableEntry__Handle *""'"); 
  }
  arg3 = reinterpret_cast< ReadableEntry__Handle * >(argp3);
  result = (GoUint32)SKY_wallet_NewReadableEntry(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_LoadReadableWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  ReadableWallet__Handle *arg2 = (ReadableWallet__Handle *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_LoadReadableWallet.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_wallet_LoadReadableWallet" "', argument " "2"" of type '" "ReadableWallet__Handle *""'"); 
  }
  arg2 = reinterpret_cast< ReadableWallet__Handle * >(argp2);
  result = (GoUint32)SKY_wallet_LoadReadableWallet(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_ReadableWallet_Save(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  ReadableWallet__Handle arg1 ;
  GoString arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_ReadableWallet_Save.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_ReadableWallet_Save" "', argument " "1"" of type '" "ReadableWallet__Handle""'");
  } 
  arg1 = static_cast< ReadableWallet__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  result = (GoUint32)SKY_wallet_ReadableWallet_Save(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_ReadableWallet_Load(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  ReadableWallet__Handle arg1 ;
  GoString arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_ReadableWallet_Load.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_ReadableWallet_Load" "', argument " "1"" of type '" "ReadableWallet__Handle""'");
  } 
  arg1 = static_cast< ReadableWallet__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  result = (GoUint32)SKY_wallet_ReadableWallet_Load(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_wallet_ReadableWallet_Erase(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  ReadableWallet__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_wallet_ReadableWallet_Erase.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_wallet_ReadableWallet_Erase" "', argument " "1"" of type '" "ReadableWallet__Handle""'");
  } 
  arg1 = static_cast< ReadableWallet__Handle >(val1);
  result = (GoUint32)SKY_wallet_ReadableWallet_Erase(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_encrypt_ScryptChacha20poly1305_Encrypt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
  GoSlice arg2 ;
  GoSlice arg3 ;
  coin__UxArray *arg4 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_encrypt_ScryptChacha20poly1305_Encrypt.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Encrypt" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
  }
  arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Encrypt" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_encrypt_ScryptChacha20poly1305_Encrypt" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Encrypt" "', argument " "3"" of type '" "GoSlice""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_encrypt_ScryptChacha20poly1305_Encrypt" "', argument " "3"" of type '" "GoSlice""'");
    } else {
      arg3 = *(reinterpret_cast< GoSlice * >(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Encrypt" "', argument " "4"" of type '" "coin__UxArray *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxArray * >(argp4);
  result = (GoUint32)SKY_encrypt_ScryptChacha20poly1305_Encrypt(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_encrypt_ScryptChacha20poly1305_Decrypt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
  GoSlice arg2 ;
  GoSlice arg3 ;
  coin__UxArray *arg4 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_encrypt_ScryptChacha20poly1305_Decrypt.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Decrypt" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
  }
  arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Decrypt" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_encrypt_ScryptChacha20poly1305_Decrypt" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Decrypt" "', argument " "3"" of type '" "GoSlice""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_encrypt_ScryptChacha20poly1305_Decrypt" "', argument " "3"" of type '" "GoSlice""'");
    } else {
      arg3 = *(reinterpret_cast< GoSlice * >(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_encrypt_ScryptChacha20poly1305_Decrypt" "', argument " "4"" of type '" "coin__UxArray *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxArray * >(argp4);
  result = (GoUint32)SKY_encrypt_ScryptChacha20poly1305_Decrypt(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_GenerateAddressesInFile(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoUint64 arg2 ;
  PasswordReader__Handle arg3 ;
  coin__UxArray *arg4 = (coin__UxArray *) 0 ;
  GoString temp1 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_GenerateAddressesInFile.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_cli_GenerateAddressesInFile" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_cli_GenerateAddressesInFile" "', argument " "3"" of type '" "PasswordReader__Handle""'");
  } 
  arg3 = static_cast< PasswordReader__Handle >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_cli_GenerateAddressesInFile" "', argument " "4"" of type '" "coin__UxArray *""'"); 
  }
  arg4 = reinterpret_cast< coin__UxArray * >(argp4);
  result = (GoUint32)SKY_cli_GenerateAddressesInFile(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_FormatAddressesAsJSON(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_FormatAddressesAsJSON.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_FormatAddressesAsJSON" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cli_FormatAddressesAsJSON" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_FormatAddressesAsJSON" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cli_FormatAddressesAsJSON(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_FormatAddressesAsJoinedArray(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_FormatAddressesAsJoinedArray.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_FormatAddressesAsJoinedArray" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cli_FormatAddressesAsJoinedArray" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_FormatAddressesAsJoinedArray" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_cli_FormatAddressesAsJoinedArray(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_AddressesToStrings(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_AddressesToStrings.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_AddressesToStrings" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cli_AddressesToStrings" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_AddressesToStrings" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_cli_AddressesToStrings(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_handle_close(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_handle_close.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_handle_close" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  SKY_handle_close(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_handle_copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_handle_copy.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_handle_copy" "', argument " "1"" of type '" "Handle""'");
  } 
  arg1 = static_cast< Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_handle_copy" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_handle_copy(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_iputil_LocalhostIP(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString_ *arg1 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_iputil_LocalhostIP.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_iputil_LocalhostIP" "', argument " "1"" of type '" "GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< GoString_ * >(argp1);
  result = (GoUint32)SKY_iputil_LocalhostIP(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_iputil_IsLocalhost(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoUint8 *arg2 = (GoUint8 *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_iputil_IsLocalhost.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_iputil_IsLocalhost" "', argument " "2"" of type '" "GoUint8 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint8 * >(argp2);
  result = (GoUint32)SKY_iputil_IsLocalhost(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_iputil_SplitAddr(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  GoUint16 *arg3 = (GoUint16 *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_iputil_SplitAddr.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_iputil_SplitAddr" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_short, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_iputil_SplitAddr" "', argument " "3"" of type '" "GoUint16 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint16 * >(argp3);
  result = (GoUint32)SKY_iputil_SplitAddr(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_cli_NewTransaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoSlice arg2 ;
  GoSlice arg3 ;
  Transaction__Handle *arg4 = (Transaction__Handle *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_cli_NewTransaction.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_cli_NewTransaction" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cli_NewTransaction" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_cli_NewTransaction" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cli_NewTransaction" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(args[2], &argp3, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_cli_NewTransaction" "', argument " "3"" of type '" "GoSlice""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_cli_NewTransaction" "', argument " "3"" of type '" "GoSlice""'");
    } else {
      arg3 = *(reinterpret_cast< GoSlice * >(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_cli_NewTransaction" "', argument " "4"" of type '" "Transaction__Handle *""'"); 
  }
  arg4 = reinterpret_cast< Transaction__Handle * >(argp4);
  result = (GoUint32)SKY_cli_NewTransaction(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_transaction_DistributeCoinHoursProportional(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoUint64 arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_transaction_DistributeCoinHoursProportional.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_transaction_DistributeCoinHoursProportional" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_transaction_DistributeCoinHoursProportional" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_transaction_DistributeCoinHoursProportional" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_transaction_DistributeCoinHoursProportional" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_transaction_DistributeCoinHoursProportional(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_transaction_DistributeSpendHours(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  GoUint64 arg2 ;
  GoUint8 arg3 ;
  GoUint64 *arg4 = (GoUint64 *) 0 ;
  coin__UxArray *arg5 = (coin__UxArray *) 0 ;
  GoUint64 *arg6 = (GoUint64 *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned char val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 6) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_transaction_DistributeSpendHours.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_transaction_DistributeSpendHours" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_transaction_DistributeSpendHours" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_char(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_transaction_DistributeSpendHours" "', argument " "3"" of type '" "GoUint8""'");
  } 
  arg3 = static_cast< GoUint8 >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_transaction_DistributeSpendHours" "', argument " "4"" of type '" "GoUint64 *""'"); 
  }
  arg4 = reinterpret_cast< GoUint64 * >(argp4);
  res5 = SWIG_ConvertPtr(args[4], &argp5,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SKY_transaction_DistributeSpendHours" "', argument " "5"" of type '" "coin__UxArray *""'"); 
  }
  arg5 = reinterpret_cast< coin__UxArray * >(argp5);
  res6 = SWIG_ConvertPtr(args[5], &argp6,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SKY_transaction_DistributeSpendHours" "', argument " "6"" of type '" "GoUint64 *""'"); 
  }
  arg6 = reinterpret_cast< GoUint64 * >(argp6);
  result = (GoUint32)SKY_transaction_DistributeSpendHours(arg1,arg2,arg3,arg4,arg5,arg6);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_base58_Hex2Base58(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_base58_Hex2Base58.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_base58_Hex2Base58" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_base58_Hex2Base58" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_base58_Hex2Base58" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_base58_Hex2Base58(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_base58_Encode(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_base58_Encode.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_base58_Encode" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_base58_Encode" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_base58_Encode" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_base58_Encode(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_base58_Decode(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_base58_Decode.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_base58_Decode" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_base58_Decode(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_base58_String2Hex(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_base58_String2Hex.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_base58_String2Hex" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_base58_String2Hex(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_NewClient(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  Client__Handle *arg2 = (Client__Handle *) 0 ;
  GoString temp1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_NewClient.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_NewClient" "', argument " "2"" of type '" "Client__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Client__Handle * >(argp2);
  result = (GoUint32)SKY_api_NewClient(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_CSRF(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_CSRF.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_CSRF" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_CSRF" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_api_Client_CSRF(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Version(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Version.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Version" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Version" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_Version(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Outputs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Outputs.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Outputs" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Outputs" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_Outputs(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_OutputsForAddresses(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoSlice arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_OutputsForAddresses.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_OutputsForAddresses" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_OutputsForAddresses" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_Client_OutputsForAddresses" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_OutputsForAddresses" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_OutputsForAddresses(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_OutputsForHashes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoSlice arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_OutputsForHashes.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_OutputsForHashes" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_OutputsForHashes" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_Client_OutputsForHashes" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_OutputsForHashes" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_OutputsForHashes(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_CoinSupply(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_CoinSupply.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_CoinSupply" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_CoinSupply" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_CoinSupply(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_BlockByHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_BlockByHash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_BlockByHash" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_BlockByHash" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_BlockByHash(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_BlockBySeq(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoUint64 arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_BlockBySeq.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_BlockBySeq" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Client_BlockBySeq" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_BlockBySeq" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_BlockBySeq(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Blocks(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoSlice arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Blocks.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Blocks" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Blocks" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_Client_Blocks" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_Blocks" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_Blocks(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_LastBlocks(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoUint64 arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_LastBlocks.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_LastBlocks" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Client_LastBlocks" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_LastBlocks" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_LastBlocks(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_BlockchainMetadata(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_BlockchainMetadata.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_BlockchainMetadata" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_BlockchainMetadata" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_BlockchainMetadata(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_BlockchainProgress(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_BlockchainProgress.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_BlockchainProgress" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_BlockchainProgress" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_BlockchainProgress(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Balance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoSlice arg2 ;
  wallet__BalancePair *arg3 = (wallet__BalancePair *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Balance.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Balance" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Balance" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_Client_Balance" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_wallet__BalancePair, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_Balance" "', argument " "3"" of type '" "wallet__BalancePair *""'"); 
  }
  arg3 = reinterpret_cast< wallet__BalancePair * >(argp3);
  result = (GoUint32)SKY_api_Client_Balance(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_UxOut(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_UxOut.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_UxOut" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_UxOut" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_UxOut(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_AddressUxOuts(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_AddressUxOuts.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_AddressUxOuts" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_AddressUxOuts" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_AddressUxOuts(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Wallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  WalletResponse__Handle *arg3 = (WalletResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Wallet.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Wallet" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_Wallet" "', argument " "3"" of type '" "WalletResponse__Handle *""'"); 
  }
  arg3 = reinterpret_cast< WalletResponse__Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_Wallet(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Wallets(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Wallets__Handle *arg2 = (Wallets__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Wallets.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Wallets" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Wallets" "', argument " "2"" of type '" "Wallets__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Wallets__Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_Wallets(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_CreateUnencryptedWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  GoInt arg4 ;
  WalletResponse__Handle *arg5 = (WalletResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoString temp3 ;
  long long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_CreateUnencryptedWallet.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_CreateUnencryptedWallet" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  ecode4 = SWIG_AsVal_long_SS_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SKY_api_Client_CreateUnencryptedWallet" "', argument " "4"" of type '" "GoInt""'");
  } 
  arg4 = static_cast< GoInt >(val4);
  res5 = SWIG_ConvertPtr(args[4], &argp5,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SKY_api_Client_CreateUnencryptedWallet" "', argument " "5"" of type '" "WalletResponse__Handle *""'"); 
  }
  arg5 = reinterpret_cast< WalletResponse__Handle * >(argp5);
  result = (GoUint32)SKY_api_Client_CreateUnencryptedWallet(arg1,arg2,arg3,arg4,arg5);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_CreateEncryptedWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  GoString arg4 ;
  GoInt arg5 ;
  WalletResponse__Handle *arg6 = (WalletResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoString temp3 ;
  GoString temp4 ;
  long long val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_CreateEncryptedWallet.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_CreateEncryptedWallet" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  {
    temp4.p = NULL;
    temp4.n = 0;
    arg4 = (GoString)temp4;
  }
  ecode5 = SWIG_AsVal_long_SS_long(args[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "SKY_api_Client_CreateEncryptedWallet" "', argument " "5"" of type '" "GoInt""'");
  } 
  arg5 = static_cast< GoInt >(val5);
  res6 = SWIG_ConvertPtr(args[5], &argp6,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "SKY_api_Client_CreateEncryptedWallet" "', argument " "6"" of type '" "WalletResponse__Handle *""'"); 
  }
  arg6 = reinterpret_cast< WalletResponse__Handle * >(argp6);
  result = (GoUint32)SKY_api_Client_CreateEncryptedWallet(arg1,arg2,arg3,arg4,arg5,arg6);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_NewWalletAddress(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoInt arg3 ;
  GoString arg4 ;
  Strings__Handle *arg5 = (Strings__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  long long val3 ;
  int ecode3 = 0 ;
  GoString temp4 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_NewWalletAddress.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_NewWalletAddress" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_api_Client_NewWalletAddress" "', argument " "3"" of type '" "GoInt""'");
  } 
  arg3 = static_cast< GoInt >(val3);
  {
    temp4.p = NULL;
    temp4.n = 0;
    arg4 = (GoString)temp4;
  }
  res5 = SWIG_ConvertPtr(args[4], &argp5,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "SKY_api_Client_NewWalletAddress" "', argument " "5"" of type '" "Strings__Handle *""'"); 
  }
  arg5 = reinterpret_cast< Strings__Handle * >(argp5);
  result = (GoUint32)SKY_api_Client_NewWalletAddress(arg1,arg2,arg3,arg4,arg5);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_WalletBalance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  wallet__BalancePair *arg3 = (wallet__BalancePair *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_WalletBalance.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_WalletBalance" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_wallet__BalancePair, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_WalletBalance" "', argument " "3"" of type '" "wallet__BalancePair *""'"); 
  }
  arg3 = reinterpret_cast< wallet__BalancePair * >(argp3);
  result = (GoUint32)SKY_api_Client_WalletBalance(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_CreateTransaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  CreateTransactionResponse__Handle *arg3 = (CreateTransactionResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_CreateTransaction.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_CreateTransaction" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_CreateTransaction" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_CreateTransaction" "', argument " "3"" of type '" "CreateTransactionResponse__Handle *""'"); 
  }
  arg3 = reinterpret_cast< CreateTransactionResponse__Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_CreateTransaction(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_UpdateWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoString temp3 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_UpdateWallet.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_UpdateWallet" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  result = (GoUint32)SKY_api_Client_UpdateWallet(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_WalletFolderName(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_WalletFolderName.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_WalletFolderName" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_WalletFolderName" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_WalletFolderName(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_NewSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoInt arg2 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_NewSeed.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_NewSeed" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Client_NewSeed" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_NewSeed" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  result = (GoUint32)SKY_api_Client_NewSeed(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_WalletSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  GoString_ *arg4 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoString temp3 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_WalletSeed.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_WalletSeed" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_api_Client_WalletSeed" "', argument " "4"" of type '" "GoString_ *""'"); 
  }
  arg4 = reinterpret_cast< GoString_ * >(argp4);
  result = (GoUint32)SKY_api_Client_WalletSeed(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_NetworkConnection(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_NetworkConnection.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_NetworkConnection" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_NetworkConnection" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_NetworkConnection(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_NetworkConnections(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  api__NetworkConnectionsFilter *arg2 = (api__NetworkConnectionsFilter *) 0 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_NetworkConnections.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_NetworkConnections" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_api__NetworkConnectionsFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_NetworkConnections" "', argument " "2"" of type '" "api__NetworkConnectionsFilter *""'"); 
  }
  arg2 = reinterpret_cast< api__NetworkConnectionsFilter * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_NetworkConnections" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_NetworkConnections(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_NetworkDefaultPeers(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_NetworkDefaultPeers.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_NetworkDefaultPeers" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_NetworkDefaultPeers" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_api_Client_NetworkDefaultPeers(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_NetworkTrustedPeers(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_NetworkTrustedPeers.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_NetworkTrustedPeers" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_NetworkTrustedPeers" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_api_Client_NetworkTrustedPeers(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_NetworkExchangedPeers(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_NetworkExchangedPeers.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_NetworkExchangedPeers" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_NetworkExchangedPeers" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_api_Client_NetworkExchangedPeers(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_PendingTransactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_PendingTransactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_PendingTransactions" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_PendingTransactions" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_PendingTransactions(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Transaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Transaction.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Transaction" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_Transaction" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_Transaction(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Transactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoSlice arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Transactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Transactions" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Transactions" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_Client_Transactions" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_Transactions" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_Transactions(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_ConfirmedTransactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoSlice arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_ConfirmedTransactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_ConfirmedTransactions" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_ConfirmedTransactions" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_Client_ConfirmedTransactions" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_ConfirmedTransactions" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_ConfirmedTransactions(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_UnconfirmedTransactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoSlice arg2 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_UnconfirmedTransactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_UnconfirmedTransactions" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_UnconfirmedTransactions" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_api_Client_UnconfirmedTransactions" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_UnconfirmedTransactions" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_UnconfirmedTransactions(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_InjectTransaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Transaction__Handle arg2 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_InjectTransaction.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_InjectTransaction" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_api_Client_InjectTransaction" "', argument " "2"" of type '" "Transaction__Handle""'");
  } 
  arg2 = static_cast< Transaction__Handle >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_InjectTransaction" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  result = (GoUint32)SKY_api_Client_InjectTransaction(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_ResendUnconfirmedTransactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_ResendUnconfirmedTransactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_ResendUnconfirmedTransactions" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_ResendUnconfirmedTransactions" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_ResendUnconfirmedTransactions(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_RawTransaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoString_ *arg3 = (GoString_ *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_RawTransaction.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_RawTransaction" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_RawTransaction" "', argument " "3"" of type '" "GoString_ *""'"); 
  }
  arg3 = reinterpret_cast< GoString_ * >(argp3);
  result = (GoUint32)SKY_api_Client_RawTransaction(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Richlist(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  api__RichlistParams *arg2 = (api__RichlistParams *) 0 ;
  Handle *arg3 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Richlist.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Richlist" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_api__RichlistParams, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Richlist" "', argument " "2"" of type '" "api__RichlistParams *""'"); 
  }
  arg2 = reinterpret_cast< api__RichlistParams * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_api_Client_Richlist" "', argument " "3"" of type '" "Handle *""'"); 
  }
  arg3 = reinterpret_cast< Handle * >(argp3);
  result = (GoUint32)SKY_api_Client_Richlist(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_AddressCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_AddressCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_AddressCount" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_AddressCount" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_api_Client_AddressCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_UnloadWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_UnloadWallet.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_UnloadWallet" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  result = (GoUint32)SKY_api_Client_UnloadWallet(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_Health(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  Handle *arg2 = (Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_Health.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_Health" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_api_Client_Health" "', argument " "2"" of type '" "Handle *""'"); 
  }
  arg2 = reinterpret_cast< Handle * >(argp2);
  result = (GoUint32)SKY_api_Client_Health(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_EncryptWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  WalletResponse__Handle *arg4 = (WalletResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoString temp3 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_EncryptWallet.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_EncryptWallet" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_api_Client_EncryptWallet" "', argument " "4"" of type '" "WalletResponse__Handle *""'"); 
  }
  arg4 = reinterpret_cast< WalletResponse__Handle * >(argp4);
  result = (GoUint32)SKY_api_Client_EncryptWallet(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_api_Client_DecryptWallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Client__Handle arg1 ;
  GoString arg2 ;
  GoString arg3 ;
  WalletResponse__Handle *arg4 = (WalletResponse__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoString temp2 ;
  GoString temp3 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_api_Client_DecryptWallet.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_api_Client_DecryptWallet" "', argument " "1"" of type '" "Client__Handle""'");
  } 
  arg1 = static_cast< Client__Handle >(val1);
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  {
    temp3.p = NULL;
    temp3.n = 0;
    arg3 = (GoString)temp3;
  }
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_api_Client_DecryptWallet" "', argument " "4"" of type '" "WalletResponse__Handle *""'"); 
  }
  arg4 = reinterpret_cast< WalletResponse__Handle * >(argp4);
  result = (GoUint32)SKY_api_Client_DecryptWallet(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Create_Transaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle *arg1 = (Transaction__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Create_Transaction.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_Create_Transaction" "', argument " "1"" of type '" "Transaction__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transaction__Handle * >(argp1);
  result = (GoUint32)SKY_coin_Create_Transaction(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_Copy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  Transaction__Handle *arg2 = (Transaction__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_Copy.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_Copy" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_Copy" "', argument " "2"" of type '" "Transaction__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Transaction__Handle * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_Copy(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_GetTransactionObject(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  coin__Transaction **arg2 = (coin__Transaction **) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_GetTransactionObject.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_GetTransactionObject" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_p_coin__Transaction, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_GetTransactionObject" "', argument " "2"" of type '" "coin__Transaction **""'"); 
  }
  arg2 = reinterpret_cast< coin__Transaction ** >(argp2);
  result = (GoUint32)SKY_coin_GetTransactionObject(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_ResetInputs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_ResetInputs.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_ResetInputs" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_ResetInputs" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  result = (GoUint32)SKY_coin_Transaction_ResetInputs(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_GetInputsCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt *arg2 = (GoInt *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_GetInputsCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_GetInputsCount" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_GetInputsCount" "', argument " "2"" of type '" "GoInt *""'"); 
  }
  arg2 = reinterpret_cast< GoInt * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_GetInputsCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_GetInputAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_GetInputAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_GetInputAt" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_GetInputAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transaction_GetInputAt" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_coin_Transaction_GetInputAt(arg1,arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_SetInputAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_SetInputAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_SetInputAt" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_SetInputAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transaction_SetInputAt" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_coin_Transaction_SetInputAt(arg1,arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_GetOutputsCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt *arg2 = (GoInt *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_GetOutputsCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_GetOutputsCount" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_GetOutputsCount" "', argument " "2"" of type '" "GoInt *""'"); 
  }
  arg2 = reinterpret_cast< GoInt * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_GetOutputsCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_GetOutputAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  coin__TransactionOutput *arg3 = (coin__TransactionOutput *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_GetOutputAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_GetOutputAt" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_GetOutputAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transaction_GetOutputAt" "', argument " "3"" of type '" "coin__TransactionOutput *""'"); 
  }
  arg3 = reinterpret_cast< coin__TransactionOutput * >(argp3);
  result = (GoUint32)SKY_coin_Transaction_GetOutputAt(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_SetOutputAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  coin__TransactionOutput *arg3 = (coin__TransactionOutput *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_SetOutputAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_SetOutputAt" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_SetOutputAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transaction_SetOutputAt" "', argument " "3"" of type '" "coin__TransactionOutput *""'"); 
  }
  arg3 = reinterpret_cast< coin__TransactionOutput * >(argp3);
  result = (GoUint32)SKY_coin_Transaction_SetOutputAt(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_GetSignaturesCount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt *arg2 = (GoInt *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_GetSignaturesCount.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_GetSignaturesCount" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_GetSignaturesCount" "', argument " "2"" of type '" "GoInt *""'"); 
  }
  arg2 = reinterpret_cast< GoInt * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_GetSignaturesCount(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_GetSignatureAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  cipher__Sig *arg3 = (cipher__Sig *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_GetSignatureAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_GetSignatureAt" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_GetSignatureAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transaction_GetSignatureAt" "', argument " "3"" of type '" "cipher__Sig *""'"); 
  }
  arg3 = reinterpret_cast< cipher__Sig * >(argp3);
  result = (GoUint32)SKY_coin_Transaction_GetSignatureAt(arg1,arg2,(unsigned char (*)[65])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_SetSignatureAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  cipher__Sig *arg3 = (cipher__Sig *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_SetSignatureAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_SetSignatureAt" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_SetSignatureAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transaction_SetSignatureAt" "', argument " "3"" of type '" "cipher__Sig *""'"); 
  }
  arg3 = reinterpret_cast< cipher__Sig * >(argp3);
  result = (GoUint32)SKY_coin_Transaction_SetSignatureAt(arg1,arg2,(unsigned char (*)[65])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_PushSignature(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  cipher__Sig *arg2 = (cipher__Sig *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_PushSignature.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_PushSignature" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_65__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_PushSignature" "', argument " "2"" of type '" "cipher__Sig *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Sig * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_PushSignature(arg1,(unsigned char (*)[65])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_ResetOutputs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_ResetOutputs.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_ResetOutputs" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_ResetOutputs" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  result = (GoUint32)SKY_coin_Transaction_ResetOutputs(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_ResetSignatures(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoInt arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_ResetSignatures.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_ResetSignatures" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transaction_ResetSignatures" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  result = (GoUint32)SKY_coin_Transaction_ResetSignatures(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_Verify(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_Verify.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_Verify" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  result = (GoUint32)SKY_coin_Transaction_Verify(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_PushInput(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_PushInput.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_PushInput" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_PushInput" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_PushInput(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_TransactionOutput_UxID(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_TransactionOutput_UxID.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_TransactionOutput_UxID" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
  }
  arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_TransactionOutput_UxID" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_TransactionOutput_UxID" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_coin_TransactionOutput_UxID(arg1,(unsigned char (*)[32])arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_PushOutput(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  GoUint64 arg3 ;
  GoUint64 arg4 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  unsigned long long val4 ;
  int ecode4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_PushOutput.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_PushOutput" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_PushOutput" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_Transaction_PushOutput" "', argument " "3"" of type '" "GoUint64""'");
  } 
  arg3 = static_cast< GoUint64 >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_long_SS_long(args[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SKY_coin_Transaction_PushOutput" "', argument " "4"" of type '" "GoUint64""'");
  } 
  arg4 = static_cast< GoUint64 >(val4);
  result = (GoUint32)SKY_coin_Transaction_PushOutput(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_SignInputs(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoSlice arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_SignInputs.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_SignInputs" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  {
    res2 = SWIG_ConvertPtr(args[1], &argp2, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_SignInputs" "', argument " "2"" of type '" "GoSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_coin_Transaction_SignInputs" "', argument " "2"" of type '" "GoSlice""'");
    } else {
      arg2 = *(reinterpret_cast< GoSlice * >(argp2));
    }
  }
  result = (GoUint32)SKY_coin_Transaction_SignInputs(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_Size(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_Size.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_Size" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_Size" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_Size(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_Hash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_Hash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_Hash" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_Hash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_Hash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_SizeHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  cipher__SHA256 *arg3 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_SizeHash.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_SizeHash" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_SizeHash" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transaction_SizeHash" "', argument " "3"" of type '" "cipher__SHA256 *""'"); 
  }
  arg3 = reinterpret_cast< cipher__SHA256 * >(argp3);
  result = (GoUint32)SKY_coin_Transaction_SizeHash(arg1,arg2,(unsigned char (*)[32])arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_UpdateHeader(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_UpdateHeader.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_UpdateHeader" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  result = (GoUint32)SKY_coin_Transaction_UpdateHeader(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_HashInner(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_HashInner.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_HashInner" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_HashInner" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_HashInner(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_Serialize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_Serialize.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_Serialize" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_Serialize" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_Serialize(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_TransactionDeserialize(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  Transaction__Handle *arg2 = (Transaction__Handle *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_TransactionDeserialize.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_TransactionDeserialize" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_coin_TransactionDeserialize" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_TransactionDeserialize" "', argument " "2"" of type '" "Transaction__Handle *""'"); 
  }
  arg2 = reinterpret_cast< Transaction__Handle * >(argp2);
  result = (GoUint32)SKY_coin_TransactionDeserialize(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transaction_OutputHours(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transaction_OutputHours.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transaction_OutputHours" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transaction_OutputHours" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_coin_Transaction_OutputHours(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Create_Transactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle *arg1 = (Transactions__Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Create_Transactions.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_Create_Transactions" "', argument " "1"" of type '" "Transactions__Handle *""'"); 
  }
  arg1 = reinterpret_cast< Transactions__Handle * >(argp1);
  result = (GoUint32)SKY_coin_Create_Transactions(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_GetTransactionsObject(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  coin__UxArray **arg2 = (coin__UxArray **) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_GetTransactionsObject.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_GetTransactionsObject" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_GetTransactionsObject" "', argument " "2"" of type '" "coin__UxArray **""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray ** >(argp2);
  result = (GoUint32)SKY_coin_GetTransactionsObject(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transactions_Length(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  GoInt *arg2 = (GoInt *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transactions_Length.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transactions_Length" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transactions_Length" "', argument " "2"" of type '" "GoInt *""'"); 
  }
  arg2 = reinterpret_cast< GoInt * >(argp2);
  result = (GoUint32)SKY_coin_Transactions_Length(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transactions_Add(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  Transaction__Handle arg2 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transactions_Add.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transactions_Add" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transactions_Add" "', argument " "2"" of type '" "Transaction__Handle""'");
  } 
  arg2 = static_cast< Transaction__Handle >(val2);
  result = (GoUint32)SKY_coin_Transactions_Add(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transactions_Fees(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  FeeCalculator *arg2 = (FeeCalculator *) 0 ;
  GoUint64 *arg3 = (GoUint64 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transactions_Fees.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transactions_Fees" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_FeeCalculator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transactions_Fees" "', argument " "2"" of type '" "FeeCalculator *""'"); 
  }
  arg2 = reinterpret_cast< FeeCalculator * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transactions_Fees" "', argument " "3"" of type '" "GoUint64 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint64 * >(argp3);
  result = (GoUint32)SKY_coin_Transactions_Fees(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transactions_GetAt(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  GoInt arg2 ;
  Transaction__Handle *arg3 = (Transaction__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transactions_GetAt.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transactions_GetAt" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transactions_GetAt" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transactions_GetAt" "', argument " "3"" of type '" "Transaction__Handle *""'"); 
  }
  arg3 = reinterpret_cast< Transaction__Handle * >(argp3);
  result = (GoUint32)SKY_coin_Transactions_GetAt(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transactions_Hashes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transactions_Hashes.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transactions_Hashes" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transactions_Hashes" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_Transactions_Hashes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transactions_Size(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  GoUint32 *arg2 = (GoUint32 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transactions_Size.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transactions_Size" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_Transactions_Size" "', argument " "2"" of type '" "GoUint32 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint32 * >(argp2);
  result = (GoUint32)SKY_coin_Transactions_Size(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_Transactions_TruncateBytesTo(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  GoUint32 arg2 ;
  Transactions__Handle *arg3 = (Transactions__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_Transactions_TruncateBytesTo.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_Transactions_TruncateBytesTo" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_Transactions_TruncateBytesTo" "', argument " "2"" of type '" "GoUint32""'");
  } 
  arg2 = static_cast< GoUint32 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_Transactions_TruncateBytesTo" "', argument " "3"" of type '" "Transactions__Handle *""'"); 
  }
  arg3 = reinterpret_cast< Transactions__Handle * >(argp3);
  result = (GoUint32)SKY_coin_Transactions_TruncateBytesTo(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_SortTransactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  FeeCalculator *arg2 = (FeeCalculator *) 0 ;
  Transactions__Handle *arg3 = (Transactions__Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_SortTransactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_SortTransactions" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_FeeCalculator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_SortTransactions" "', argument " "2"" of type '" "FeeCalculator *""'"); 
  }
  arg2 = reinterpret_cast< FeeCalculator * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_SortTransactions" "', argument " "3"" of type '" "Transactions__Handle *""'"); 
  }
  arg3 = reinterpret_cast< Transactions__Handle * >(argp3);
  result = (GoUint32)SKY_coin_SortTransactions(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_NewSortableTransactions(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transactions__Handle arg1 ;
  FeeCalculator *arg2 = (FeeCalculator *) 0 ;
  SortableTransactionResult_Handle *arg3 = (SortableTransactionResult_Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_NewSortableTransactions.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_NewSortableTransactions" "', argument " "1"" of type '" "Transactions__Handle""'");
  } 
  arg1 = static_cast< Transactions__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_FeeCalculator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_NewSortableTransactions" "', argument " "2"" of type '" "FeeCalculator *""'"); 
  }
  arg2 = reinterpret_cast< FeeCalculator * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_NewSortableTransactions" "', argument " "3"" of type '" "SortableTransactionResult_Handle *""'"); 
  }
  arg3 = reinterpret_cast< SortableTransactionResult_Handle * >(argp3);
  result = (GoUint32)SKY_coin_NewSortableTransactions(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_SortableTransactions_Sort(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  SortableTransactionResult_Handle arg1 ;
  long long val1 ;
  int ecode1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_SortableTransactions_Sort.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_SortableTransactions_Sort" "', argument " "1"" of type '" "SortableTransactionResult_Handle""'");
  } 
  arg1 = static_cast< SortableTransactionResult_Handle >(val1);
  result = (GoUint32)SKY_coin_SortableTransactions_Sort(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_SortableTransactions_Len(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  SortableTransactionResult_Handle arg1 ;
  GoInt *arg2 = (GoInt *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_SortableTransactions_Len.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_SortableTransactions_Len" "', argument " "1"" of type '" "SortableTransactionResult_Handle""'");
  } 
  arg1 = static_cast< SortableTransactionResult_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_SortableTransactions_Len" "', argument " "2"" of type '" "GoInt *""'"); 
  }
  arg2 = reinterpret_cast< GoInt * >(argp2);
  result = (GoUint32)SKY_coin_SortableTransactions_Len(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_SortableTransactions_Less(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  SortableTransactionResult_Handle arg1 ;
  GoInt arg2 ;
  GoInt arg3 ;
  GoUint8 *arg4 = (GoUint8 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_SortableTransactions_Less.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_SortableTransactions_Less" "', argument " "1"" of type '" "SortableTransactionResult_Handle""'");
  } 
  arg1 = static_cast< SortableTransactionResult_Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_SortableTransactions_Less" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_SortableTransactions_Less" "', argument " "3"" of type '" "GoInt""'");
  } 
  arg3 = static_cast< GoInt >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_coin_SortableTransactions_Less" "', argument " "4"" of type '" "GoUint8 *""'"); 
  }
  arg4 = reinterpret_cast< GoUint8 * >(argp4);
  result = (GoUint32)SKY_coin_SortableTransactions_Less(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_SortableTransactions_Swap(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  SortableTransactionResult_Handle arg1 ;
  GoInt arg2 ;
  GoInt arg3 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  long long val3 ;
  int ecode3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_SortableTransactions_Swap.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_SortableTransactions_Swap" "', argument " "1"" of type '" "SortableTransactionResult_Handle""'");
  } 
  arg1 = static_cast< SortableTransactionResult_Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_SortableTransactions_Swap" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_SortableTransactions_Swap" "', argument " "3"" of type '" "GoInt""'");
  } 
  arg3 = static_cast< GoInt >(val3);
  result = (GoUint32)SKY_coin_SortableTransactions_Swap(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_VerifyTransactionCoinsSpending(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_VerifyTransactionCoinsSpending.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_VerifyTransactionCoinsSpending" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_VerifyTransactionCoinsSpending" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_VerifyTransactionCoinsSpending(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_VerifyTransactionHoursSpending(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint64 arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  unsigned long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_VerifyTransactionHoursSpending.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_VerifyTransactionHoursSpending" "', argument " "1"" of type '" "GoUint64""'");
  } 
  arg1 = static_cast< GoUint64 >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_VerifyTransactionHoursSpending" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_VerifyTransactionHoursSpending" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_coin_VerifyTransactionHoursSpending(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_VerifyInputSignatures(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  Transaction__Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_VerifyInputSignatures.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_VerifyInputSignatures" "', argument " "1"" of type '" "Transaction__Handle""'");
  } 
  arg1 = static_cast< Transaction__Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_VerifyInputSignatures" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_VerifyInputSignatures(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_params_GetDistributionAddresses(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_params_GetDistributionAddresses.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_params_GetDistributionAddresses" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  SKY_params_GetDistributionAddresses(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_params_GetUnlockedDistributionAddresses(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_params_GetUnlockedDistributionAddresses.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_params_GetUnlockedDistributionAddresses" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  SKY_params_GetUnlockedDistributionAddresses(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_params_GetLockedDistributionAddresses(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_params_GetLockedDistributionAddresses.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_params_GetLockedDistributionAddresses" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  SKY_params_GetLockedDistributionAddresses(arg1);
  jsresult = SWIGV8_UNDEFINED();
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_bip39_NewDefaultMnemomic(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString_ *arg1 = (GoString_ *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_bip39_NewDefaultMnemomic.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_bip39_NewDefaultMnemomic" "', argument " "1"" of type '" "GoString_ *""'"); 
  }
  arg1 = reinterpret_cast< GoString_ * >(argp1);
  result = (GoUint32)SKY_bip39_NewDefaultMnemomic(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_bip39_NewEntropy(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoInt arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_bip39_NewEntropy.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_bip39_NewEntropy" "', argument " "1"" of type '" "GoInt""'");
  } 
  arg1 = static_cast< GoInt >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_bip39_NewEntropy" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_bip39_NewEntropy(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_bip39_NewMnemonic(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoSlice arg1 ;
  GoString_ *arg2 = (GoString_ *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_bip39_NewMnemonic.");
  
  {
    res1 = SWIG_ConvertPtr(args[0], &argp1, SWIGTYPE_p_GoSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_bip39_NewMnemonic" "', argument " "1"" of type '" "GoSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SKY_bip39_NewMnemonic" "', argument " "1"" of type '" "GoSlice""'");
    } else {
      arg1 = *(reinterpret_cast< GoSlice * >(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_bip39_NewMnemonic" "', argument " "2"" of type '" "GoString_ *""'"); 
  }
  arg2 = reinterpret_cast< GoString_ * >(argp2);
  result = (GoUint32)SKY_bip39_NewMnemonic(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_bip39_ValidateMnemonic(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString temp1 ;
  GoUint32 result;
  
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_bip39_ValidateMnemonic.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  result = (GoUint32)SKY_bip39_ValidateMnemonic(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_bip39_NewSeed(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoString arg1 ;
  GoString arg2 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  GoString temp1 ;
  GoString temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_bip39_NewSeed.");
  
  {
    temp1.p = NULL;
    temp1.n = 0;
    arg1 = (GoString)temp1;
  }
  {
    temp2.p = NULL;
    temp2.n = 0;
    arg2 = (GoString)temp2;
  }
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_bip39_NewSeed" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_bip39_NewSeed(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxOut_Hash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxOut *arg1 = (coin__UxOut *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxOut_Hash.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__UxOut, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxOut_Hash" "', argument " "1"" of type '" "coin__UxOut *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxOut * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxOut_Hash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_UxOut_Hash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxOut_SnapshotHash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxOut *arg1 = (coin__UxOut *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxOut_SnapshotHash.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__UxOut, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxOut_SnapshotHash" "', argument " "1"" of type '" "coin__UxOut *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxOut * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxOut_SnapshotHash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_UxOut_SnapshotHash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxBody_Hash(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxBody *arg1 = (coin__UxBody *) 0 ;
  cipher__SHA256 *arg2 = (cipher__SHA256 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxBody_Hash.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxBody_Hash" "', argument " "1"" of type '" "coin__UxBody *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxBody * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_a_32__unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxBody_Hash" "', argument " "2"" of type '" "cipher__SHA256 *""'"); 
  }
  arg2 = reinterpret_cast< cipher__SHA256 * >(argp2);
  result = (GoUint32)SKY_coin_UxBody_Hash(arg1,(unsigned char (*)[32])arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxOut_CoinHours(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxOut *arg1 = (coin__UxOut *) 0 ;
  GoUint64 arg2 ;
  GoUint64 *arg3 = (GoUint64 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxOut_CoinHours.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_coin__UxOut, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxOut_CoinHours" "', argument " "1"" of type '" "coin__UxOut *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxOut * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_UxOut_CoinHours" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_UxOut_CoinHours" "', argument " "3"" of type '" "GoUint64 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint64 * >(argp3);
  result = (GoUint32)SKY_coin_UxOut_CoinHours(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Hashes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Hashes.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Hashes" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxArray_Hashes" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_UxArray_Hashes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_HasDupes(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  GoUint8 *arg2 = (GoUint8 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_HasDupes.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_HasDupes" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxArray_HasDupes" "', argument " "2"" of type '" "GoUint8 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint8 * >(argp2);
  result = (GoUint32)SKY_coin_UxArray_HasDupes(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Sort(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Sort.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Sort" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  result = (GoUint32)SKY_coin_UxArray_Sort(arg1);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Len(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  GoInt *arg2 = (GoInt *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Len.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Len" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxArray_Len" "', argument " "2"" of type '" "GoInt *""'"); 
  }
  arg2 = reinterpret_cast< GoInt * >(argp2);
  result = (GoUint32)SKY_coin_UxArray_Len(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Less(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  GoInt arg2 ;
  GoInt arg3 ;
  GoUint8 *arg4 = (GoUint8 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  long long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 4) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Less.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Less" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_UxArray_Less" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_UxArray_Less" "', argument " "3"" of type '" "GoInt""'");
  } 
  arg3 = static_cast< GoInt >(val3);
  res4 = SWIG_ConvertPtr(args[3], &argp4,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SKY_coin_UxArray_Less" "', argument " "4"" of type '" "GoUint8 *""'"); 
  }
  arg4 = reinterpret_cast< GoUint8 * >(argp4);
  result = (GoUint32)SKY_coin_UxArray_Less(arg1,arg2,arg3,arg4);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Swap(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  GoInt arg2 ;
  GoInt arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  long long val3 ;
  int ecode3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Swap.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Swap" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_UxArray_Swap" "', argument " "2"" of type '" "GoInt""'");
  } 
  arg2 = static_cast< GoInt >(val2);
  ecode3 = SWIG_AsVal_long_SS_long(args[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SKY_coin_UxArray_Swap" "', argument " "3"" of type '" "GoInt""'");
  } 
  arg3 = static_cast< GoInt >(val3);
  result = (GoUint32)SKY_coin_UxArray_Swap(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Coins(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  GoUint64 *arg2 = (GoUint64 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Coins.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Coins" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxArray_Coins" "', argument " "2"" of type '" "GoUint64 *""'"); 
  }
  arg2 = reinterpret_cast< GoUint64 * >(argp2);
  result = (GoUint32)SKY_coin_UxArray_Coins(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_CoinHours(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  GoUint64 arg2 ;
  GoUint64 *arg3 = (GoUint64 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_CoinHours.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_CoinHours" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_UxArray_CoinHours" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_UxArray_CoinHours" "', argument " "3"" of type '" "GoUint64 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint64 * >(argp3);
  result = (GoUint32)SKY_coin_UxArray_CoinHours(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Sub(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Sub.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Sub" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxArray_Sub" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_UxArray_Sub" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_coin_UxArray_Sub(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_UxArray_Add(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_UxArray_Add.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_UxArray_Add" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_UxArray_Add" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_UxArray_Add" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_coin_UxArray_Add(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_NewAddressUxOuts(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  coin__UxArray *arg1 = (coin__UxArray *) 0 ;
  AddressUxOuts_Handle *arg2 = (AddressUxOuts_Handle *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_NewAddressUxOuts.");
  
  res1 = SWIG_ConvertPtr(args[0], &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SKY_coin_NewAddressUxOuts" "', argument " "1"" of type '" "coin__UxArray *""'"); 
  }
  arg1 = reinterpret_cast< coin__UxArray * >(argp1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_NewAddressUxOuts" "', argument " "2"" of type '" "AddressUxOuts_Handle *""'"); 
  }
  arg2 = reinterpret_cast< AddressUxOuts_Handle * >(argp2);
  result = (GoUint32)SKY_coin_NewAddressUxOuts(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_Keys(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_Keys.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_Keys" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_AddressUxOuts_Keys" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_AddressUxOuts_Keys(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_Flatten(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  coin__UxArray *arg2 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_Flatten.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_Flatten" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_AddressUxOuts_Flatten" "', argument " "2"" of type '" "coin__UxArray *""'"); 
  }
  arg2 = reinterpret_cast< coin__UxArray * >(argp2);
  result = (GoUint32)SKY_coin_AddressUxOuts_Flatten(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_Sub(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  AddressUxOuts_Handle arg2 ;
  AddressUxOuts_Handle *arg3 = (AddressUxOuts_Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_Sub.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_Sub" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_AddressUxOuts_Sub" "', argument " "2"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg2 = static_cast< AddressUxOuts_Handle >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_AddressUxOuts_Sub" "', argument " "3"" of type '" "AddressUxOuts_Handle *""'"); 
  }
  arg3 = reinterpret_cast< AddressUxOuts_Handle * >(argp3);
  result = (GoUint32)SKY_coin_AddressUxOuts_Sub(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_Add(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  AddressUxOuts_Handle arg2 ;
  AddressUxOuts_Handle *arg3 = (AddressUxOuts_Handle *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  long long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_Add.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_Add" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  ecode2 = SWIG_AsVal_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_coin_AddressUxOuts_Add" "', argument " "2"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg2 = static_cast< AddressUxOuts_Handle >(val2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_AddressUxOuts_Add" "', argument " "3"" of type '" "AddressUxOuts_Handle *""'"); 
  }
  arg3 = reinterpret_cast< AddressUxOuts_Handle * >(argp3);
  result = (GoUint32)SKY_coin_AddressUxOuts_Add(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_Get(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_Get.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_Get" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_AddressUxOuts_Get" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_AddressUxOuts_Get" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_coin_AddressUxOuts_Get(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_HasKey(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  GoUint8 *arg3 = (GoUint8 *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_HasKey.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_HasKey" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_AddressUxOuts_HasKey" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_AddressUxOuts_HasKey" "', argument " "3"" of type '" "GoUint8 *""'"); 
  }
  arg3 = reinterpret_cast< GoUint8 * >(argp3);
  result = (GoUint32)SKY_coin_AddressUxOuts_HasKey(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_GetOutputLength(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  GoInt *arg3 = (GoInt *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_GetOutputLength.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_GetOutputLength" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_AddressUxOuts_GetOutputLength" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_AddressUxOuts_GetOutputLength" "', argument " "3"" of type '" "GoInt *""'"); 
  }
  arg3 = reinterpret_cast< GoInt * >(argp3);
  result = (GoUint32)SKY_coin_AddressUxOuts_GetOutputLength(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_Length(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  GoInt *arg2 = (GoInt *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_Length.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_Length" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_AddressUxOuts_Length" "', argument " "2"" of type '" "GoInt *""'"); 
  }
  arg2 = reinterpret_cast< GoInt * >(argp2);
  result = (GoUint32)SKY_coin_AddressUxOuts_Length(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_coin_AddressUxOuts_Set(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  AddressUxOuts_Handle arg1 ;
  cipher__Address *arg2 = (cipher__Address *) 0 ;
  coin__UxArray *arg3 = (coin__UxArray *) 0 ;
  long long val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 3) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_coin_AddressUxOuts_Set.");
  
  ecode1 = SWIG_AsVal_long_SS_long(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_coin_AddressUxOuts_Set" "', argument " "1"" of type '" "AddressUxOuts_Handle""'");
  } 
  arg1 = static_cast< AddressUxOuts_Handle >(val1);
  res2 = SWIG_ConvertPtr(args[1], &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SKY_coin_AddressUxOuts_Set" "', argument " "2"" of type '" "cipher__Address *""'"); 
  }
  arg2 = reinterpret_cast< cipher__Address * >(argp2);
  res3 = SWIG_ConvertPtr(args[2], &argp3,SWIGTYPE_p_GoSlice_, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SKY_coin_AddressUxOuts_Set" "', argument " "3"" of type '" "coin__UxArray *""'"); 
  }
  arg3 = reinterpret_cast< coin__UxArray * >(argp3);
  result = (GoUint32)SKY_coin_AddressUxOuts_Set(arg1,arg2,arg3);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_params_DropletPrecisionToDivisor(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint8 arg1 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  GoUint64 result;
  
  if(args.Length() != 1) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_params_DropletPrecisionToDivisor.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_char(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_params_DropletPrecisionToDivisor" "', argument " "1"" of type '" "GoUint8""'");
  } 
  arg1 = static_cast< GoUint8 >(val1);
  result = (GoUint64)SKY_params_DropletPrecisionToDivisor(arg1);
  jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


static SwigV8ReturnValue _wrap_SKY_params_DropletPrecisionCheck(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Value> jsresult;
  GoUint8 arg1 ;
  GoUint64 arg2 ;
  unsigned char val1 ;
  int ecode1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  GoUint32 result;
  
  if(args.Length() != 2) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_SKY_params_DropletPrecisionCheck.");
  
  ecode1 = SWIG_AsVal_unsigned_SS_char(args[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SKY_params_DropletPrecisionCheck" "', argument " "1"" of type '" "GoUint8""'");
  } 
  arg1 = static_cast< GoUint8 >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(args[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SKY_params_DropletPrecisionCheck" "', argument " "2"" of type '" "GoUint64""'");
  } 
  arg2 = static_cast< GoUint64 >(val2);
  result = (GoUint32)SKY_params_DropletPrecisionCheck(arg1,arg2);
  jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  
  
  
  SWIGV8_RETURN(jsresult);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_api__RichlistParams_N_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_api__RichlistParams_N_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    api__RichlistParams *arg1 = (api__RichlistParams *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__RichlistParams, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__RichlistParams_N_set" "', argument " "1"" of type '" "api__RichlistParams *""'"); 
    }
    arg1 = reinterpret_cast< api__RichlistParams * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "api__RichlistParams_N_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->N = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_api__RichlistParams_N_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_api__RichlistParams_N_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    api__RichlistParams *arg1 = (api__RichlistParams *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__RichlistParams, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__RichlistParams_N_get" "', argument " "1"" of type '" "api__RichlistParams *""'"); 
    }
    arg1 = reinterpret_cast< api__RichlistParams * >(argp1);
    result = (GoInt_) ((arg1)->N);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_api__RichlistParams_IncludeDistribution_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_api__RichlistParams_IncludeDistribution_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    api__RichlistParams *arg1 = (api__RichlistParams *) 0 ;
    BOOL arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__RichlistParams, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__RichlistParams_IncludeDistribution_set" "', argument " "1"" of type '" "api__RichlistParams *""'"); 
    }
    arg1 = reinterpret_cast< api__RichlistParams * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "api__RichlistParams_IncludeDistribution_set" "', argument " "2"" of type '" "BOOL""'");
    } 
    arg2 = static_cast< BOOL >(val2);
    if (arg1) (arg1)->IncludeDistribution = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_api__RichlistParams_IncludeDistribution_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_api__RichlistParams_IncludeDistribution_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    api__RichlistParams *arg1 = (api__RichlistParams *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    BOOL result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__RichlistParams, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__RichlistParams_IncludeDistribution_get" "', argument " "1"" of type '" "api__RichlistParams *""'"); 
    }
    arg1 = reinterpret_cast< api__RichlistParams * >(argp1);
    result = (BOOL) ((arg1)->IncludeDistribution);
    jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_api__RichlistParams(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  api__RichlistParams *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_api__RichlistParams.");
  result = (api__RichlistParams *)new api__RichlistParams();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_api__RichlistParams, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_api__RichlistParams(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_api__RichlistParams(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_api__RichlistParams(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_api__RichlistParams(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_api__RichlistParams(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            api__RichlistParams * arg1 = (api__RichlistParams *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_api__NetworkConnectionsFilter_States_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_api__NetworkConnectionsFilter_States_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    api__NetworkConnectionsFilter *arg1 = (api__NetworkConnectionsFilter *) 0 ;
    GoString_ *arg2 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__NetworkConnectionsFilter, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__NetworkConnectionsFilter_States_set" "', argument " "1"" of type '" "api__NetworkConnectionsFilter *""'"); 
    }
    arg1 = reinterpret_cast< api__NetworkConnectionsFilter * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "api__NetworkConnectionsFilter_States_set" "', argument " "2"" of type '" "GoString_ *""'"); 
    }
    arg2 = reinterpret_cast< GoString_ * >(argp2);
    if (arg1) (arg1)->States = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_api__NetworkConnectionsFilter_States_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_api__NetworkConnectionsFilter_States_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    api__NetworkConnectionsFilter *arg1 = (api__NetworkConnectionsFilter *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoString_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__NetworkConnectionsFilter, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__NetworkConnectionsFilter_States_get" "', argument " "1"" of type '" "api__NetworkConnectionsFilter *""'"); 
    }
    arg1 = reinterpret_cast< api__NetworkConnectionsFilter * >(argp1);
    result = (GoString_ *)& ((arg1)->States);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoString_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_api__NetworkConnectionsFilter_Direction_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_api__NetworkConnectionsFilter_Direction_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    api__NetworkConnectionsFilter *arg1 = (api__NetworkConnectionsFilter *) 0 ;
    GoString_ *arg2 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__NetworkConnectionsFilter, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__NetworkConnectionsFilter_Direction_set" "', argument " "1"" of type '" "api__NetworkConnectionsFilter *""'"); 
    }
    arg1 = reinterpret_cast< api__NetworkConnectionsFilter * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "api__NetworkConnectionsFilter_Direction_set" "', argument " "2"" of type '" "GoString_ *""'"); 
    }
    arg2 = reinterpret_cast< GoString_ * >(argp2);
    if (arg1) (arg1)->Direction = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_api__NetworkConnectionsFilter_Direction_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_api__NetworkConnectionsFilter_Direction_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    api__NetworkConnectionsFilter *arg1 = (api__NetworkConnectionsFilter *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoString_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__NetworkConnectionsFilter, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__NetworkConnectionsFilter_Direction_get" "', argument " "1"" of type '" "api__NetworkConnectionsFilter *""'"); 
    }
    arg1 = reinterpret_cast< api__NetworkConnectionsFilter * >(argp1);
    result = (GoString_ *)& ((arg1)->Direction);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoString_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_api__NetworkConnectionsFilter(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  api__NetworkConnectionsFilter *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_api__NetworkConnectionsFilter.");
  result = (api__NetworkConnectionsFilter *)new api__NetworkConnectionsFilter();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_api__NetworkConnectionsFilter, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_api__NetworkConnectionsFilter(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_api__NetworkConnectionsFilter(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_api__NetworkConnectionsFilter(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_api__NetworkConnectionsFilter(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_api__NetworkConnectionsFilter(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            api__NetworkConnectionsFilter * arg1 = (api__NetworkConnectionsFilter *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher__Address_Version_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher__Address_Version_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher__Address *arg1 = (cipher__Address *) 0 ;
    GoUint8_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned char val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__Address_Version_set" "', argument " "1"" of type '" "cipher__Address *""'"); 
    }
    arg1 = reinterpret_cast< cipher__Address * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_char(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cipher__Address_Version_set" "', argument " "2"" of type '" "GoUint8_""'");
    } 
    arg2 = static_cast< GoUint8_ >(val2);
    if (arg1) (arg1)->Version = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher__Address_Version_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher__Address_Version_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher__Address *arg1 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__Address_Version_get" "', argument " "1"" of type '" "cipher__Address *""'"); 
    }
    arg1 = reinterpret_cast< cipher__Address * >(argp1);
    result = (GoUint8_) ((arg1)->Version);
    jsresult = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher__Address_Key_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher__Address_Key_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher__Address *arg1 = (cipher__Address *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__Address_Key_set" "', argument " "1"" of type '" "cipher__Address *""'"); 
    }
    arg1 = reinterpret_cast< cipher__Address * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher__Address_Key_set" "', argument " "2"" of type '" "unsigned char [20]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)20; ++ii) *(unsigned char *)&arg1->Key[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Key""' of type '""unsigned char [20]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher__Address_Key_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher__Address_Key_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher__Address *arg1 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__Address_Key_get" "', argument " "1"" of type '" "cipher__Address *""'"); 
    }
    arg1 = reinterpret_cast< cipher__Address * >(argp1);
    result = (GoUint8_ *) ((arg1)->Key);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher__Address(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher__Address *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher__Address.");
  result = (cipher__Address *)new cipher__Address();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher__Address, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher__Address(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher__Address(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher__Address(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher__Address(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher__Address(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher__Address * arg1 = (cipher__Address *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher__BitcoinAddress_Version_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher__BitcoinAddress_Version_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
    GoUint8_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned char val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__BitcoinAddress_Version_set" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
    }
    arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_char(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cipher__BitcoinAddress_Version_set" "', argument " "2"" of type '" "GoUint8_""'");
    } 
    arg2 = static_cast< GoUint8_ >(val2);
    if (arg1) (arg1)->Version = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher__BitcoinAddress_Version_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher__BitcoinAddress_Version_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__BitcoinAddress_Version_get" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
    }
    arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
    result = (GoUint8_) ((arg1)->Version);
    jsresult = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cipher__BitcoinAddress_Key_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cipher__BitcoinAddress_Key_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__BitcoinAddress_Key_set" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
    }
    arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cipher__BitcoinAddress_Key_set" "', argument " "2"" of type '" "unsigned char [20]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)20; ++ii) *(unsigned char *)&arg1->Key[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Key""' of type '""unsigned char [20]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cipher__BitcoinAddress_Key_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cipher__BitcoinAddress_Key_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cipher__BitcoinAddress *arg1 = (cipher__BitcoinAddress *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cipher__BitcoinAddress, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cipher__BitcoinAddress_Key_get" "', argument " "1"" of type '" "cipher__BitcoinAddress *""'"); 
    }
    arg1 = reinterpret_cast< cipher__BitcoinAddress * >(argp1);
    result = (GoUint8_ *) ((arg1)->Key);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cipher__BitcoinAddress(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cipher__BitcoinAddress *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cipher__BitcoinAddress.");
  result = (cipher__BitcoinAddress *)new cipher__BitcoinAddress();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cipher__BitcoinAddress, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cipher__BitcoinAddress(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cipher__BitcoinAddress(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cipher__BitcoinAddress(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cipher__BitcoinAddress(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cipher__BitcoinAddress(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cipher__BitcoinAddress * arg1 = (cipher__BitcoinAddress *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_encrypt__ScryptChacha20poly1305_N_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_encrypt__ScryptChacha20poly1305_N_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_N_set" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "encrypt__ScryptChacha20poly1305_N_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->N = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_N_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_N_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_N_get" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    result = (GoInt_) ((arg1)->N);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_encrypt__ScryptChacha20poly1305_R_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_encrypt__ScryptChacha20poly1305_R_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_R_set" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "encrypt__ScryptChacha20poly1305_R_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->R = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_R_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_R_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_R_get" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    result = (GoInt_) ((arg1)->R);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_encrypt__ScryptChacha20poly1305_P_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_encrypt__ScryptChacha20poly1305_P_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_P_set" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "encrypt__ScryptChacha20poly1305_P_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->P = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_P_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_P_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_P_get" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    result = (GoInt_) ((arg1)->P);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_encrypt__ScryptChacha20poly1305_KeyLen_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_encrypt__ScryptChacha20poly1305_KeyLen_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_KeyLen_set" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "encrypt__ScryptChacha20poly1305_KeyLen_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->KeyLen = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_KeyLen_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_encrypt__ScryptChacha20poly1305_KeyLen_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    encrypt__ScryptChacha20poly1305 *arg1 = (encrypt__ScryptChacha20poly1305 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_encrypt__ScryptChacha20poly1305, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "encrypt__ScryptChacha20poly1305_KeyLen_get" "', argument " "1"" of type '" "encrypt__ScryptChacha20poly1305 *""'"); 
    }
    arg1 = reinterpret_cast< encrypt__ScryptChacha20poly1305 * >(argp1);
    result = (GoInt_) ((arg1)->KeyLen);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_encrypt__ScryptChacha20poly1305(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  encrypt__ScryptChacha20poly1305 *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_encrypt__ScryptChacha20poly1305.");
  result = (encrypt__ScryptChacha20poly1305 *)new encrypt__ScryptChacha20poly1305();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_encrypt__ScryptChacha20poly1305, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_encrypt__ScryptChacha20poly1305(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_encrypt__ScryptChacha20poly1305(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_encrypt__ScryptChacha20poly1305(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_encrypt__ScryptChacha20poly1305(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_encrypt__ScryptChacha20poly1305(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            encrypt__ScryptChacha20poly1305 * arg1 = (encrypt__ScryptChacha20poly1305 *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__Field_n_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__Field_n_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__Field *arg1 = (secp256k1go__Field *) 0 ;
    GoUint32_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__Field_n_set" "', argument " "1"" of type '" "secp256k1go__Field *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__Field * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secp256k1go__Field_n_set" "', argument " "2"" of type '" "GoUint32_ [10]""'"); 
    } 
    arg2 = reinterpret_cast< GoUint32_ * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)10; ++ii) *(GoUint32_ *)&arg1->n[ii] = *((GoUint32_ *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""n""' of type '""GoUint32_ [10]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__Field_n_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__Field_n_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__Field *arg1 = (secp256k1go__Field *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint32_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__Field_n_get" "', argument " "1"" of type '" "secp256k1go__Field *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__Field * >(argp1);
    result = (GoUint32_ *)(GoUint32_ *) ((arg1)->n);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_int, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_secp256k1go__Field(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  secp256k1go__Field *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_secp256k1go__Field.");
  result = (secp256k1go__Field *)new secp256k1go__Field();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_secp256k1go__Field, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_secp256k1go__Field(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_secp256k1go__Field(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_secp256k1go__Field(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_secp256k1go__Field(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_secp256k1go__Field(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            secp256k1go__Field * arg1 = (secp256k1go__Field *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__XY_X_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__XY_X_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__XY *arg1 = (secp256k1go__XY *) 0 ;
    secp256k1go__Field *arg2 = (secp256k1go__Field *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XY, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XY_X_set" "', argument " "1"" of type '" "secp256k1go__XY *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XY * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secp256k1go__XY_X_set" "', argument " "2"" of type '" "secp256k1go__Field *""'"); 
    }
    arg2 = reinterpret_cast< secp256k1go__Field * >(argp2);
    if (arg1) (arg1)->X = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__XY_X_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__XY_X_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__XY *arg1 = (secp256k1go__XY *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    secp256k1go__Field *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XY, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XY_X_get" "', argument " "1"" of type '" "secp256k1go__XY *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XY * >(argp1);
    result = (secp256k1go__Field *)& ((arg1)->X);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__XY_Y_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__XY_Y_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__XY *arg1 = (secp256k1go__XY *) 0 ;
    secp256k1go__Field *arg2 = (secp256k1go__Field *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XY, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XY_Y_set" "', argument " "1"" of type '" "secp256k1go__XY *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XY * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secp256k1go__XY_Y_set" "', argument " "2"" of type '" "secp256k1go__Field *""'"); 
    }
    arg2 = reinterpret_cast< secp256k1go__Field * >(argp2);
    if (arg1) (arg1)->Y = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__XY_Y_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__XY_Y_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__XY *arg1 = (secp256k1go__XY *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    secp256k1go__Field *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XY, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XY_Y_get" "', argument " "1"" of type '" "secp256k1go__XY *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XY * >(argp1);
    result = (secp256k1go__Field *)& ((arg1)->Y);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__XY_Infinity_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__XY_Infinity_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__XY *arg1 = (secp256k1go__XY *) 0 ;
    BOOL arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XY, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XY_Infinity_set" "', argument " "1"" of type '" "secp256k1go__XY *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XY * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "secp256k1go__XY_Infinity_set" "', argument " "2"" of type '" "BOOL""'");
    } 
    arg2 = static_cast< BOOL >(val2);
    if (arg1) (arg1)->Infinity = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__XY_Infinity_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__XY_Infinity_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__XY *arg1 = (secp256k1go__XY *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    BOOL result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XY, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XY_Infinity_get" "', argument " "1"" of type '" "secp256k1go__XY *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XY * >(argp1);
    result = (BOOL) ((arg1)->Infinity);
    jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_secp256k1go__XY(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  secp256k1go__XY *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_secp256k1go__XY.");
  result = (secp256k1go__XY *)new secp256k1go__XY();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_secp256k1go__XY, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_secp256k1go__XY(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_secp256k1go__XY(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_secp256k1go__XY(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_secp256k1go__XY(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_secp256k1go__XY(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            secp256k1go__XY * arg1 = (secp256k1go__XY *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__XYZ_X_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__XYZ_X_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    secp256k1go__Field *arg2 = (secp256k1go__Field *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_X_set" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secp256k1go__XYZ_X_set" "', argument " "2"" of type '" "secp256k1go__Field *""'"); 
    }
    arg2 = reinterpret_cast< secp256k1go__Field * >(argp2);
    if (arg1) (arg1)->X = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__XYZ_X_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__XYZ_X_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    secp256k1go__Field *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_X_get" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    result = (secp256k1go__Field *)& ((arg1)->X);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__XYZ_Y_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__XYZ_Y_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    secp256k1go__Field *arg2 = (secp256k1go__Field *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_Y_set" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secp256k1go__XYZ_Y_set" "', argument " "2"" of type '" "secp256k1go__Field *""'"); 
    }
    arg2 = reinterpret_cast< secp256k1go__Field * >(argp2);
    if (arg1) (arg1)->Y = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__XYZ_Y_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__XYZ_Y_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    secp256k1go__Field *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_Y_get" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    result = (secp256k1go__Field *)& ((arg1)->Y);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__XYZ_Z_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__XYZ_Z_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    secp256k1go__Field *arg2 = (secp256k1go__Field *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_Z_set" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "secp256k1go__XYZ_Z_set" "', argument " "2"" of type '" "secp256k1go__Field *""'"); 
    }
    arg2 = reinterpret_cast< secp256k1go__Field * >(argp2);
    if (arg1) (arg1)->Z = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__XYZ_Z_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__XYZ_Z_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    secp256k1go__Field *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_Z_get" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    result = (secp256k1go__Field *)& ((arg1)->Z);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_secp256k1go__Field, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_secp256k1go__XYZ_Infinity_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_secp256k1go__XYZ_Infinity_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    BOOL arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_Infinity_set" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "secp256k1go__XYZ_Infinity_set" "', argument " "2"" of type '" "BOOL""'");
    } 
    arg2 = static_cast< BOOL >(val2);
    if (arg1) (arg1)->Infinity = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_secp256k1go__XYZ_Infinity_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_secp256k1go__XYZ_Infinity_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    secp256k1go__XYZ *arg1 = (secp256k1go__XYZ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    BOOL result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_secp256k1go__XYZ, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "secp256k1go__XYZ_Infinity_get" "', argument " "1"" of type '" "secp256k1go__XYZ *""'"); 
    }
    arg1 = reinterpret_cast< secp256k1go__XYZ * >(argp1);
    result = (BOOL) ((arg1)->Infinity);
    jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_secp256k1go__XYZ(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  secp256k1go__XYZ *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_secp256k1go__XYZ.");
  result = (secp256k1go__XYZ *)new secp256k1go__XYZ();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_secp256k1go__XYZ, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_secp256k1go__XYZ(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_secp256k1go__XYZ(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_secp256k1go__XYZ(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_secp256k1go__XYZ(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_secp256k1go__XYZ(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            secp256k1go__XYZ * arg1 = (secp256k1go__XYZ *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cli__SendAmount_Addr_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cli__SendAmount_Addr_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cli__SendAmount *arg1 = (cli__SendAmount *) 0 ;
    GoString_ *arg2 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cli__SendAmount, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cli__SendAmount_Addr_set" "', argument " "1"" of type '" "cli__SendAmount *""'"); 
    }
    arg1 = reinterpret_cast< cli__SendAmount * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cli__SendAmount_Addr_set" "', argument " "2"" of type '" "GoString_ *""'"); 
    }
    arg2 = reinterpret_cast< GoString_ * >(argp2);
    if (arg1) (arg1)->Addr = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cli__SendAmount_Addr_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cli__SendAmount_Addr_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cli__SendAmount *arg1 = (cli__SendAmount *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoString_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cli__SendAmount, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cli__SendAmount_Addr_get" "', argument " "1"" of type '" "cli__SendAmount *""'"); 
    }
    arg1 = reinterpret_cast< cli__SendAmount * >(argp1);
    result = (GoString_ *)& ((arg1)->Addr);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoString_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_cli__SendAmount_Coins_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_cli__SendAmount_Coins_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    cli__SendAmount *arg1 = (cli__SendAmount *) 0 ;
    GoInt64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cli__SendAmount, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cli__SendAmount_Coins_set" "', argument " "1"" of type '" "cli__SendAmount *""'"); 
    }
    arg1 = reinterpret_cast< cli__SendAmount * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cli__SendAmount_Coins_set" "', argument " "2"" of type '" "GoInt64_""'");
    } 
    arg2 = static_cast< GoInt64_ >(val2);
    if (arg1) (arg1)->Coins = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_cli__SendAmount_Coins_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_cli__SendAmount_Coins_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    cli__SendAmount *arg1 = (cli__SendAmount *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_cli__SendAmount, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cli__SendAmount_Coins_get" "', argument " "1"" of type '" "cli__SendAmount *""'"); 
    }
    arg1 = reinterpret_cast< cli__SendAmount * >(argp1);
    result = (GoInt64_) ((arg1)->Coins);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_cli__SendAmount(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  cli__SendAmount *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_cli__SendAmount.");
  result = (cli__SendAmount *)new cli__SendAmount();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_cli__SendAmount, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_cli__SendAmount(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_cli__SendAmount(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_cli__SendAmount(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_cli__SendAmount(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_cli__SendAmount(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            cli__SendAmount * arg1 = (cli__SendAmount *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Transaction_Length_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Transaction_Length_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    GoInt32_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Length_set" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    ecode2 = SWIG_AsVal_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__Transaction_Length_set" "', argument " "2"" of type '" "GoInt32_""'");
    } 
    arg2 = static_cast< GoInt32_ >(val2);
    if (arg1) (arg1)->Length = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Transaction_Length_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Transaction_Length_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt32_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Length_get" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    result = (GoInt32_) ((arg1)->Length);
    jsresult = SWIG_From_int(static_cast< int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Transaction_Type_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Transaction_Type_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    GoInt8_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    signed char val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Type_set" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    ecode2 = SWIG_AsVal_signed_SS_char(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__Transaction_Type_set" "', argument " "2"" of type '" "GoInt8_""'");
    } 
    arg2 = static_cast< GoInt8_ >(val2);
    if (arg1) (arg1)->Type = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Transaction_Type_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Transaction_Type_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt8_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Type_get" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    result = (GoInt8_) ((arg1)->Type);
    jsresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Transaction_InnerHash_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Transaction_InnerHash_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_InnerHash_set" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__Transaction_InnerHash_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->InnerHash[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""InnerHash""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Transaction_InnerHash_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Transaction_InnerHash_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_InnerHash_get" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    result = (GoUint8_ *) ((arg1)->InnerHash);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Transaction_Sigs_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Transaction_Sigs_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    GoSlice_ *arg2 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Sigs_set" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__Transaction_Sigs_set" "', argument " "2"" of type '" "GoSlice_ *""'"); 
    }
    arg2 = reinterpret_cast< GoSlice_ * >(argp2);
    if (arg1) (arg1)->Sigs = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Transaction_Sigs_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Transaction_Sigs_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoSlice_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Sigs_get" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    result = (GoSlice_ *)& ((arg1)->Sigs);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Transaction_In_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Transaction_In_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    GoSlice_ *arg2 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_In_set" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__Transaction_In_set" "', argument " "2"" of type '" "GoSlice_ *""'"); 
    }
    arg2 = reinterpret_cast< GoSlice_ * >(argp2);
    if (arg1) (arg1)->In = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Transaction_In_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Transaction_In_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoSlice_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_In_get" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    result = (GoSlice_ *)& ((arg1)->In);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Transaction_Out_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Transaction_Out_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    GoSlice_ *arg2 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Out_set" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__Transaction_Out_set" "', argument " "2"" of type '" "GoSlice_ *""'"); 
    }
    arg2 = reinterpret_cast< GoSlice_ * >(argp2);
    if (arg1) (arg1)->Out = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Transaction_Out_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Transaction_Out_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Transaction *arg1 = (coin__Transaction *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoSlice_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Transaction, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Transaction_Out_get" "', argument " "1"" of type '" "coin__Transaction *""'"); 
    }
    arg1 = reinterpret_cast< coin__Transaction * >(argp1);
    result = (GoSlice_ *)& ((arg1)->Out);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__Transaction(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__Transaction *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__Transaction.");
  result = (coin__Transaction *)new coin__Transaction();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__Transaction, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__Transaction(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__Transaction(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__Transaction(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__Transaction(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__Transaction(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__Transaction * arg1 = (coin__Transaction *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__TransactionOutput_Address_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__TransactionOutput_Address_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
    cipher__Address *arg2 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionOutput_Address_set" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
    }
    arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__TransactionOutput_Address_set" "', argument " "2"" of type '" "cipher__Address *""'"); 
    }
    arg2 = reinterpret_cast< cipher__Address * >(argp2);
    if (arg1) (arg1)->Address = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__TransactionOutput_Address_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__TransactionOutput_Address_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher__Address *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionOutput_Address_get" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
    }
    arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
    result = (cipher__Address *)& ((arg1)->Address);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__TransactionOutput_Coins_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__TransactionOutput_Coins_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionOutput_Coins_set" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
    }
    arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__TransactionOutput_Coins_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Coins = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__TransactionOutput_Coins_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__TransactionOutput_Coins_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionOutput_Coins_get" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
    }
    arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
    result = (GoUint64_) ((arg1)->Coins);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__TransactionOutput_Hours_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__TransactionOutput_Hours_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionOutput_Hours_set" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
    }
    arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__TransactionOutput_Hours_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Hours = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__TransactionOutput_Hours_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__TransactionOutput_Hours_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__TransactionOutput *arg1 = (coin__TransactionOutput *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__TransactionOutput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__TransactionOutput_Hours_get" "', argument " "1"" of type '" "coin__TransactionOutput *""'"); 
    }
    arg1 = reinterpret_cast< coin__TransactionOutput * >(argp1);
    result = (GoUint64_) ((arg1)->Hours);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__TransactionOutput(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__TransactionOutput *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__TransactionOutput.");
  result = (coin__TransactionOutput *)new coin__TransactionOutput();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__TransactionOutput, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__TransactionOutput(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__TransactionOutput(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__TransactionOutput(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__TransactionOutput(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__TransactionOutput(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__TransactionOutput * arg1 = (coin__TransactionOutput *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockHeader_Version_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockHeader_Version_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    GoUint32_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_Version_set" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__BlockHeader_Version_set" "', argument " "2"" of type '" "GoUint32_""'");
    } 
    arg2 = static_cast< GoUint32_ >(val2);
    if (arg1) (arg1)->Version = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockHeader_Version_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockHeader_Version_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint32_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_Version_get" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    result = (GoUint32_) ((arg1)->Version);
    jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockHeader_Time_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockHeader_Time_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_Time_set" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__BlockHeader_Time_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Time = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockHeader_Time_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockHeader_Time_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_Time_get" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    result = (GoUint64_) ((arg1)->Time);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockHeader_BkSeq_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockHeader_BkSeq_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_BkSeq_set" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__BlockHeader_BkSeq_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->BkSeq = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockHeader_BkSeq_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockHeader_BkSeq_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_BkSeq_get" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    result = (GoUint64_) ((arg1)->BkSeq);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockHeader_Fee_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockHeader_Fee_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_Fee_set" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__BlockHeader_Fee_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Fee = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockHeader_Fee_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockHeader_Fee_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_Fee_get" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    result = (GoUint64_) ((arg1)->Fee);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockHeader_PrevHash_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockHeader_PrevHash_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_PrevHash_set" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__BlockHeader_PrevHash_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->PrevHash[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""PrevHash""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockHeader_PrevHash_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockHeader_PrevHash_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_PrevHash_get" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    result = (GoUint8_ *) ((arg1)->PrevHash);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockHeader_BodyHash_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockHeader_BodyHash_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_BodyHash_set" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__BlockHeader_BodyHash_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->BodyHash[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""BodyHash""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockHeader_BodyHash_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockHeader_BodyHash_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_BodyHash_get" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    result = (GoUint8_ *) ((arg1)->BodyHash);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockHeader_UxHash_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockHeader_UxHash_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_UxHash_set" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__BlockHeader_UxHash_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->UxHash[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""UxHash""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockHeader_UxHash_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockHeader_UxHash_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockHeader *arg1 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockHeader_UxHash_get" "', argument " "1"" of type '" "coin__BlockHeader *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockHeader * >(argp1);
    result = (GoUint8_ *) ((arg1)->UxHash);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__BlockHeader(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__BlockHeader *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__BlockHeader.");
  result = (coin__BlockHeader *)new coin__BlockHeader();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__BlockHeader, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__BlockHeader(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__BlockHeader(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__BlockHeader(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__BlockHeader(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__BlockHeader(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__BlockHeader * arg1 = (coin__BlockHeader *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__BlockBody_Transactions_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__BlockBody_Transactions_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__BlockBody *arg1 = (coin__BlockBody *) 0 ;
    coin__Transactions *arg2 = (coin__Transactions *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockBody_Transactions_set" "', argument " "1"" of type '" "coin__BlockBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockBody * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__BlockBody_Transactions_set" "', argument " "2"" of type '" "coin__Transactions *""'"); 
    }
    arg2 = reinterpret_cast< coin__Transactions * >(argp2);
    if (arg1) (arg1)->Transactions = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__BlockBody_Transactions_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__BlockBody_Transactions_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__BlockBody *arg1 = (coin__BlockBody *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__Transactions *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__BlockBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__BlockBody_Transactions_get" "', argument " "1"" of type '" "coin__BlockBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__BlockBody * >(argp1);
    result = (coin__Transactions *)& ((arg1)->Transactions);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__BlockBody(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__BlockBody *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__BlockBody.");
  result = (coin__BlockBody *)new coin__BlockBody();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__BlockBody, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__BlockBody(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__BlockBody(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__BlockBody(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__BlockBody(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__BlockBody(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__BlockBody * arg1 = (coin__BlockBody *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Block_Head_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Block_Head_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Block *arg1 = (coin__Block *) 0 ;
    coin__BlockHeader *arg2 = (coin__BlockHeader *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Block, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Block_Head_set" "', argument " "1"" of type '" "coin__Block *""'"); 
    }
    arg1 = reinterpret_cast< coin__Block * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__Block_Head_set" "', argument " "2"" of type '" "coin__BlockHeader *""'"); 
    }
    arg2 = reinterpret_cast< coin__BlockHeader * >(argp2);
    if (arg1) (arg1)->Head = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Block_Head_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Block_Head_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Block *arg1 = (coin__Block *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__BlockHeader *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Block, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Block_Head_get" "', argument " "1"" of type '" "coin__Block *""'"); 
    }
    arg1 = reinterpret_cast< coin__Block * >(argp1);
    result = (coin__BlockHeader *)& ((arg1)->Head);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__BlockHeader, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__Block_Body_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__Block_Body_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__Block *arg1 = (coin__Block *) 0 ;
    coin__BlockBody *arg2 = (coin__BlockBody *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Block, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Block_Body_set" "', argument " "1"" of type '" "coin__Block *""'"); 
    }
    arg1 = reinterpret_cast< coin__Block * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_coin__BlockBody, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__Block_Body_set" "', argument " "2"" of type '" "coin__BlockBody *""'"); 
    }
    arg2 = reinterpret_cast< coin__BlockBody * >(argp2);
    if (arg1) (arg1)->Body = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__Block_Body_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__Block_Body_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__Block *arg1 = (coin__Block *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__BlockBody *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__Block, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__Block_Body_get" "', argument " "1"" of type '" "coin__Block *""'"); 
    }
    arg1 = reinterpret_cast< coin__Block * >(argp1);
    result = (coin__BlockBody *)& ((arg1)->Body);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__BlockBody, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__Block(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__Block *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__Block.");
  result = (coin__Block *)new coin__Block();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__Block, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__Block(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__Block(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__Block(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__Block(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__Block(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__Block * arg1 = (coin__Block *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__SignedBlock__unnamed_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__SignedBlock__unnamed_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__SignedBlock *arg1 = (coin__SignedBlock *) 0 ;
    coin__Block *arg2 = (coin__Block *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__SignedBlock, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__SignedBlock__unnamed_set" "', argument " "1"" of type '" "coin__SignedBlock *""'"); 
    }
    arg1 = reinterpret_cast< coin__SignedBlock * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_coin__Block, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__SignedBlock__unnamed_set" "', argument " "2"" of type '" "coin__Block *""'"); 
    }
    arg2 = reinterpret_cast< coin__Block * >(argp2);
    if (arg1) (arg1)->_unnamed = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__SignedBlock__unnamed_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__SignedBlock__unnamed_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__SignedBlock *arg1 = (coin__SignedBlock *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__Block *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__SignedBlock, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__SignedBlock__unnamed_get" "', argument " "1"" of type '" "coin__SignedBlock *""'"); 
    }
    arg1 = reinterpret_cast< coin__SignedBlock * >(argp1);
    result = (coin__Block *)& ((arg1)->_unnamed);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__Block, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__SignedBlock_Sig_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__SignedBlock_Sig_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__SignedBlock *arg1 = (coin__SignedBlock *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__SignedBlock, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__SignedBlock_Sig_set" "', argument " "1"" of type '" "coin__SignedBlock *""'"); 
    }
    arg1 = reinterpret_cast< coin__SignedBlock * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__SignedBlock_Sig_set" "', argument " "2"" of type '" "unsigned char [65]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)65; ++ii) *(unsigned char *)&arg1->Sig[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Sig""' of type '""unsigned char [65]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__SignedBlock_Sig_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__SignedBlock_Sig_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__SignedBlock *arg1 = (coin__SignedBlock *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__SignedBlock, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__SignedBlock_Sig_get" "', argument " "1"" of type '" "coin__SignedBlock *""'"); 
    }
    arg1 = reinterpret_cast< coin__SignedBlock * >(argp1);
    result = (GoUint8_ *) ((arg1)->Sig);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__SignedBlock(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__SignedBlock *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__SignedBlock.");
  result = (coin__SignedBlock *)new coin__SignedBlock();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__SignedBlock, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__SignedBlock(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__SignedBlock(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__SignedBlock(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__SignedBlock(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__SignedBlock(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__SignedBlock * arg1 = (coin__SignedBlock *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxHead_Time_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxHead_Time_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxHead *arg1 = (coin__UxHead *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxHead, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxHead_Time_set" "', argument " "1"" of type '" "coin__UxHead *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxHead * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__UxHead_Time_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Time = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxHead_Time_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxHead_Time_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxHead *arg1 = (coin__UxHead *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxHead, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxHead_Time_get" "', argument " "1"" of type '" "coin__UxHead *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxHead * >(argp1);
    result = (GoUint64_) ((arg1)->Time);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxHead_BkSeq_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxHead_BkSeq_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxHead *arg1 = (coin__UxHead *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxHead, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxHead_BkSeq_set" "', argument " "1"" of type '" "coin__UxHead *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxHead * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__UxHead_BkSeq_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->BkSeq = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxHead_BkSeq_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxHead_BkSeq_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxHead *arg1 = (coin__UxHead *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxHead, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxHead_BkSeq_get" "', argument " "1"" of type '" "coin__UxHead *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxHead * >(argp1);
    result = (GoUint64_) ((arg1)->BkSeq);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__UxHead(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__UxHead *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__UxHead.");
  result = (coin__UxHead *)new coin__UxHead();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__UxHead, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__UxHead(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__UxHead(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__UxHead(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__UxHead(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__UxHead(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__UxHead * arg1 = (coin__UxHead *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxBody_SrcTransaction_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxBody_SrcTransaction_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_SrcTransaction_set" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__UxBody_SrcTransaction_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->SrcTransaction[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""SrcTransaction""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxBody_SrcTransaction_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxBody_SrcTransaction_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_SrcTransaction_get" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    result = (GoUint8_ *) ((arg1)->SrcTransaction);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxBody_Address_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxBody_Address_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    cipher__Address *arg2 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_Address_set" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__UxBody_Address_set" "', argument " "2"" of type '" "cipher__Address *""'"); 
    }
    arg2 = reinterpret_cast< cipher__Address * >(argp2);
    if (arg1) (arg1)->Address = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxBody_Address_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxBody_Address_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher__Address *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_Address_get" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    result = (cipher__Address *)& ((arg1)->Address);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxBody_Coins_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxBody_Coins_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_Coins_set" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__UxBody_Coins_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Coins = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxBody_Coins_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxBody_Coins_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_Coins_get" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    result = (GoUint64_) ((arg1)->Coins);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxBody_Hours_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxBody_Hours_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_Hours_set" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "coin__UxBody_Hours_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Hours = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxBody_Hours_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxBody_Hours_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxBody *arg1 = (coin__UxBody *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxBody_Hours_get" "', argument " "1"" of type '" "coin__UxBody *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxBody * >(argp1);
    result = (GoUint64_) ((arg1)->Hours);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__UxBody(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__UxBody *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__UxBody.");
  result = (coin__UxBody *)new coin__UxBody();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__UxBody, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__UxBody(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__UxBody(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__UxBody(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__UxBody(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__UxBody(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__UxBody * arg1 = (coin__UxBody *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxOut_Head_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxOut_Head_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxOut *arg1 = (coin__UxOut *) 0 ;
    coin__UxHead *arg2 = (coin__UxHead *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxOut, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxOut_Head_set" "', argument " "1"" of type '" "coin__UxOut *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxOut * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_coin__UxHead, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__UxOut_Head_set" "', argument " "2"" of type '" "coin__UxHead *""'"); 
    }
    arg2 = reinterpret_cast< coin__UxHead * >(argp2);
    if (arg1) (arg1)->Head = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxOut_Head_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxOut_Head_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxOut *arg1 = (coin__UxOut *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__UxHead *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxOut, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxOut_Head_get" "', argument " "1"" of type '" "coin__UxOut *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxOut * >(argp1);
    result = (coin__UxHead *)& ((arg1)->Head);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__UxHead, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_coin__UxOut_Body_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_coin__UxOut_Body_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    coin__UxOut *arg1 = (coin__UxOut *) 0 ;
    coin__UxBody *arg2 = (coin__UxBody *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxOut, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxOut_Body_set" "', argument " "1"" of type '" "coin__UxOut *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxOut * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_coin__UxBody, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "coin__UxOut_Body_set" "', argument " "2"" of type '" "coin__UxBody *""'"); 
    }
    arg2 = reinterpret_cast< coin__UxBody * >(argp2);
    if (arg1) (arg1)->Body = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_coin__UxOut_Body_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_coin__UxOut_Body_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    coin__UxOut *arg1 = (coin__UxOut *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__UxBody *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_coin__UxOut, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "coin__UxOut_Body_get" "', argument " "1"" of type '" "coin__UxOut *""'"); 
    }
    arg1 = reinterpret_cast< coin__UxOut * >(argp1);
    result = (coin__UxBody *)& ((arg1)->Body);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__UxBody, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_coin__UxOut(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  coin__UxOut *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_coin__UxOut.");
  result = (coin__UxOut *)new coin__UxOut();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_coin__UxOut, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_coin__UxOut(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_coin__UxOut(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_coin__UxOut(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_coin__UxOut(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_coin__UxOut(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            coin__UxOut * arg1 = (coin__UxOut *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_httphelper__Address__unnamed_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_httphelper__Address__unnamed_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    httphelper__Address *arg1 = (httphelper__Address *) 0 ;
    cipher__Address *arg2 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_httphelper__Address, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "httphelper__Address__unnamed_set" "', argument " "1"" of type '" "httphelper__Address *""'"); 
    }
    arg1 = reinterpret_cast< httphelper__Address * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "httphelper__Address__unnamed_set" "', argument " "2"" of type '" "cipher__Address *""'"); 
    }
    arg2 = reinterpret_cast< cipher__Address * >(argp2);
    if (arg1) (arg1)->_unnamed = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_httphelper__Address__unnamed_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_httphelper__Address__unnamed_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    httphelper__Address *arg1 = (httphelper__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher__Address *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_httphelper__Address, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "httphelper__Address__unnamed_get" "', argument " "1"" of type '" "httphelper__Address *""'"); 
    }
    arg1 = reinterpret_cast< httphelper__Address * >(argp1);
    result = (cipher__Address *)& ((arg1)->_unnamed);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_httphelper__Address(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  httphelper__Address *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_httphelper__Address.");
  result = (httphelper__Address *)new httphelper__Address();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_httphelper__Address, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_httphelper__Address(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_httphelper__Address(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_httphelper__Address(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_httphelper__Address(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_httphelper__Address(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            httphelper__Address * arg1 = (httphelper__Address *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_httphelper__SHA256__unnamed_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_httphelper__SHA256__unnamed_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    httphelper__SHA256 *arg1 = (httphelper__SHA256 *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_httphelper__SHA256, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "httphelper__SHA256__unnamed_set" "', argument " "1"" of type '" "httphelper__SHA256 *""'"); 
    }
    arg1 = reinterpret_cast< httphelper__SHA256 * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "httphelper__SHA256__unnamed_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->_unnamed[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""_unnamed""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_httphelper__SHA256__unnamed_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_httphelper__SHA256__unnamed_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    httphelper__SHA256 *arg1 = (httphelper__SHA256 *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_httphelper__SHA256, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "httphelper__SHA256__unnamed_get" "', argument " "1"" of type '" "httphelper__SHA256 *""'"); 
    }
    arg1 = reinterpret_cast< httphelper__SHA256 * >(argp1);
    result = (GoUint8_ *) ((arg1)->_unnamed);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_httphelper__SHA256(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  httphelper__SHA256 *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_httphelper__SHA256.");
  result = (httphelper__SHA256 *)new httphelper__SHA256();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_httphelper__SHA256, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_httphelper__SHA256(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_httphelper__SHA256(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_httphelper__SHA256(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_httphelper__SHA256(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_httphelper__SHA256(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            httphelper__SHA256 * arg1 = (httphelper__SHA256 *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__Balance_Coins_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__Balance_Coins_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__Balance *arg1 = (wallet__Balance *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Balance_Coins_set" "', argument " "1"" of type '" "wallet__Balance *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Balance * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "wallet__Balance_Coins_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Coins = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__Balance_Coins_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__Balance_Coins_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__Balance *arg1 = (wallet__Balance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Balance_Coins_get" "', argument " "1"" of type '" "wallet__Balance *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Balance * >(argp1);
    result = (GoUint64_) ((arg1)->Coins);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__Balance_Hours_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__Balance_Hours_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__Balance *arg1 = (wallet__Balance *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Balance_Hours_set" "', argument " "1"" of type '" "wallet__Balance *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Balance * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "wallet__Balance_Hours_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Hours = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__Balance_Hours_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__Balance_Hours_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__Balance *arg1 = (wallet__Balance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Balance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Balance_Hours_get" "', argument " "1"" of type '" "wallet__Balance *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Balance * >(argp1);
    result = (GoUint64_) ((arg1)->Hours);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_wallet__Balance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  wallet__Balance *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_wallet__Balance.");
  result = (wallet__Balance *)new wallet__Balance();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_wallet__Balance, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_wallet__Balance(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_wallet__Balance(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_wallet__Balance(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_wallet__Balance(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_wallet__Balance(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            wallet__Balance * arg1 = (wallet__Balance *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__BalancePair_Confirmed_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__BalancePair_Confirmed_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__BalancePair *arg1 = (wallet__BalancePair *) 0 ;
    wallet__Balance *arg2 = (wallet__Balance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__BalancePair, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__BalancePair_Confirmed_set" "', argument " "1"" of type '" "wallet__BalancePair *""'"); 
    }
    arg1 = reinterpret_cast< wallet__BalancePair * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_wallet__Balance, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__BalancePair_Confirmed_set" "', argument " "2"" of type '" "wallet__Balance *""'"); 
    }
    arg2 = reinterpret_cast< wallet__Balance * >(argp2);
    if (arg1) (arg1)->Confirmed = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__BalancePair_Confirmed_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__BalancePair_Confirmed_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__BalancePair *arg1 = (wallet__BalancePair *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    wallet__Balance *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__BalancePair, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__BalancePair_Confirmed_get" "', argument " "1"" of type '" "wallet__BalancePair *""'"); 
    }
    arg1 = reinterpret_cast< wallet__BalancePair * >(argp1);
    result = (wallet__Balance *)& ((arg1)->Confirmed);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_wallet__Balance, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__BalancePair_Predicted_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__BalancePair_Predicted_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__BalancePair *arg1 = (wallet__BalancePair *) 0 ;
    wallet__Balance *arg2 = (wallet__Balance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__BalancePair, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__BalancePair_Predicted_set" "', argument " "1"" of type '" "wallet__BalancePair *""'"); 
    }
    arg1 = reinterpret_cast< wallet__BalancePair * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_wallet__Balance, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__BalancePair_Predicted_set" "', argument " "2"" of type '" "wallet__Balance *""'"); 
    }
    arg2 = reinterpret_cast< wallet__Balance * >(argp2);
    if (arg1) (arg1)->Predicted = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__BalancePair_Predicted_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__BalancePair_Predicted_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__BalancePair *arg1 = (wallet__BalancePair *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    wallet__Balance *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__BalancePair, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__BalancePair_Predicted_get" "', argument " "1"" of type '" "wallet__BalancePair *""'"); 
    }
    arg1 = reinterpret_cast< wallet__BalancePair * >(argp1);
    result = (wallet__Balance *)& ((arg1)->Predicted);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_wallet__Balance, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_wallet__BalancePair(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  wallet__BalancePair *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_wallet__BalancePair.");
  result = (wallet__BalancePair *)new wallet__BalancePair();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_wallet__BalancePair, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_wallet__BalancePair(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_wallet__BalancePair(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_wallet__BalancePair(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_wallet__BalancePair(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_wallet__BalancePair(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            wallet__BalancePair * arg1 = (wallet__BalancePair *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__Entry_Address_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__Entry_Address_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__Entry *arg1 = (wallet__Entry *) 0 ;
    cipher__Address *arg2 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Entry_Address_set" "', argument " "1"" of type '" "wallet__Entry *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Entry * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__Entry_Address_set" "', argument " "2"" of type '" "cipher__Address *""'"); 
    }
    arg2 = reinterpret_cast< cipher__Address * >(argp2);
    if (arg1) (arg1)->Address = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__Entry_Address_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__Entry_Address_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__Entry *arg1 = (wallet__Entry *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher__Address *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Entry_Address_get" "', argument " "1"" of type '" "wallet__Entry *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Entry * >(argp1);
    result = (cipher__Address *)& ((arg1)->Address);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__Entry_Public_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__Entry_Public_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__Entry *arg1 = (wallet__Entry *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Entry_Public_set" "', argument " "1"" of type '" "wallet__Entry *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Entry * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__Entry_Public_set" "', argument " "2"" of type '" "unsigned char [33]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)33; ++ii) *(unsigned char *)&arg1->Public[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Public""' of type '""unsigned char [33]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__Entry_Public_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__Entry_Public_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__Entry *arg1 = (wallet__Entry *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Entry_Public_get" "', argument " "1"" of type '" "wallet__Entry *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Entry * >(argp1);
    result = (GoUint8_ *) ((arg1)->Public);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__Entry_Secret_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__Entry_Secret_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__Entry *arg1 = (wallet__Entry *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Entry_Secret_set" "', argument " "1"" of type '" "wallet__Entry *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Entry * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__Entry_Secret_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->Secret[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Secret""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__Entry_Secret_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__Entry_Secret_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__Entry *arg1 = (wallet__Entry *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Entry, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Entry_Secret_get" "', argument " "1"" of type '" "wallet__Entry *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Entry * >(argp1);
    result = (GoUint8_ *) ((arg1)->Secret);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_wallet__Entry(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  wallet__Entry *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_wallet__Entry.");
  result = (wallet__Entry *)new wallet__Entry();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_wallet__Entry, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_wallet__Entry(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_wallet__Entry(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_wallet__Entry(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_wallet__Entry(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_wallet__Entry(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            wallet__Entry * arg1 = (wallet__Entry *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__Note_TxID_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__Note_TxID_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__Note *arg1 = (wallet__Note *) 0 ;
    GoString_ *arg2 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Note, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Note_TxID_set" "', argument " "1"" of type '" "wallet__Note *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Note * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__Note_TxID_set" "', argument " "2"" of type '" "GoString_ *""'"); 
    }
    arg2 = reinterpret_cast< GoString_ * >(argp2);
    if (arg1) (arg1)->TxID = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__Note_TxID_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__Note_TxID_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__Note *arg1 = (wallet__Note *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoString_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Note, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Note_TxID_get" "', argument " "1"" of type '" "wallet__Note *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Note * >(argp1);
    result = (GoString_ *)& ((arg1)->TxID);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoString_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__Note_Value_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__Note_Value_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__Note *arg1 = (wallet__Note *) 0 ;
    GoString_ *arg2 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Note, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Note_Value_set" "', argument " "1"" of type '" "wallet__Note *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Note * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__Note_Value_set" "', argument " "2"" of type '" "GoString_ *""'"); 
    }
    arg2 = reinterpret_cast< GoString_ * >(argp2);
    if (arg1) (arg1)->Value = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__Note_Value_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__Note_Value_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__Note *arg1 = (wallet__Note *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoString_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__Note, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__Note_Value_get" "', argument " "1"" of type '" "wallet__Note *""'"); 
    }
    arg1 = reinterpret_cast< wallet__Note * >(argp1);
    result = (GoString_ *)& ((arg1)->Value);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoString_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_wallet__Note(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  wallet__Note *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_wallet__Note.");
  result = (wallet__Note *)new wallet__Note();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_wallet__Note, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_wallet__Note(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_wallet__Note(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_wallet__Note(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_wallet__Note(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_wallet__Note(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            wallet__Note * arg1 = (wallet__Note *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__ReadableNote_TransactionID_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__ReadableNote_TransactionID_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__ReadableNote *arg1 = (wallet__ReadableNote *) 0 ;
    GoString_ *arg2 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__ReadableNote, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__ReadableNote_TransactionID_set" "', argument " "1"" of type '" "wallet__ReadableNote *""'"); 
    }
    arg1 = reinterpret_cast< wallet__ReadableNote * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__ReadableNote_TransactionID_set" "', argument " "2"" of type '" "GoString_ *""'"); 
    }
    arg2 = reinterpret_cast< GoString_ * >(argp2);
    if (arg1) (arg1)->TransactionID = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__ReadableNote_TransactionID_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__ReadableNote_TransactionID_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__ReadableNote *arg1 = (wallet__ReadableNote *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoString_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__ReadableNote, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__ReadableNote_TransactionID_get" "', argument " "1"" of type '" "wallet__ReadableNote *""'"); 
    }
    arg1 = reinterpret_cast< wallet__ReadableNote * >(argp1);
    result = (GoString_ *)& ((arg1)->TransactionID);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoString_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_wallet__ReadableNote_ActualNote_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_wallet__ReadableNote_ActualNote_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    wallet__ReadableNote *arg1 = (wallet__ReadableNote *) 0 ;
    GoString_ *arg2 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__ReadableNote, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__ReadableNote_ActualNote_set" "', argument " "1"" of type '" "wallet__ReadableNote *""'"); 
    }
    arg1 = reinterpret_cast< wallet__ReadableNote * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "wallet__ReadableNote_ActualNote_set" "', argument " "2"" of type '" "GoString_ *""'"); 
    }
    arg2 = reinterpret_cast< GoString_ * >(argp2);
    if (arg1) (arg1)->ActualNote = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_wallet__ReadableNote_ActualNote_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_wallet__ReadableNote_ActualNote_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    wallet__ReadableNote *arg1 = (wallet__ReadableNote *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoString_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_wallet__ReadableNote, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "wallet__ReadableNote_ActualNote_get" "', argument " "1"" of type '" "wallet__ReadableNote *""'"); 
    }
    arg1 = reinterpret_cast< wallet__ReadableNote * >(argp1);
    result = (GoString_ *)& ((arg1)->ActualNote);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoString_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_wallet__ReadableNote(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  wallet__ReadableNote *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_wallet__ReadableNote.");
  result = (wallet__ReadableNote *)new wallet__ReadableNote();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_wallet__ReadableNote, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_wallet__ReadableNote(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_wallet__ReadableNote(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_wallet__ReadableNote(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_wallet__ReadableNote(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_wallet__ReadableNote(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            wallet__ReadableNote * arg1 = (wallet__ReadableNote *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_transaction__UxBalance_Hash_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_transaction__UxBalance_Hash_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Hash_set" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "transaction__UxBalance_Hash_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->Hash[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""Hash""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_transaction__UxBalance_Hash_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_transaction__UxBalance_Hash_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Hash_get" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    result = (GoUint8_ *) ((arg1)->Hash);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_transaction__UxBalance_BkSeq_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_transaction__UxBalance_BkSeq_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_BkSeq_set" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "transaction__UxBalance_BkSeq_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->BkSeq = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_transaction__UxBalance_BkSeq_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_transaction__UxBalance_BkSeq_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_BkSeq_get" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    result = (GoUint64_) ((arg1)->BkSeq);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_transaction__UxBalance_Address_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_transaction__UxBalance_Address_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    cipher__Address *arg2 = (cipher__Address *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Address_set" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_cipher__Address, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "transaction__UxBalance_Address_set" "', argument " "2"" of type '" "cipher__Address *""'"); 
    }
    arg2 = reinterpret_cast< cipher__Address * >(argp2);
    if (arg1) (arg1)->Address = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_transaction__UxBalance_Address_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_transaction__UxBalance_Address_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    cipher__Address *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Address_get" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    result = (cipher__Address *)& ((arg1)->Address);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cipher__Address, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_transaction__UxBalance_Coins_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_transaction__UxBalance_Coins_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Coins_set" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "transaction__UxBalance_Coins_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Coins = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_transaction__UxBalance_Coins_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_transaction__UxBalance_Coins_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Coins_get" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    result = (GoUint64_) ((arg1)->Coins);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_transaction__UxBalance_Hours_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_transaction__UxBalance_Hours_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Hours_set" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "transaction__UxBalance_Hours_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->Hours = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_transaction__UxBalance_Hours_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_transaction__UxBalance_Hours_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_Hours_get" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    result = (GoUint64_) ((arg1)->Hours);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_transaction__UxBalance_InitialHours_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_transaction__UxBalance_InitialHours_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    GoUint64_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_InitialHours_set" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "transaction__UxBalance_InitialHours_set" "', argument " "2"" of type '" "GoUint64_""'");
    } 
    arg2 = static_cast< GoUint64_ >(val2);
    if (arg1) (arg1)->InitialHours = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_transaction__UxBalance_InitialHours_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_transaction__UxBalance_InitialHours_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint64_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_InitialHours_get" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    result = (GoUint64_) ((arg1)->InitialHours);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_transaction__UxBalance_SrcTransaction_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_transaction__UxBalance_SrcTransaction_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    GoUint8_ *arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_SrcTransaction_set" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_unsigned_char, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "transaction__UxBalance_SrcTransaction_set" "', argument " "2"" of type '" "unsigned char [32]""'"); 
    } 
    arg2 = reinterpret_cast< unsigned char * >(argp2);
    {
      if (arg2) {
        size_t ii = 0;
        for (; ii < (size_t)32; ++ii) *(unsigned char *)&arg1->SrcTransaction[ii] = *((unsigned char *)arg2 + ii);
      } else {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""SrcTransaction""' of type '""unsigned char [32]""'");
      }
    }
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_transaction__UxBalance_SrcTransaction_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_transaction__UxBalance_SrcTransaction_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    transaction__UxBalance *arg1 = (transaction__UxBalance *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint8_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_transaction__UxBalance, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "transaction__UxBalance_SrcTransaction_get" "', argument " "1"" of type '" "transaction__UxBalance *""'"); 
    }
    arg1 = reinterpret_cast< transaction__UxBalance * >(argp1);
    result = (GoUint8_ *) ((arg1)->SrcTransaction);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_transaction__UxBalance(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  transaction__UxBalance *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_transaction__UxBalance.");
  result = (transaction__UxBalance *)new transaction__UxBalance();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_transaction__UxBalance, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_transaction__UxBalance(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_transaction__UxBalance(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_transaction__UxBalance(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_transaction__UxBalance(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_transaction__UxBalance(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            transaction__UxBalance * arg1 = (transaction__UxBalance *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_api__TransactionInput_UxOut_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_api__TransactionInput_UxOut_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    api__TransactionInput *arg1 = (api__TransactionInput *) 0 ;
    coin__UxOut *arg2 = (coin__UxOut *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__TransactionInput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__TransactionInput_UxOut_set" "', argument " "1"" of type '" "api__TransactionInput *""'"); 
    }
    arg1 = reinterpret_cast< api__TransactionInput * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_coin__UxOut, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "api__TransactionInput_UxOut_set" "', argument " "2"" of type '" "coin__UxOut *""'"); 
    }
    arg2 = reinterpret_cast< coin__UxOut * >(argp2);
    if (arg1) (arg1)->UxOut = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_api__TransactionInput_UxOut_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_api__TransactionInput_UxOut_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    api__TransactionInput *arg1 = (api__TransactionInput *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    coin__UxOut *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__TransactionInput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__TransactionInput_UxOut_get" "', argument " "1"" of type '" "api__TransactionInput *""'"); 
    }
    arg1 = reinterpret_cast< api__TransactionInput * >(argp1);
    result = (coin__UxOut *)& ((arg1)->UxOut);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_coin__UxOut, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_api__TransactionInput_CalculatedHours_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_api__TransactionInput_CalculatedHours_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    api__TransactionInput *arg1 = (api__TransactionInput *) 0 ;
    GoUint_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__TransactionInput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__TransactionInput_CalculatedHours_set" "', argument " "1"" of type '" "api__TransactionInput *""'"); 
    }
    arg1 = reinterpret_cast< api__TransactionInput * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "api__TransactionInput_CalculatedHours_set" "', argument " "2"" of type '" "GoUint_""'");
    } 
    arg2 = static_cast< GoUint_ >(val2);
    if (arg1) (arg1)->CalculatedHours = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_api__TransactionInput_CalculatedHours_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_api__TransactionInput_CalculatedHours_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    api__TransactionInput *arg1 = (api__TransactionInput *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoUint_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_api__TransactionInput, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "api__TransactionInput_CalculatedHours_get" "', argument " "1"" of type '" "api__TransactionInput *""'"); 
    }
    arg1 = reinterpret_cast< api__TransactionInput * >(argp1);
    result = (GoUint_) ((arg1)->CalculatedHours);
    jsresult = SWIG_From_unsigned_SS_long_SS_long(static_cast< unsigned long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_api__TransactionInput(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  api__TransactionInput *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_api__TransactionInput.");
  result = (api__TransactionInput *)new api__TransactionInput();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_api__TransactionInput, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_api__TransactionInput(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_api__TransactionInput(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_api__TransactionInput(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_api__TransactionInput(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_api__TransactionInput(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            api__TransactionInput * arg1 = (api__TransactionInput *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_OK(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_OK(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ERROR(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ERROR(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x7FFFFFFF));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_BAD_HANDLE(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_BAD_HANDLE(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x7F000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_INVALID_TIMESTRING(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_INVALID_TIMESTRING(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x7F000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_API(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_API(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x01000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_CIPHER(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_CIPHER(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_CLI(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_CLI(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x03000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_COIN(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_COIN(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_CONSENSUS(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_CONSENSUS(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x05000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_DAEMON(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_DAEMON(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_GUI(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_GUI(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x07000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_SKYCOIN(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_SKYCOIN(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x08000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_UTIL(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_UTIL(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_VISOR(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_VISOR(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_WALLET(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_WALLET(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_PARAMS(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_PARAMS(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0C000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_PKG_LIBCGO(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_PKG_LIBCGO(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x7F000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidChecksum(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidChecksum(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidVersion(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidVersion(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidPubKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidPubKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000003));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidFirstByte(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidFirstByte(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000004));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidLastByte(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddressInvalidLastByte(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000005));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrBufferUnderflow(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrBufferUnderflow(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000006));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidOmitEmpty(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidOmitEmpty(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000007));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthPubKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthPubKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000008));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrPubKeyFromNullSecKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrPubKeyFromNullSecKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000009));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrPubKeyFromBadSecKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrPubKeyFromBadSecKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200000A));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthSecKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthSecKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200000B));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrECHDInvalidPubKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrECHDInvalidPubKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200000C));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrECHDInvalidSecKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrECHDInvalidSecKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200000D));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthSig(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthSig(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200000E));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthRipemd160(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthRipemd160(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200000F));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthSHA256(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidLengthSHA256(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000010));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidBase58Char(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidBase58Char(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000011));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidBase58String(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidBase58String(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000012));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidBase58Length(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidBase58Length(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000013));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidHexLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidHexLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000014));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidBytesLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidBytesLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000015));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidPubKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidPubKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000016));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSecKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSecKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000017));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigPubKeyRecovery(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigPubKeyRecovery(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000018));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSecKeyHex(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSecKeyHex(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000019));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidAddressForSig(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidAddressForSig(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200001A));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidHashForSig(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidHashForSig(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200001B));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrPubKeyRecoverMismatch(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrPubKeyRecoverMismatch(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200001C));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigInvalidPubKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigInvalidPubKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200001D));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigValidity(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigValidity(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200001E));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigForMessage(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSigForMessage(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200001F));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSecKyVerification(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSecKyVerification(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000020));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNullPubKeyFromSecKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNullPubKeyFromSecKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000021));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidDerivedPubKeyFromSecKey(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidDerivedPubKeyFromSecKey(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000022));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidPubKeyFromHash(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidPubKeyFromHash(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000023));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrPubKeyFromSecKeyMismatch(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrPubKeyFromSecKeyMismatch(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000024));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000025));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrBitcoinWIFInvalidFirstByte(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrBitcoinWIFInvalidFirstByte(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000026));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrBitcoinWIFInvalidSuffix(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrBitcoinWIFInvalidSuffix(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000027));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrBitcoinWIFInvalidChecksum(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrBitcoinWIFInvalidChecksum(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000028));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrEmptySeed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrEmptySeed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000029));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidSig(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidSig(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200002A));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingPassword(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingPassword(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200002B));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDataTooLarge(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDataTooLarge(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200002C));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidChecksumLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidChecksumLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200002D));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidChecksum(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidChecksum(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200002E));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidNonceLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidNonceLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0200002F));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidBlockSize(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidBlockSize(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000030));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrReadDataHashFailed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrReadDataHashFailed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000031));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidPassword(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidPassword(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000032));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrReadDataLengthFailed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrReadDataLengthFailed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000033));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidDataLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidDataLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x02000034));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTemporaryInsufficientBalance(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTemporaryInsufficientBalance(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x03000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddress(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddress(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x03000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletName(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletName(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x03000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrJSONMarshal(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrJSONMarshal(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x03000003));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_WalletLoadError(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_WalletLoadError(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x03000004));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_WalletSaveError(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_WalletSaveError(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x03000005));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrAddEarnedCoinHoursAdditionOverflow(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrAddEarnedCoinHoursAdditionOverflow(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUint64MultOverflow(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUint64MultOverflow(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUint64AddOverflow(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUint64AddOverflow(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUint32AddOverflow(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUint32AddOverflow(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000003));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUint64OverflowsInt64(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUint64OverflowsInt64(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000004));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInt64UnderflowsUint64(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInt64UnderflowsUint64(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000005));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrIntUnderflowsUint32(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrIntUnderflowsUint32(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000006));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrIntOverflowsUint32(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrIntOverflowsUint32(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x04000007));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrPeerlistFull(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrPeerlistFull(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidAddress(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidAddress(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNoLocalhost(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNoLocalhost(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNotExternalIP(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNotExternalIP(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000003));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrPortTooLow(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrPortTooLow(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000004));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrBlacklistedAddress(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrBlacklistedAddress(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000005));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectWriteFailed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectWriteFailed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000007));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectSetReadDeadlineFailed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectSetReadDeadlineFailed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000008));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectInvalidMessageLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectInvalidMessageLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000009));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectMalformedMessage(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectMalformedMessage(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600000A));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectUnknownMessage(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectUnknownMessage(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600000B));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrConnectionPoolClosed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrConnectionPoolClosed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600000D));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWriteQueueFull(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWriteQueueFull(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600000E));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNoReachableConnections(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNoReachableConnections(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600000F));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMaxDefaultConnectionsReached(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMaxDefaultConnectionsReached(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000010));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectVersionNotSupported(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectVersionNotSupported(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000011));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIntroductionTimeout(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIntroductionTimeout(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000012));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIsBlacklisted(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIsBlacklisted(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000014));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectSelf(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectSelf(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000015));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectConnectedTwice(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectConnectedTwice(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000016));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIdle(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIdle(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000017));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectNoIntroduction(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectNoIntroduction(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000018));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIPLimitReached(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectIPLimitReached(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x06000019));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectMaxDefaultConnectionReached(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectMaxDefaultConnectionReached(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600001B));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDisconnectMaxOutgoingConnectionsReached(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDisconnectMaxOutgoingConnectionsReached(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600001C));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ConnectionError(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ConnectionError(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0600001D));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTxnNoFee(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTxnNoFee(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTxnInsufficientFee(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTxnInsufficientFee(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTxnInsufficientCoinHours(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTxnInsufficientCoinHours(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNegativeValue(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNegativeValue(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000003));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTooManyDecimals(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTooManyDecimals(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000004));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTooLarge(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTooLarge(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000005));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrEmptyDirectoryName(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrEmptyDirectoryName(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000006));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDotDirectoryName(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDotDirectoryName(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x09000007));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrHistoryDBCorrupted(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrHistoryDBCorrupted(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUxOutNotExist(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUxOutNotExist(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNoHeadBlock(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNoHeadBlock(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingSignature(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingSignature(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000003));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUnspentNotExist(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUnspentNotExist(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000004));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrVerifyStopped(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrVerifyStopped(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000005));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrCreateBucketFailed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrCreateBucketFailed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrBucketNotExist(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrBucketNotExist(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000006));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTxnViolatesHardConstraint(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTxnViolatesHardConstraint(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000007));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTxnViolatesSoftConstraint(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTxnViolatesSoftConstraint(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000008));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrTxnViolatesUserConstraint(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrTxnViolatesUserConstraint(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0A000009));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInsufficientBalance(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInsufficientBalance(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInsufficientHours(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInsufficientHours(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000001));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrZeroSpend(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrZeroSpend(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000002));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrSpendingUnconfirmed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrSpendingUnconfirmed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000003));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidEncryptedField(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidEncryptedField(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000004));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletEncrypted(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletEncrypted(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000005));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletNotEncrypted(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletNotEncrypted(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000006));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletMissingPassword(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletMissingPassword(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000007));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingEncrypt(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingEncrypt(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000008));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletInvalidPassword(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletInvalidPassword(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000009));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingSeed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingSeed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00000A));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingAuthenticated(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingAuthenticated(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00000B));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWrongCryptoType(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWrongCryptoType(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00000C));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletNotExist(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletNotExist(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00000D));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrSeedUsed(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrSeedUsed(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00000E));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletAPIDisabled(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletAPIDisabled(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00000F));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrSeedAPIDisabled(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrSeedAPIDisabled(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000010));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletNameConflict(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletNameConflict(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000011));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelectionMode(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelectionMode(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000012));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelectionType(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelectionType(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000013));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUnknownAddress(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUnknownAddress(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000014));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUnknownUxOut(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUnknownUxOut(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000015));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNoUnspents(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNoUnspents(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000016));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNullChangeAddress(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNullChangeAddress(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000017));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingTo(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingTo(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000018));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrZeroCoinsTo(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrZeroCoinsTo(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000019));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrNullAddressTo(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrNullAddressTo(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00001A));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDuplicateTo(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDuplicateTo(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00001B));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingWalletID(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingWalletID(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00001C));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrIncludesNullAddress(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrIncludesNullAddress(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00001D));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDuplicateAddresses(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDuplicateAddresses(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00001E));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrZeroToHoursAuto(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrZeroToHoursAuto(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B00001F));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingModeAuto(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingModeAuto(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000020));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelMode(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelMode(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000021));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidModeManual(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidModeManual(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000022));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelType(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidHoursSelType(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000023));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrMissingShareFactor(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrMissingShareFactor(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000024));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidShareFactor(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidShareFactor(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000025));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrShareFactorOutOfRange(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrShareFactorOutOfRange(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000026));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrWalletConstraint(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrWalletConstraint(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000027));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrDuplicateUxOuts(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrDuplicateUxOuts(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000028));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrUnknownWalletID(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrUnknownWalletID(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000029));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrVerifySignatureInvalidInputsNils(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrVerifySignatureInvalidInputsNils(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000033));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrVerifySignatureInvalidSigLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrVerifySignatureInvalidSigLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000034));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrVerifySignatureInvalidPubkeysLength(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrVerifySignatureInvalidPubkeysLength(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0B000035));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_SKY_ErrInvalidDecimals(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_SKY_ErrInvalidDecimals(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    
    jsresult = SWIG_From_int(static_cast< int >(0x0C000000));
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoComplex64__real_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoComplex64__real_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoComplex64_ *arg1 = (GoComplex64_ *) 0 ;
    float arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    float val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex64_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex64__real_set" "', argument " "1"" of type '" "GoComplex64_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex64_ * >(argp1);
    ecode2 = SWIG_AsVal_float(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoComplex64__real_set" "', argument " "2"" of type '" "float""'");
    } 
    arg2 = static_cast< float >(val2);
    if (arg1) (arg1)->real = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoComplex64__real_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoComplex64__real_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoComplex64_ *arg1 = (GoComplex64_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    float result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex64_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex64__real_get" "', argument " "1"" of type '" "GoComplex64_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex64_ * >(argp1);
    result = (float) ((arg1)->real);
    jsresult = SWIG_From_float(static_cast< float >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoComplex64__imaginary_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoComplex64__imaginary_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoComplex64_ *arg1 = (GoComplex64_ *) 0 ;
    float arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    float val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex64_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex64__imaginary_set" "', argument " "1"" of type '" "GoComplex64_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex64_ * >(argp1);
    ecode2 = SWIG_AsVal_float(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoComplex64__imaginary_set" "', argument " "2"" of type '" "float""'");
    } 
    arg2 = static_cast< float >(val2);
    if (arg1) (arg1)->imaginary = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoComplex64__imaginary_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoComplex64__imaginary_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoComplex64_ *arg1 = (GoComplex64_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    float result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex64_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex64__imaginary_get" "', argument " "1"" of type '" "GoComplex64_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex64_ * >(argp1);
    result = (float) ((arg1)->imaginary);
    jsresult = SWIG_From_float(static_cast< float >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_GoComplex64_(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  GoComplex64_ *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoComplex64_.");
  result = (GoComplex64_ *)new GoComplex64_();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_GoComplex64_, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_GoComplex64_(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_GoComplex64_(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_GoComplex64_(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_GoComplex64_(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_GoComplex64_(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            GoComplex64_ * arg1 = (GoComplex64_ *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoComplex128__real_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoComplex128__real_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoComplex128_ *arg1 = (GoComplex128_ *) 0 ;
    double arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    double val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex128_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex128__real_set" "', argument " "1"" of type '" "GoComplex128_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex128_ * >(argp1);
    ecode2 = SWIG_AsVal_double(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoComplex128__real_set" "', argument " "2"" of type '" "double""'");
    } 
    arg2 = static_cast< double >(val2);
    if (arg1) (arg1)->real = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoComplex128__real_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoComplex128__real_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoComplex128_ *arg1 = (GoComplex128_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    double result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex128_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex128__real_get" "', argument " "1"" of type '" "GoComplex128_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex128_ * >(argp1);
    result = (double) ((arg1)->real);
    jsresult = SWIG_From_double(static_cast< double >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoComplex128__imaginary_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoComplex128__imaginary_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoComplex128_ *arg1 = (GoComplex128_ *) 0 ;
    double arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    double val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex128_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex128__imaginary_set" "', argument " "1"" of type '" "GoComplex128_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex128_ * >(argp1);
    ecode2 = SWIG_AsVal_double(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoComplex128__imaginary_set" "', argument " "2"" of type '" "double""'");
    } 
    arg2 = static_cast< double >(val2);
    if (arg1) (arg1)->imaginary = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoComplex128__imaginary_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoComplex128__imaginary_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoComplex128_ *arg1 = (GoComplex128_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    double result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoComplex128_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoComplex128__imaginary_get" "', argument " "1"" of type '" "GoComplex128_ *""'"); 
    }
    arg1 = reinterpret_cast< GoComplex128_ * >(argp1);
    result = (double) ((arg1)->imaginary);
    jsresult = SWIG_From_double(static_cast< double >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_GoComplex128_(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  GoComplex128_ *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoComplex128_.");
  result = (GoComplex128_ *)new GoComplex128_();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_GoComplex128_, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_GoComplex128_(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_GoComplex128_(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_GoComplex128_(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_GoComplex128_(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_GoComplex128_(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            GoComplex128_ * arg1 = (GoComplex128_ *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoString__p_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoString__p_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoString_ *arg1 = (GoString_ *) 0 ;
    char *arg2 = (char *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    char *buf2 = 0 ;
    int alloc2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoString__p_set" "', argument " "1"" of type '" "GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< GoString_ * >(argp1);
    res2 = SWIG_AsCharPtrAndSize(value, &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoString__p_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);
    if (arg2) {
      size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >(arg2))) + 1;
      arg1->p = (char const *)reinterpret_cast< char* >(memcpy(new char[size], arg2, sizeof(char)*(size)));
    } else {
      arg1->p = 0;
    }
    
    if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoString__p_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoString__p_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoString_ *arg1 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    char *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoString__p_get" "', argument " "1"" of type '" "GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< GoString_ * >(argp1);
    result = (char *) ((arg1)->p);
    jsresult = SWIG_FromCharPtr((const char *)result);
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoString__n_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoString__n_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoString_ *arg1 = (GoString_ *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoString__n_set" "', argument " "1"" of type '" "GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< GoString_ * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoString__n_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->n = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoString__n_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoString__n_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoString_ *arg1 = (GoString_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoString_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoString__n_get" "', argument " "1"" of type '" "GoString_ *""'"); 
    }
    arg1 = reinterpret_cast< GoString_ * >(argp1);
    result = (GoInt_) ((arg1)->n);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_GoString_(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  GoString_ *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoString_.");
  result = (GoString_ *)new GoString_();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_GoString_, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_GoString_(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_GoString_(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_GoString_(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_GoString_(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_GoString_(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            GoString_ * arg1 = (GoString_ *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoInterface__t_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoInterface__t_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoInterface_ *arg1 = (GoInterface_ *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface__t_set" "', argument " "1"" of type '" "GoInterface_ *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface_ * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoInterface__t_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->t = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoInterface__t_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoInterface__t_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoInterface_ *arg1 = (GoInterface_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface__t_get" "', argument " "1"" of type '" "GoInterface_ *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface_ * >(argp1);
    result = (void *) ((arg1)->t);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoInterface__v_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoInterface__v_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoInterface_ *arg1 = (GoInterface_ *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface__v_set" "', argument " "1"" of type '" "GoInterface_ *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface_ * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoInterface__v_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->v = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoInterface__v_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoInterface__v_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoInterface_ *arg1 = (GoInterface_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoInterface_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoInterface__v_get" "', argument " "1"" of type '" "GoInterface_ *""'"); 
    }
    arg1 = reinterpret_cast< GoInterface_ * >(argp1);
    result = (void *) ((arg1)->v);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_GoInterface_(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  GoInterface_ *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoInterface_.");
  result = (GoInterface_ *)new GoInterface_();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_GoInterface_, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_GoInterface_(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_GoInterface_(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_GoInterface_(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_GoInterface_(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_GoInterface_(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            GoInterface_ * arg1 = (GoInterface_ *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoSlice__data_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoSlice__data_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoSlice_ *arg1 = (GoSlice_ *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice__data_set" "', argument " "1"" of type '" "GoSlice_ *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice_ * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GoSlice__data_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->data = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoSlice__data_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoSlice__data_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoSlice_ *arg1 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice__data_get" "', argument " "1"" of type '" "GoSlice_ *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice_ * >(argp1);
    result = (void *) ((arg1)->data);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoSlice__len_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoSlice__len_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoSlice_ *arg1 = (GoSlice_ *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice__len_set" "', argument " "1"" of type '" "GoSlice_ *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice_ * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoSlice__len_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->len = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoSlice__len_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoSlice__len_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoSlice_ *arg1 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice__len_get" "', argument " "1"" of type '" "GoSlice_ *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice_ * >(argp1);
    result = (GoInt_) ((arg1)->len);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_GoSlice__cap_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_GoSlice__cap_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    GoSlice_ *arg1 = (GoSlice_ *) 0 ;
    GoInt_ arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    long long val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice__cap_set" "', argument " "1"" of type '" "GoSlice_ *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice_ * >(argp1);
    ecode2 = SWIG_AsVal_long_SS_long(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GoSlice__cap_set" "', argument " "2"" of type '" "GoInt_""'");
    } 
    arg2 = static_cast< GoInt_ >(val2);
    if (arg1) (arg1)->cap = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_GoSlice__cap_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_GoSlice__cap_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    GoSlice_ *arg1 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoInt_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GoSlice__cap_get" "', argument " "1"" of type '" "GoSlice_ *""'"); 
    }
    arg1 = reinterpret_cast< GoSlice_ * >(argp1);
    result = (GoInt_) ((arg1)->cap);
    jsresult = SWIG_From_long_SS_long(static_cast< long long >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_GoSlice_(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  GoSlice_ *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_GoSlice_.");
  result = (GoSlice_ *)new GoSlice_();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_GoSlice_, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_GoSlice_(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_GoSlice_(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_GoSlice_(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_GoSlice_(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_GoSlice_(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            GoSlice_ * arg1 = (GoSlice_ *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Number_neg_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Number_neg_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Number *arg1 = (Number *) 0 ;
    BOOL arg2 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    unsigned int val2 ;
    int ecode2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Number, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Number_neg_set" "', argument " "1"" of type '" "Number *""'"); 
    }
    arg1 = reinterpret_cast< Number * >(argp1);
    ecode2 = SWIG_AsVal_unsigned_SS_int(value, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Number_neg_set" "', argument " "2"" of type '" "BOOL""'");
    } 
    arg2 = static_cast< BOOL >(val2);
    if (arg1) (arg1)->neg = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Number_neg_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Number_neg_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Number *arg1 = (Number *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    BOOL result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Number, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Number_neg_get" "', argument " "1"" of type '" "Number *""'"); 
    }
    arg1 = reinterpret_cast< Number * >(argp1);
    result = (BOOL) ((arg1)->neg);
    jsresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Number_nat_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Number_nat_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Number *arg1 = (Number *) 0 ;
    GoSlice_ *arg2 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Number, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Number_nat_set" "', argument " "1"" of type '" "Number *""'"); 
    }
    arg1 = reinterpret_cast< Number * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Number_nat_set" "', argument " "2"" of type '" "GoSlice_ *""'"); 
    }
    arg2 = reinterpret_cast< GoSlice_ * >(argp2);
    if (arg1) (arg1)->nat = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Number_nat_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Number_nat_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Number *arg1 = (Number *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoSlice_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Number, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Number_nat_get" "', argument " "1"" of type '" "Number *""'"); 
    }
    arg1 = reinterpret_cast< Number * >(argp1);
    result = (GoSlice_ *)& ((arg1)->nat);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_Number(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  Number *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Number.");
  result = (Number *)new Number();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Number, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_Number(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_Number(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_Number(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_Number(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_Number(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            Number * arg1 = (Number *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Signature_R_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Signature_R_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Signature *arg1 = (Signature *) 0 ;
    Number *arg2 = (Number *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Signature, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Signature_R_set" "', argument " "1"" of type '" "Signature *""'"); 
    }
    arg1 = reinterpret_cast< Signature * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_Number, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Signature_R_set" "', argument " "2"" of type '" "Number *""'"); 
    }
    arg2 = reinterpret_cast< Number * >(argp2);
    if (arg1) (arg1)->R = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Signature_R_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Signature_R_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Signature *arg1 = (Signature *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    Number *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Signature, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Signature_R_get" "', argument " "1"" of type '" "Signature *""'"); 
    }
    arg1 = reinterpret_cast< Signature * >(argp1);
    result = (Number *)& ((arg1)->R);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Number, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Signature_S_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Signature_S_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Signature *arg1 = (Signature *) 0 ;
    Number *arg2 = (Number *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Signature, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Signature_S_set" "', argument " "1"" of type '" "Signature *""'"); 
    }
    arg1 = reinterpret_cast< Signature * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_Number, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Signature_S_set" "', argument " "2"" of type '" "Number *""'"); 
    }
    arg2 = reinterpret_cast< Number * >(argp2);
    if (arg1) (arg1)->S = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Signature_S_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Signature_S_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Signature *arg1 = (Signature *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    Number *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Signature, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Signature_S_get" "', argument " "1"" of type '" "Signature *""'"); 
    }
    arg1 = reinterpret_cast< Signature * >(argp1);
    result = (Number *)& ((arg1)->S);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Number, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_Signature(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  Signature *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Signature.");
  result = (Signature *)new Signature();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Signature, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_Signature(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_Signature(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_Signature(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_Signature(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_Signature(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            Signature * arg1 = (Signature *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Wallet_Meta_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Wallet_Meta_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Wallet *arg1 = (Wallet *) 0 ;
    GoMap_ arg2 = (GoMap_) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Wallet, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Wallet_Meta_set" "', argument " "1"" of type '" "Wallet *""'"); 
    }
    arg1 = reinterpret_cast< Wallet * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Wallet_Meta_set" "', argument " "2"" of type '" "GoMap_""'"); 
    }
    if (arg1) (arg1)->Meta = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Wallet_Meta_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Wallet_Meta_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Wallet *arg1 = (Wallet *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoMap_ result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Wallet, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Wallet_Meta_get" "', argument " "1"" of type '" "Wallet *""'"); 
    }
    arg1 = reinterpret_cast< Wallet * >(argp1);
    result = (GoMap_) ((arg1)->Meta);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_Wallet_Entries_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_Wallet_Entries_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    Wallet *arg1 = (Wallet *) 0 ;
    GoSlice_ *arg2 = (GoSlice_ *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *argp2 = 0 ;
    int res2 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Wallet, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Wallet_Entries_set" "', argument " "1"" of type '" "Wallet *""'"); 
    }
    arg1 = reinterpret_cast< Wallet * >(argp1);
    res2 = SWIG_ConvertPtr(value, &argp2,SWIGTYPE_p_GoSlice_, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Wallet_Entries_set" "', argument " "2"" of type '" "GoSlice_ *""'"); 
    }
    arg2 = reinterpret_cast< GoSlice_ * >(argp2);
    if (arg1) (arg1)->Entries = *arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_Wallet_Entries_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_Wallet_Entries_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    Wallet *arg1 = (Wallet *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    GoSlice_ *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_Wallet, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Wallet_Entries_get" "', argument " "1"" of type '" "Wallet *""'"); 
    }
    arg1 = reinterpret_cast< Wallet * >(argp1);
    result = (GoSlice_ *)& ((arg1)->Entries);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GoSlice_, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_Wallet(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  Wallet *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_Wallet.");
  result = (Wallet *)new Wallet();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_Wallet, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_Wallet(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_Wallet(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_Wallet(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_Wallet(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_Wallet(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            Wallet * arg1 = (Wallet *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_FeeCalculator_callback_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_FeeCalculator_callback_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    FeeCalculator *arg1 = (FeeCalculator *) 0 ;
    FeeCalcFunc arg2 = (FeeCalcFunc) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_FeeCalculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalculator_callback_set" "', argument " "1"" of type '" "FeeCalculator *""'"); 
    }
    arg1 = reinterpret_cast< FeeCalculator * >(argp1);
    {
      int res = SWIG_ConvertFunctionPtr(value, (void**)(&arg2), SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "FeeCalculator_callback_set" "', argument " "2"" of type '" "FeeCalcFunc""'"); 
      }
    }
    if (arg1) (arg1)->callback = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_FeeCalculator_callback_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_FeeCalculator_callback_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    FeeCalculator *arg1 = (FeeCalculator *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    FeeCalcFunc result;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_FeeCalculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalculator_callback_get" "', argument " "1"" of type '" "FeeCalculator *""'"); 
    }
    arg1 = reinterpret_cast< FeeCalculator * >(argp1);
    result = (FeeCalcFunc) ((arg1)->callback);
    jsresult = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int);
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


#if (V8_MAJOR_VERSION-0) < 5
static void _wrap_FeeCalculator_context_set(v8::Local<v8::String> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#else
  static void _wrap_FeeCalculator_context_set(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const SwigV8PropertyCallbackInfoVoid &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    FeeCalculator *arg1 = (FeeCalculator *) 0 ;
    void *arg2 = (void *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    int res2 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_FeeCalculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalculator_context_set" "', argument " "1"" of type '" "FeeCalculator *""'"); 
    }
    arg1 = reinterpret_cast< FeeCalculator * >(argp1);
    res2 = SWIG_ConvertPtr(value,SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FeeCalculator_context_set" "', argument " "2"" of type '" "void *""'"); 
    }
    if (arg1) (arg1)->context = arg2;
    
    
    
    goto fail;
  fail:
    return;
  }


#if (V8_MAJOR_VERSION-0) < 5
static SwigV8ReturnValue _wrap_FeeCalculator_context_get(v8::Local<v8::String> property, const SwigV8PropertyCallbackInfo &info) {
#else
  static SwigV8ReturnValue _wrap_FeeCalculator_context_get(v8::Local<v8::Name> property, const SwigV8PropertyCallbackInfo &info) {
#endif
    SWIGV8_HANDLESCOPE();
    
    v8::Handle<v8::Value> jsresult;
    FeeCalculator *arg1 = (FeeCalculator *) 0 ;
    void *argp1 = 0 ;
    int res1 = 0 ;
    void *result = 0 ;
    
    res1 = SWIG_ConvertPtr(info.Holder(), &argp1,SWIGTYPE_p_FeeCalculator, 0 |  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FeeCalculator_context_get" "', argument " "1"" of type '" "FeeCalculator *""'"); 
    }
    arg1 = reinterpret_cast< FeeCalculator * >(argp1);
    result = (void *) ((arg1)->context);
    jsresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
    
    
    SWIGV8_RETURN_INFO(jsresult, info);
    
    goto fail;
  fail:
    SWIGV8_RETURN_INFO(SWIGV8_UNDEFINED(), info);
  }


static SwigV8ReturnValue _wrap_new_FeeCalculator(const SwigV8Arguments &args) {
  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> self = args.Holder();
  FeeCalculator *result;
  if(args.Length() != 0) SWIG_exception_fail(SWIG_ERROR, "Illegal number of arguments for _wrap_new_FeeCalculator.");
  result = (FeeCalculator *)new FeeCalculator();
  
  
  
  SWIGV8_SetPrivateData(self, result, SWIGTYPE_p_FeeCalculator, SWIG_POINTER_OWN);
  SWIGV8_RETURN(self);
  
  goto fail;
fail:
  SWIGV8_RETURN(SWIGV8_UNDEFINED());
}


#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
static void _wrap_delete_FeeCalculator(v8::Persistent<v8::Value> object, void *parameter) {
  SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
  static void _wrap_delete_FeeCalculator(v8::Isolate *isolate, v8::Persistent<v8::Value> object, void *parameter) {
    SWIGV8_Proxy *proxy = static_cast<SWIGV8_Proxy *>(parameter);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
    static void _wrap_delete_FeeCalculator(v8::Isolate *isolate, v8::Persistent< v8::Object> *object, SWIGV8_Proxy *proxy) {
#elif (V8_MAJOR_VERSION-0) < 5
      static void _wrap_delete_FeeCalculator(const v8::WeakCallbackData<v8::Object, SWIGV8_Proxy> &data) {
        v8::Local<v8::Object> object = data.GetValue();
        SWIGV8_Proxy *proxy = data.GetParameter();
#else
        static void _wrap_delete_FeeCalculator(const v8::WeakCallbackInfo<SWIGV8_Proxy> &data) {
          SWIGV8_Proxy *proxy = data.GetParameter();
#endif
          
          if(proxy->swigCMemOwn && proxy->swigCObject) {
            FeeCalculator * arg1 = (FeeCalculator *)proxy->swigCObject;
            delete arg1;
          }
          delete proxy;
          
#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)
          object.Dispose();
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)
          object.Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032100)
          object->Dispose(isolate);
#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < SWIGV8_SETWEAK_VERSION)
          object->Dispose();
#elif (V8_MAJOR_VERSION-0) < 5
          object.Clear();
#endif
        }


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_FeeCalculator = {"_p_FeeCalculator", "FeeCalculator *|p_FeeCalculator", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Fee_Calculator = {"_p_Fee_Calculator", "Fee_Calculator *|p_Fee_Calculator", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GoComplex128_ = {"_p_GoComplex128_", "GoComplex128_ *|p_GoComplex128_", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GoComplex64_ = {"_p_GoComplex64_", "p_GoComplex64_|GoComplex64_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GoInterface = {"_p_GoInterface", "p_GoInterface|GoInterface *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GoInterface_ = {"_p_GoInterface_", "GoInterface_ *|p_GoInterface_", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GoSlice = {"_p_GoSlice", "p_GoSlice|GoSlice *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GoSlice_ = {"_p_GoSlice_", "coin__Transactions *|coin__UxArray *|GoSlice_ *|cli__PasswordFromBytes *|visor__ReadableOutputs *|p_GoSlice_", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GoString_ = {"_p_GoString_", "GoString_ *|p_GoString_", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Number = {"_p_Number", "Number *|p_Number", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Signature = {"_p_Signature", "Signature *|p_Signature", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Wallet = {"_p_Wallet", "Wallet *|p_Wallet", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__GoString_ = {"_p__GoString_", "_GoString_ *|p__GoString_|GoString *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p___SIZE_TYPE__ = {"_p___SIZE_TYPE__", "__SIZE_TYPE__ *|GoUintptr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_16__unsigned_char = {"_p_a_16__unsigned_char", "poly1305__Mac *|unsigned char (*)[16]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_20__unsigned_char = {"_p_a_20__unsigned_char", "unsigned char (*)[20]|cipher__Ripemd160 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_32__unsigned_char = {"_p_a_32__unsigned_char", "cipher__SecKey *|cipher__SHA256 *|unsigned char (*)[32]|poly1305__Key *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_33__unsigned_char = {"_p_a_33__unsigned_char", "unsigned char (*)[33]|cipher__PubKey *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__unsigned_char = {"_p_a_4__unsigned_char", "cipher__Checksum *|unsigned char (*)[4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_65__unsigned_char = {"_p_a_65__unsigned_char", "unsigned char (*)[65]|cipher__Sig *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_sizeof_void_____64_8_1__1__char = {"_p_a_sizeof_void_____64_8_1__1__char", "char (*)[sizeof(void *)==64/8?1:-1]|_check_for_64_bit_pointer_matching_GoInt *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_api__NetworkConnectionsFilter = {"_p_api__NetworkConnectionsFilter", "api__NetworkConnectionsFilter *|p_api__NetworkConnectionsFilter", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_api__RichlistParams = {"_p_api__RichlistParams", "api__RichlistParams *|p_api__RichlistParams", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_api__TransactionInput = {"_p_api__TransactionInput", "api__TransactionInput *|p_api__TransactionInput", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_Addresses = {"_p_cipher_Addresses", "p_cipher_Addresses|cipher_Addresses *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_Checksum = {"_p_cipher_Checksum", "cipher_Checksum *|p_cipher_Checksum", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_PubKey = {"_p_cipher_PubKey", "p_cipher_PubKey|cipher_PubKey *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_PubKeys = {"_p_cipher_PubKeys", "cipher_PubKeys *|p_cipher_PubKeys", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_Ripemd160 = {"_p_cipher_Ripemd160", "cipher_Ripemd160 *|p_cipher_Ripemd160", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_SHA256 = {"_p_cipher_SHA256", "cipher_SHA256 *|p_cipher_SHA256", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_SHA256s = {"_p_cipher_SHA256s", "p_cipher_SHA256s|cipher_SHA256s *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_SecKey = {"_p_cipher_SecKey", "cipher_SecKey *|p_cipher_SecKey", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_SecKeys = {"_p_cipher_SecKeys", "p_cipher_SecKeys|cipher_SecKeys *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher_Sig = {"_p_cipher_Sig", "cipher_Sig *|p_cipher_Sig", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher__Address = {"_p_cipher__Address", "cipher__Address *|p_cipher__Address", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cipher__BitcoinAddress = {"_p_cipher__BitcoinAddress", "cipher__BitcoinAddress *|p_cipher__BitcoinAddress", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cli__SendAmount = {"_p_cli__SendAmount", "cli__SendAmount *|p_cli__SendAmount", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin_UxOutArray = {"_p_coin_UxOutArray", "coin_UxOutArray *|p_coin_UxOutArray", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__Block = {"_p_coin__Block", "coin__Block *|p_coin__Block", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__BlockBody = {"_p_coin__BlockBody", "coin__BlockBody *|p_coin__BlockBody", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__BlockHeader = {"_p_coin__BlockHeader", "p_coin__BlockHeader|coin__BlockHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__SignedBlock = {"_p_coin__SignedBlock", "coin__SignedBlock *|p_coin__SignedBlock", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__Transaction = {"_p_coin__Transaction", "coin__Transaction *|p_coin__Transaction", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__TransactionOutput = {"_p_coin__TransactionOutput", "p_coin__TransactionOutput|coin__TransactionOutput *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__UxBody = {"_p_coin__UxBody", "coin__UxBody *|p_coin__UxBody", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__UxHead = {"_p_coin__UxHead", "p_coin__UxHead|coin__UxHead *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_coin__UxOut = {"_p_coin__UxOut", "coin__UxOut *|p_coin__UxOut", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "GoFloat64_ *|GoFloat64 *|double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_encrypt__ScryptChacha20poly1305 = {"_p_encrypt__ScryptChacha20poly1305", "p_encrypt__ScryptChacha20poly1305|encrypt__ScryptChacha20poly1305 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_long_long_p_unsigned_long_long_p_void__unsigned_int = {"_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int", "unsigned int (*)(long long,unsigned long long *,void *)|FeeCalcFunc", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *|GoFloat32_ *|GoFloat32 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_httphelper__Address = {"_p_httphelper__Address", "httphelper__Address *|p_httphelper__Address", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_httphelper__SHA256 = {"_p_httphelper__SHA256", "httphelper__SHA256 *|p_httphelper__SHA256", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *|GoInt32 *|GoInt_ *|GoInt32_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "GoStringMap_ *|GoInt64 *|long long *|GoInt64_ *|GoInt *|TransactionResult_Handle *|SpendResult_Handle *|BalanceResult_Handle *|SignedBlock__Handle *|WalletResponse__Handle *|Number_Handle *|Signature_Handle *|BlockBody__Handle *|BlockHeader__Handle *|Block__Handle *|Transaction__Handle *|Transactions__Handle *|AddressUxOuts_Handle *|Options__Handle *|Wallet__Handle *|Config__Handle *|CLI__Handle *|PasswordReader__Handle *|CreateTransactionResponse__Handle *|CreatedTransaction__Handle *|CreateTransactionParams__Handle *|ReadableOutputSet_Handle *|CreateTransactionRequest__Handle *|WebRpcClient__Handle *|SortableTransactionResult_Handle *|Strings__Handle *|Wallets__Handle *|Client__Handle *|ReadableWallet__Handle *|ReadableEntry__Handle *|CreatedTransactionInput__Handle *|CreatedTransactionOutput__Handle *|WalletReadableNotes_Handle *|OutputsResult_Handle *|StatusResult_Handle *|BuildInfo_Handle *|ReadableUnspentOutputsSummary_Handle *|Hash_Handle *|UnspentOutputsSummary_Handle *|Handle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_GoSlice_ = {"_p_p_GoSlice_", "coin__UxArray **|GoSlice_ **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_coin__Block = {"_p_p_coin__Block", "coin__Block **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_coin__BlockHeader = {"_p_p_coin__BlockHeader", "coin__BlockHeader **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_coin__Transaction = {"_p_p_coin__Transaction", "coin__Transaction **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int = {"_p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int", "FeeCalcFunc *|unsigned int (**)(long long,unsigned long long *,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_secp256k1go__Field = {"_p_secp256k1go__Field", "p_secp256k1go__Field|secp256k1go__Field *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_secp256k1go__XY = {"_p_secp256k1go__XY", "p_secp256k1go__XY|secp256k1go__XY *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_secp256k1go__XYZ = {"_p_secp256k1go__XYZ", "p_secp256k1go__XYZ|secp256k1go__XYZ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "GoInt16 *|GoInt16_ *|short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|GoInt8 *|GoInt8_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_transaction__UxBalance = {"_p_transaction__UxBalance", "p_transaction__UxBalance|transaction__UxBalance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_uintptr_t = {"_p_uintptr_t", "uintptr_t *|GoUintptr_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|GoUint8 *|GoUint8_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "BOOL *|error *|GoUint32 *|unsigned int *|GoUint_ *|GoUint32_ *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "httphelper__Coins *|GoUint64 *|GoUint *|unsigned long long *|GoUint64_ *|httphelper__Hours *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "GoUint16_ *|GoUint16 *|unsigned short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *|GoMap_", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_wallet__Balance = {"_p_wallet__Balance", "p_wallet__Balance|wallet__Balance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_wallet__BalancePair = {"_p_wallet__BalancePair", "wallet__BalancePair *|p_wallet__BalancePair", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_wallet__Entry = {"_p_wallet__Entry", "wallet__Entry *|p_wallet__Entry", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_wallet__Note = {"_p_wallet__Note", "wallet__Note *|p_wallet__Note", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_wallet__ReadableNote = {"_p_wallet__ReadableNote", "wallet__ReadableNote *|p_wallet__ReadableNote", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_FeeCalculator,
  &_swigt__p_Fee_Calculator,
  &_swigt__p_GoComplex128_,
  &_swigt__p_GoComplex64_,
  &_swigt__p_GoInterface,
  &_swigt__p_GoInterface_,
  &_swigt__p_GoSlice,
  &_swigt__p_GoSlice_,
  &_swigt__p_GoString_,
  &_swigt__p_Number,
  &_swigt__p_Signature,
  &_swigt__p_Wallet,
  &_swigt__p__GoString_,
  &_swigt__p___SIZE_TYPE__,
  &_swigt__p_a_16__unsigned_char,
  &_swigt__p_a_20__unsigned_char,
  &_swigt__p_a_32__unsigned_char,
  &_swigt__p_a_33__unsigned_char,
  &_swigt__p_a_4__unsigned_char,
  &_swigt__p_a_65__unsigned_char,
  &_swigt__p_a_sizeof_void_____64_8_1__1__char,
  &_swigt__p_api__NetworkConnectionsFilter,
  &_swigt__p_api__RichlistParams,
  &_swigt__p_api__TransactionInput,
  &_swigt__p_char,
  &_swigt__p_cipher_Addresses,
  &_swigt__p_cipher_Checksum,
  &_swigt__p_cipher_PubKey,
  &_swigt__p_cipher_PubKeys,
  &_swigt__p_cipher_Ripemd160,
  &_swigt__p_cipher_SHA256,
  &_swigt__p_cipher_SHA256s,
  &_swigt__p_cipher_SecKey,
  &_swigt__p_cipher_SecKeys,
  &_swigt__p_cipher_Sig,
  &_swigt__p_cipher__Address,
  &_swigt__p_cipher__BitcoinAddress,
  &_swigt__p_cli__SendAmount,
  &_swigt__p_coin_UxOutArray,
  &_swigt__p_coin__Block,
  &_swigt__p_coin__BlockBody,
  &_swigt__p_coin__BlockHeader,
  &_swigt__p_coin__SignedBlock,
  &_swigt__p_coin__Transaction,
  &_swigt__p_coin__TransactionOutput,
  &_swigt__p_coin__UxBody,
  &_swigt__p_coin__UxHead,
  &_swigt__p_coin__UxOut,
  &_swigt__p_double,
  &_swigt__p_encrypt__ScryptChacha20poly1305,
  &_swigt__p_f_long_long_p_unsigned_long_long_p_void__unsigned_int,
  &_swigt__p_float,
  &_swigt__p_httphelper__Address,
  &_swigt__p_httphelper__SHA256,
  &_swigt__p_int,
  &_swigt__p_long_long,
  &_swigt__p_p_GoSlice_,
  &_swigt__p_p_coin__Block,
  &_swigt__p_p_coin__BlockHeader,
  &_swigt__p_p_coin__Transaction,
  &_swigt__p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int,
  &_swigt__p_secp256k1go__Field,
  &_swigt__p_secp256k1go__XY,
  &_swigt__p_secp256k1go__XYZ,
  &_swigt__p_short,
  &_swigt__p_signed_char,
  &_swigt__p_transaction__UxBalance,
  &_swigt__p_uintptr_t,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_unsigned_short,
  &_swigt__p_void,
  &_swigt__p_wallet__Balance,
  &_swigt__p_wallet__BalancePair,
  &_swigt__p_wallet__Entry,
  &_swigt__p_wallet__Note,
  &_swigt__p_wallet__ReadableNote,
};

static swig_cast_info _swigc__p_FeeCalculator[] = {  {&_swigt__p_FeeCalculator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Fee_Calculator[] = {  {&_swigt__p_Fee_Calculator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GoComplex128_[] = {  {&_swigt__p_GoComplex128_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GoComplex64_[] = {  {&_swigt__p_GoComplex64_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GoInterface[] = {  {&_swigt__p_GoInterface, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GoInterface_[] = {  {&_swigt__p_GoInterface_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GoSlice[] = {  {&_swigt__p_GoSlice, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GoSlice_[] = {  {&_swigt__p_GoSlice_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GoString_[] = {  {&_swigt__p_GoString_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Number[] = {  {&_swigt__p_Number, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Signature[] = {  {&_swigt__p_Signature, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Wallet[] = {  {&_swigt__p_Wallet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__GoString_[] = {  {&_swigt__p__GoString_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p___SIZE_TYPE__[] = {  {&_swigt__p___SIZE_TYPE__, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_16__unsigned_char[] = {  {&_swigt__p_a_16__unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_20__unsigned_char[] = {  {&_swigt__p_a_20__unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_32__unsigned_char[] = {  {&_swigt__p_a_32__unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_33__unsigned_char[] = {  {&_swigt__p_a_33__unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__unsigned_char[] = {  {&_swigt__p_a_4__unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_65__unsigned_char[] = {  {&_swigt__p_a_65__unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_sizeof_void_____64_8_1__1__char[] = {  {&_swigt__p_a_sizeof_void_____64_8_1__1__char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_api__NetworkConnectionsFilter[] = {  {&_swigt__p_api__NetworkConnectionsFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_api__RichlistParams[] = {  {&_swigt__p_api__RichlistParams, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_api__TransactionInput[] = {  {&_swigt__p_api__TransactionInput, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_Addresses[] = {  {&_swigt__p_cipher_Addresses, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_Checksum[] = {  {&_swigt__p_cipher_Checksum, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_PubKey[] = {  {&_swigt__p_cipher_PubKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_PubKeys[] = {  {&_swigt__p_cipher_PubKeys, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_Ripemd160[] = {  {&_swigt__p_cipher_Ripemd160, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_SHA256[] = {  {&_swigt__p_cipher_SHA256, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_SHA256s[] = {  {&_swigt__p_cipher_SHA256s, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_SecKey[] = {  {&_swigt__p_cipher_SecKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_SecKeys[] = {  {&_swigt__p_cipher_SecKeys, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher_Sig[] = {  {&_swigt__p_cipher_Sig, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher__Address[] = {  {&_swigt__p_cipher__Address, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cipher__BitcoinAddress[] = {  {&_swigt__p_cipher__BitcoinAddress, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cli__SendAmount[] = {  {&_swigt__p_cli__SendAmount, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin_UxOutArray[] = {  {&_swigt__p_coin_UxOutArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__Block[] = {  {&_swigt__p_coin__Block, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__BlockBody[] = {  {&_swigt__p_coin__BlockBody, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__BlockHeader[] = {  {&_swigt__p_coin__BlockHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__SignedBlock[] = {  {&_swigt__p_coin__SignedBlock, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__Transaction[] = {  {&_swigt__p_coin__Transaction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__TransactionOutput[] = {  {&_swigt__p_coin__TransactionOutput, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__UxBody[] = {  {&_swigt__p_coin__UxBody, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__UxHead[] = {  {&_swigt__p_coin__UxHead, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_coin__UxOut[] = {  {&_swigt__p_coin__UxOut, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_encrypt__ScryptChacha20poly1305[] = {  {&_swigt__p_encrypt__ScryptChacha20poly1305, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_long_long_p_unsigned_long_long_p_void__unsigned_int[] = {  {&_swigt__p_f_long_long_p_unsigned_long_long_p_void__unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_httphelper__Address[] = {  {&_swigt__p_httphelper__Address, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_httphelper__SHA256[] = {  {&_swigt__p_httphelper__SHA256, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_GoSlice_[] = {  {&_swigt__p_p_GoSlice_, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_coin__Block[] = {  {&_swigt__p_p_coin__Block, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_coin__BlockHeader[] = {  {&_swigt__p_p_coin__BlockHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_coin__Transaction[] = {  {&_swigt__p_p_coin__Transaction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int[] = {  {&_swigt__p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_secp256k1go__Field[] = {  {&_swigt__p_secp256k1go__Field, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_secp256k1go__XY[] = {  {&_swigt__p_secp256k1go__XY, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_secp256k1go__XYZ[] = {  {&_swigt__p_secp256k1go__XYZ, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_transaction__UxBalance[] = {  {&_swigt__p_transaction__UxBalance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uintptr_t[] = {  {&_swigt__p_uintptr_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_wallet__Balance[] = {  {&_swigt__p_wallet__Balance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_wallet__BalancePair[] = {  {&_swigt__p_wallet__BalancePair, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_wallet__Entry[] = {  {&_swigt__p_wallet__Entry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_wallet__Note[] = {  {&_swigt__p_wallet__Note, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_wallet__ReadableNote[] = {  {&_swigt__p_wallet__ReadableNote, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_FeeCalculator,
  _swigc__p_Fee_Calculator,
  _swigc__p_GoComplex128_,
  _swigc__p_GoComplex64_,
  _swigc__p_GoInterface,
  _swigc__p_GoInterface_,
  _swigc__p_GoSlice,
  _swigc__p_GoSlice_,
  _swigc__p_GoString_,
  _swigc__p_Number,
  _swigc__p_Signature,
  _swigc__p_Wallet,
  _swigc__p__GoString_,
  _swigc__p___SIZE_TYPE__,
  _swigc__p_a_16__unsigned_char,
  _swigc__p_a_20__unsigned_char,
  _swigc__p_a_32__unsigned_char,
  _swigc__p_a_33__unsigned_char,
  _swigc__p_a_4__unsigned_char,
  _swigc__p_a_65__unsigned_char,
  _swigc__p_a_sizeof_void_____64_8_1__1__char,
  _swigc__p_api__NetworkConnectionsFilter,
  _swigc__p_api__RichlistParams,
  _swigc__p_api__TransactionInput,
  _swigc__p_char,
  _swigc__p_cipher_Addresses,
  _swigc__p_cipher_Checksum,
  _swigc__p_cipher_PubKey,
  _swigc__p_cipher_PubKeys,
  _swigc__p_cipher_Ripemd160,
  _swigc__p_cipher_SHA256,
  _swigc__p_cipher_SHA256s,
  _swigc__p_cipher_SecKey,
  _swigc__p_cipher_SecKeys,
  _swigc__p_cipher_Sig,
  _swigc__p_cipher__Address,
  _swigc__p_cipher__BitcoinAddress,
  _swigc__p_cli__SendAmount,
  _swigc__p_coin_UxOutArray,
  _swigc__p_coin__Block,
  _swigc__p_coin__BlockBody,
  _swigc__p_coin__BlockHeader,
  _swigc__p_coin__SignedBlock,
  _swigc__p_coin__Transaction,
  _swigc__p_coin__TransactionOutput,
  _swigc__p_coin__UxBody,
  _swigc__p_coin__UxHead,
  _swigc__p_coin__UxOut,
  _swigc__p_double,
  _swigc__p_encrypt__ScryptChacha20poly1305,
  _swigc__p_f_long_long_p_unsigned_long_long_p_void__unsigned_int,
  _swigc__p_float,
  _swigc__p_httphelper__Address,
  _swigc__p_httphelper__SHA256,
  _swigc__p_int,
  _swigc__p_long_long,
  _swigc__p_p_GoSlice_,
  _swigc__p_p_coin__Block,
  _swigc__p_p_coin__BlockHeader,
  _swigc__p_p_coin__Transaction,
  _swigc__p_p_f_long_long_p_unsigned_long_long_p_void__unsigned_int,
  _swigc__p_secp256k1go__Field,
  _swigc__p_secp256k1go__XY,
  _swigc__p_secp256k1go__XYZ,
  _swigc__p_short,
  _swigc__p_signed_char,
  _swigc__p_transaction__UxBalance,
  _swigc__p_uintptr_t,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long_long,
  _swigc__p_unsigned_short,
  _swigc__p_void,
  _swigc__p_wallet__Balance,
  _swigc__p_wallet__BalancePair,
  _swigc__p_wallet__Entry,
  _swigc__p_wallet__Note,
  _swigc__p_wallet__ReadableNote,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */




SWIGRUNTIME void
SWIG_V8_SetModule(void *, swig_module_info *swig_module) {
  v8::Local<v8::Object> global_obj = SWIGV8_CURRENT_CONTEXT()->Global();
  v8::Local<v8::External> mod = SWIGV8_EXTERNAL_NEW(swig_module);
  assert(!mod.IsEmpty());
#if (V8_MAJOR_VERSION-0) < 5
  global_obj->SetHiddenValue(SWIGV8_STRING_NEW("swig_module_info_data"), mod);
#else
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("swig_module_info_data"));
  global_obj->SetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey, mod);
#endif
}

SWIGRUNTIME swig_module_info *
SWIG_V8_GetModule(void *) {
  v8::Local<v8::Object> global_obj = SWIGV8_CURRENT_CONTEXT()->Global();
#if (V8_MAJOR_VERSION-0) < 5
  v8::Local<v8::Value> moduleinfo = global_obj->GetHiddenValue(SWIGV8_STRING_NEW("swig_module_info_data"));
#else
  v8::Local<v8::Private> privateKey = v8::Private::ForApi(v8::Isolate::GetCurrent(), SWIGV8_STRING_NEW("swig_module_info_data"));
  v8::Local<v8::Value> moduleinfo;
  if (!global_obj->GetPrivate(SWIGV8_CURRENT_CONTEXT(), privateKey).ToLocal(&moduleinfo))
    return 0;
#endif

  if (moduleinfo.IsEmpty() || moduleinfo->IsNull() || moduleinfo->IsUndefined())
  {
    // It's not yet loaded
    return 0;
  }

  v8::Local<v8::External> moduleinfo_extern = v8::Local<v8::External>::Cast(moduleinfo);

  if (moduleinfo_extern.IsEmpty() || moduleinfo_extern->IsNull() || moduleinfo_extern->IsUndefined())
  {
    // Something's not right
    return 0;
  }

  void *ptr = moduleinfo_extern->Value();
  assert(ptr);
  swig_module_info *retptr = static_cast<swig_module_info *>(ptr);
  assert(retptr);
  return retptr;
}

#define SWIG_GetModule(clientdata)                SWIG_V8_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)       SWIG_V8_SetModule(clientdata, pointer)


/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif


// Note: 'extern "C"'' disables name mangling which makes it easier to load the symbol manually
// TODO: is it ok to do that?
extern "C"
#if (NODE_MODULE_VERSION < 0x000C)
void SWIGV8_INIT (v8::Handle<v8::Object> exports)
#else
void SWIGV8_INIT (v8::Handle<v8::Object> exports, v8::Handle<v8::Object> /*module*/)
#endif
{
  SWIG_InitializeModule(static_cast<void *>(&exports));

  SWIGV8_HANDLESCOPE();
  
  v8::Handle<v8::Object> exports_obj = exports;


  // a class template for creating proxies of undefined types
  SWIGV8_SET_CLASS_TEMPL(SWIGV8_SWIGTYPE_Proxy_class_templ, SWIGV8_CreateClassTemplate("SwigProxy"));

  /* create objects for namespaces */
  

  /* create class templates */
  /* Name: _exports_cipher_PubKey, Type: p_cipher_PubKey, Dtor: _wrap_delete_cipher_PubKey */
v8::Handle<v8::FunctionTemplate> _exports_cipher_PubKey_class = SWIGV8_CreateClassTemplate("_exports_cipher_PubKey");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_PubKey_clientData.class_templ, _exports_cipher_PubKey_class);
_exports_cipher_PubKey_clientData.dtor = _wrap_delete_cipher_PubKey;
if (SWIGTYPE_p_cipher_PubKey->clientdata == 0) {
  SWIGTYPE_p_cipher_PubKey->clientdata = &_exports_cipher_PubKey_clientData;
}
/* Name: _exports_cipher_SecKey, Type: p_cipher_SecKey, Dtor: _wrap_delete_cipher_SecKey */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SecKey_class = SWIGV8_CreateClassTemplate("_exports_cipher_SecKey");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_SecKey_clientData.class_templ, _exports_cipher_SecKey_class);
_exports_cipher_SecKey_clientData.dtor = _wrap_delete_cipher_SecKey;
if (SWIGTYPE_p_cipher_SecKey->clientdata == 0) {
  SWIGTYPE_p_cipher_SecKey->clientdata = &_exports_cipher_SecKey_clientData;
}
/* Name: _exports_cipher_Ripemd160, Type: p_cipher_Ripemd160, Dtor: _wrap_delete_cipher_Ripemd160 */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Ripemd160_class = SWIGV8_CreateClassTemplate("_exports_cipher_Ripemd160");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_Ripemd160_clientData.class_templ, _exports_cipher_Ripemd160_class);
_exports_cipher_Ripemd160_clientData.dtor = _wrap_delete_cipher_Ripemd160;
if (SWIGTYPE_p_cipher_Ripemd160->clientdata == 0) {
  SWIGTYPE_p_cipher_Ripemd160->clientdata = &_exports_cipher_Ripemd160_clientData;
}
/* Name: _exports_cipher_Sig, Type: p_cipher_Sig, Dtor: _wrap_delete_cipher_Sig */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Sig_class = SWIGV8_CreateClassTemplate("_exports_cipher_Sig");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_Sig_clientData.class_templ, _exports_cipher_Sig_class);
_exports_cipher_Sig_clientData.dtor = _wrap_delete_cipher_Sig;
if (SWIGTYPE_p_cipher_Sig->clientdata == 0) {
  SWIGTYPE_p_cipher_Sig->clientdata = &_exports_cipher_Sig_clientData;
}
/* Name: _exports_cipher_SHA256, Type: p_cipher_SHA256, Dtor: _wrap_delete_cipher_SHA256 */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SHA256_class = SWIGV8_CreateClassTemplate("_exports_cipher_SHA256");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_SHA256_clientData.class_templ, _exports_cipher_SHA256_class);
_exports_cipher_SHA256_clientData.dtor = _wrap_delete_cipher_SHA256;
if (SWIGTYPE_p_cipher_SHA256->clientdata == 0) {
  SWIGTYPE_p_cipher_SHA256->clientdata = &_exports_cipher_SHA256_clientData;
}
/* Name: _exports_cipher_Checksum, Type: p_cipher_Checksum, Dtor: _wrap_delete_cipher_Checksum */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Checksum_class = SWIGV8_CreateClassTemplate("_exports_cipher_Checksum");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_Checksum_clientData.class_templ, _exports_cipher_Checksum_class);
_exports_cipher_Checksum_clientData.dtor = _wrap_delete_cipher_Checksum;
if (SWIGTYPE_p_cipher_Checksum->clientdata == 0) {
  SWIGTYPE_p_cipher_Checksum->clientdata = &_exports_cipher_Checksum_clientData;
}
/* Name: _exports_cipher_SecKeys, Type: p_cipher_SecKeys, Dtor: _wrap_delete_cipher_SecKeys */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SecKeys_class = SWIGV8_CreateClassTemplate("_exports_cipher_SecKeys");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_SecKeys_clientData.class_templ, _exports_cipher_SecKeys_class);
_exports_cipher_SecKeys_clientData.dtor = _wrap_delete_cipher_SecKeys;
if (SWIGTYPE_p_cipher_SecKeys->clientdata == 0) {
  SWIGTYPE_p_cipher_SecKeys->clientdata = &_exports_cipher_SecKeys_clientData;
}
/* Name: _exports_cipher_PubKeys, Type: p_cipher_PubKeys, Dtor: _wrap_delete_cipher_PubKeys */
v8::Handle<v8::FunctionTemplate> _exports_cipher_PubKeys_class = SWIGV8_CreateClassTemplate("_exports_cipher_PubKeys");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_PubKeys_clientData.class_templ, _exports_cipher_PubKeys_class);
_exports_cipher_PubKeys_clientData.dtor = _wrap_delete_cipher_PubKeys;
if (SWIGTYPE_p_cipher_PubKeys->clientdata == 0) {
  SWIGTYPE_p_cipher_PubKeys->clientdata = &_exports_cipher_PubKeys_clientData;
}
/* Name: _exports_cipher_SHA256s, Type: p_cipher_SHA256s, Dtor: _wrap_delete_cipher_SHA256s */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SHA256s_class = SWIGV8_CreateClassTemplate("_exports_cipher_SHA256s");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_SHA256s_clientData.class_templ, _exports_cipher_SHA256s_class);
_exports_cipher_SHA256s_clientData.dtor = _wrap_delete_cipher_SHA256s;
if (SWIGTYPE_p_cipher_SHA256s->clientdata == 0) {
  SWIGTYPE_p_cipher_SHA256s->clientdata = &_exports_cipher_SHA256s_clientData;
}
/* Name: _exports_coin_UxOutArray, Type: p_coin_UxOutArray, Dtor: _wrap_delete_coin_UxOutArray */
v8::Handle<v8::FunctionTemplate> _exports_coin_UxOutArray_class = SWIGV8_CreateClassTemplate("_exports_coin_UxOutArray");
SWIGV8_SET_CLASS_TEMPL(_exports_coin_UxOutArray_clientData.class_templ, _exports_coin_UxOutArray_class);
_exports_coin_UxOutArray_clientData.dtor = _wrap_delete_coin_UxOutArray;
if (SWIGTYPE_p_coin_UxOutArray->clientdata == 0) {
  SWIGTYPE_p_coin_UxOutArray->clientdata = &_exports_coin_UxOutArray_clientData;
}
/* Name: _exports_cipher_Addresses, Type: p_cipher_Addresses, Dtor: _wrap_delete_cipher_Addresses */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Addresses_class = SWIGV8_CreateClassTemplate("_exports_cipher_Addresses");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher_Addresses_clientData.class_templ, _exports_cipher_Addresses_class);
_exports_cipher_Addresses_clientData.dtor = _wrap_delete_cipher_Addresses;
if (SWIGTYPE_p_cipher_Addresses->clientdata == 0) {
  SWIGTYPE_p_cipher_Addresses->clientdata = &_exports_cipher_Addresses_clientData;
}
/* Name: _exports_Fee_Calculator, Type: p_Fee_Calculator, Dtor: _wrap_delete_Fee_Calculator */
v8::Handle<v8::FunctionTemplate> _exports_Fee_Calculator_class = SWIGV8_CreateClassTemplate("_exports_Fee_Calculator");
SWIGV8_SET_CLASS_TEMPL(_exports_Fee_Calculator_clientData.class_templ, _exports_Fee_Calculator_class);
_exports_Fee_Calculator_clientData.dtor = _wrap_delete_Fee_Calculator;
if (SWIGTYPE_p_Fee_Calculator->clientdata == 0) {
  SWIGTYPE_p_Fee_Calculator->clientdata = &_exports_Fee_Calculator_clientData;
}
/* Name: _exports__GoString_, Type: p__GoString_, Dtor: _wrap_delete__GoString_ */
v8::Handle<v8::FunctionTemplate> _exports__GoString__class = SWIGV8_CreateClassTemplate("_exports__GoString_");
SWIGV8_SET_CLASS_TEMPL(_exports__GoString__clientData.class_templ, _exports__GoString__class);
_exports__GoString__clientData.dtor = _wrap_delete__GoString_;
if (SWIGTYPE_p__GoString_->clientdata == 0) {
  SWIGTYPE_p__GoString_->clientdata = &_exports__GoString__clientData;
}
/* Name: _exports_GoInterface, Type: p_GoInterface, Dtor: _wrap_delete_GoInterface */
v8::Handle<v8::FunctionTemplate> _exports_GoInterface_class = SWIGV8_CreateClassTemplate("_exports_GoInterface");
SWIGV8_SET_CLASS_TEMPL(_exports_GoInterface_clientData.class_templ, _exports_GoInterface_class);
_exports_GoInterface_clientData.dtor = _wrap_delete_GoInterface;
if (SWIGTYPE_p_GoInterface->clientdata == 0) {
  SWIGTYPE_p_GoInterface->clientdata = &_exports_GoInterface_clientData;
}
/* Name: _exports_GoSlice, Type: p_GoSlice, Dtor: _wrap_delete_GoSlice */
v8::Handle<v8::FunctionTemplate> _exports_GoSlice_class = SWIGV8_CreateClassTemplate("_exports_GoSlice");
SWIGV8_SET_CLASS_TEMPL(_exports_GoSlice_clientData.class_templ, _exports_GoSlice_class);
_exports_GoSlice_clientData.dtor = _wrap_delete_GoSlice;
if (SWIGTYPE_p_GoSlice->clientdata == 0) {
  SWIGTYPE_p_GoSlice->clientdata = &_exports_GoSlice_clientData;
}
/* Name: _exports_api__RichlistParams, Type: p_api__RichlistParams, Dtor: _wrap_delete_api__RichlistParams */
v8::Handle<v8::FunctionTemplate> _exports_api__RichlistParams_class = SWIGV8_CreateClassTemplate("_exports_api__RichlistParams");
SWIGV8_SET_CLASS_TEMPL(_exports_api__RichlistParams_clientData.class_templ, _exports_api__RichlistParams_class);
_exports_api__RichlistParams_clientData.dtor = _wrap_delete_api__RichlistParams;
if (SWIGTYPE_p_api__RichlistParams->clientdata == 0) {
  SWIGTYPE_p_api__RichlistParams->clientdata = &_exports_api__RichlistParams_clientData;
}
/* Name: _exports_api__NetworkConnectionsFilter, Type: p_api__NetworkConnectionsFilter, Dtor: _wrap_delete_api__NetworkConnectionsFilter */
v8::Handle<v8::FunctionTemplate> _exports_api__NetworkConnectionsFilter_class = SWIGV8_CreateClassTemplate("_exports_api__NetworkConnectionsFilter");
SWIGV8_SET_CLASS_TEMPL(_exports_api__NetworkConnectionsFilter_clientData.class_templ, _exports_api__NetworkConnectionsFilter_class);
_exports_api__NetworkConnectionsFilter_clientData.dtor = _wrap_delete_api__NetworkConnectionsFilter;
if (SWIGTYPE_p_api__NetworkConnectionsFilter->clientdata == 0) {
  SWIGTYPE_p_api__NetworkConnectionsFilter->clientdata = &_exports_api__NetworkConnectionsFilter_clientData;
}
/* Name: _exports_cipher__Address, Type: p_cipher__Address, Dtor: _wrap_delete_cipher__Address */
v8::Handle<v8::FunctionTemplate> _exports_cipher__Address_class = SWIGV8_CreateClassTemplate("_exports_cipher__Address");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher__Address_clientData.class_templ, _exports_cipher__Address_class);
_exports_cipher__Address_clientData.dtor = _wrap_delete_cipher__Address;
if (SWIGTYPE_p_cipher__Address->clientdata == 0) {
  SWIGTYPE_p_cipher__Address->clientdata = &_exports_cipher__Address_clientData;
}
/* Name: _exports_cipher__BitcoinAddress, Type: p_cipher__BitcoinAddress, Dtor: _wrap_delete_cipher__BitcoinAddress */
v8::Handle<v8::FunctionTemplate> _exports_cipher__BitcoinAddress_class = SWIGV8_CreateClassTemplate("_exports_cipher__BitcoinAddress");
SWIGV8_SET_CLASS_TEMPL(_exports_cipher__BitcoinAddress_clientData.class_templ, _exports_cipher__BitcoinAddress_class);
_exports_cipher__BitcoinAddress_clientData.dtor = _wrap_delete_cipher__BitcoinAddress;
if (SWIGTYPE_p_cipher__BitcoinAddress->clientdata == 0) {
  SWIGTYPE_p_cipher__BitcoinAddress->clientdata = &_exports_cipher__BitcoinAddress_clientData;
}
/* Name: _exports_encrypt__ScryptChacha20poly1305, Type: p_encrypt__ScryptChacha20poly1305, Dtor: _wrap_delete_encrypt__ScryptChacha20poly1305 */
v8::Handle<v8::FunctionTemplate> _exports_encrypt__ScryptChacha20poly1305_class = SWIGV8_CreateClassTemplate("_exports_encrypt__ScryptChacha20poly1305");
SWIGV8_SET_CLASS_TEMPL(_exports_encrypt__ScryptChacha20poly1305_clientData.class_templ, _exports_encrypt__ScryptChacha20poly1305_class);
_exports_encrypt__ScryptChacha20poly1305_clientData.dtor = _wrap_delete_encrypt__ScryptChacha20poly1305;
if (SWIGTYPE_p_encrypt__ScryptChacha20poly1305->clientdata == 0) {
  SWIGTYPE_p_encrypt__ScryptChacha20poly1305->clientdata = &_exports_encrypt__ScryptChacha20poly1305_clientData;
}
/* Name: _exports_secp256k1go__Field, Type: p_secp256k1go__Field, Dtor: _wrap_delete_secp256k1go__Field */
v8::Handle<v8::FunctionTemplate> _exports_secp256k1go__Field_class = SWIGV8_CreateClassTemplate("_exports_secp256k1go__Field");
SWIGV8_SET_CLASS_TEMPL(_exports_secp256k1go__Field_clientData.class_templ, _exports_secp256k1go__Field_class);
_exports_secp256k1go__Field_clientData.dtor = _wrap_delete_secp256k1go__Field;
if (SWIGTYPE_p_secp256k1go__Field->clientdata == 0) {
  SWIGTYPE_p_secp256k1go__Field->clientdata = &_exports_secp256k1go__Field_clientData;
}
/* Name: _exports_secp256k1go__XY, Type: p_secp256k1go__XY, Dtor: _wrap_delete_secp256k1go__XY */
v8::Handle<v8::FunctionTemplate> _exports_secp256k1go__XY_class = SWIGV8_CreateClassTemplate("_exports_secp256k1go__XY");
SWIGV8_SET_CLASS_TEMPL(_exports_secp256k1go__XY_clientData.class_templ, _exports_secp256k1go__XY_class);
_exports_secp256k1go__XY_clientData.dtor = _wrap_delete_secp256k1go__XY;
if (SWIGTYPE_p_secp256k1go__XY->clientdata == 0) {
  SWIGTYPE_p_secp256k1go__XY->clientdata = &_exports_secp256k1go__XY_clientData;
}
/* Name: _exports_secp256k1go__XYZ, Type: p_secp256k1go__XYZ, Dtor: _wrap_delete_secp256k1go__XYZ */
v8::Handle<v8::FunctionTemplate> _exports_secp256k1go__XYZ_class = SWIGV8_CreateClassTemplate("_exports_secp256k1go__XYZ");
SWIGV8_SET_CLASS_TEMPL(_exports_secp256k1go__XYZ_clientData.class_templ, _exports_secp256k1go__XYZ_class);
_exports_secp256k1go__XYZ_clientData.dtor = _wrap_delete_secp256k1go__XYZ;
if (SWIGTYPE_p_secp256k1go__XYZ->clientdata == 0) {
  SWIGTYPE_p_secp256k1go__XYZ->clientdata = &_exports_secp256k1go__XYZ_clientData;
}
/* Name: _exports_cli__SendAmount, Type: p_cli__SendAmount, Dtor: _wrap_delete_cli__SendAmount */
v8::Handle<v8::FunctionTemplate> _exports_cli__SendAmount_class = SWIGV8_CreateClassTemplate("_exports_cli__SendAmount");
SWIGV8_SET_CLASS_TEMPL(_exports_cli__SendAmount_clientData.class_templ, _exports_cli__SendAmount_class);
_exports_cli__SendAmount_clientData.dtor = _wrap_delete_cli__SendAmount;
if (SWIGTYPE_p_cli__SendAmount->clientdata == 0) {
  SWIGTYPE_p_cli__SendAmount->clientdata = &_exports_cli__SendAmount_clientData;
}
/* Name: _exports_coin__Transaction, Type: p_coin__Transaction, Dtor: _wrap_delete_coin__Transaction */
v8::Handle<v8::FunctionTemplate> _exports_coin__Transaction_class = SWIGV8_CreateClassTemplate("_exports_coin__Transaction");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__Transaction_clientData.class_templ, _exports_coin__Transaction_class);
_exports_coin__Transaction_clientData.dtor = _wrap_delete_coin__Transaction;
if (SWIGTYPE_p_coin__Transaction->clientdata == 0) {
  SWIGTYPE_p_coin__Transaction->clientdata = &_exports_coin__Transaction_clientData;
}
/* Name: _exports_coin__TransactionOutput, Type: p_coin__TransactionOutput, Dtor: _wrap_delete_coin__TransactionOutput */
v8::Handle<v8::FunctionTemplate> _exports_coin__TransactionOutput_class = SWIGV8_CreateClassTemplate("_exports_coin__TransactionOutput");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__TransactionOutput_clientData.class_templ, _exports_coin__TransactionOutput_class);
_exports_coin__TransactionOutput_clientData.dtor = _wrap_delete_coin__TransactionOutput;
if (SWIGTYPE_p_coin__TransactionOutput->clientdata == 0) {
  SWIGTYPE_p_coin__TransactionOutput->clientdata = &_exports_coin__TransactionOutput_clientData;
}
/* Name: _exports_coin__BlockHeader, Type: p_coin__BlockHeader, Dtor: _wrap_delete_coin__BlockHeader */
v8::Handle<v8::FunctionTemplate> _exports_coin__BlockHeader_class = SWIGV8_CreateClassTemplate("_exports_coin__BlockHeader");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__BlockHeader_clientData.class_templ, _exports_coin__BlockHeader_class);
_exports_coin__BlockHeader_clientData.dtor = _wrap_delete_coin__BlockHeader;
if (SWIGTYPE_p_coin__BlockHeader->clientdata == 0) {
  SWIGTYPE_p_coin__BlockHeader->clientdata = &_exports_coin__BlockHeader_clientData;
}
/* Name: _exports_coin__BlockBody, Type: p_coin__BlockBody, Dtor: _wrap_delete_coin__BlockBody */
v8::Handle<v8::FunctionTemplate> _exports_coin__BlockBody_class = SWIGV8_CreateClassTemplate("_exports_coin__BlockBody");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__BlockBody_clientData.class_templ, _exports_coin__BlockBody_class);
_exports_coin__BlockBody_clientData.dtor = _wrap_delete_coin__BlockBody;
if (SWIGTYPE_p_coin__BlockBody->clientdata == 0) {
  SWIGTYPE_p_coin__BlockBody->clientdata = &_exports_coin__BlockBody_clientData;
}
/* Name: _exports_coin__Block, Type: p_coin__Block, Dtor: _wrap_delete_coin__Block */
v8::Handle<v8::FunctionTemplate> _exports_coin__Block_class = SWIGV8_CreateClassTemplate("_exports_coin__Block");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__Block_clientData.class_templ, _exports_coin__Block_class);
_exports_coin__Block_clientData.dtor = _wrap_delete_coin__Block;
if (SWIGTYPE_p_coin__Block->clientdata == 0) {
  SWIGTYPE_p_coin__Block->clientdata = &_exports_coin__Block_clientData;
}
/* Name: _exports_coin__SignedBlock, Type: p_coin__SignedBlock, Dtor: _wrap_delete_coin__SignedBlock */
v8::Handle<v8::FunctionTemplate> _exports_coin__SignedBlock_class = SWIGV8_CreateClassTemplate("_exports_coin__SignedBlock");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__SignedBlock_clientData.class_templ, _exports_coin__SignedBlock_class);
_exports_coin__SignedBlock_clientData.dtor = _wrap_delete_coin__SignedBlock;
if (SWIGTYPE_p_coin__SignedBlock->clientdata == 0) {
  SWIGTYPE_p_coin__SignedBlock->clientdata = &_exports_coin__SignedBlock_clientData;
}
/* Name: _exports_coin__UxHead, Type: p_coin__UxHead, Dtor: _wrap_delete_coin__UxHead */
v8::Handle<v8::FunctionTemplate> _exports_coin__UxHead_class = SWIGV8_CreateClassTemplate("_exports_coin__UxHead");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__UxHead_clientData.class_templ, _exports_coin__UxHead_class);
_exports_coin__UxHead_clientData.dtor = _wrap_delete_coin__UxHead;
if (SWIGTYPE_p_coin__UxHead->clientdata == 0) {
  SWIGTYPE_p_coin__UxHead->clientdata = &_exports_coin__UxHead_clientData;
}
/* Name: _exports_coin__UxBody, Type: p_coin__UxBody, Dtor: _wrap_delete_coin__UxBody */
v8::Handle<v8::FunctionTemplate> _exports_coin__UxBody_class = SWIGV8_CreateClassTemplate("_exports_coin__UxBody");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__UxBody_clientData.class_templ, _exports_coin__UxBody_class);
_exports_coin__UxBody_clientData.dtor = _wrap_delete_coin__UxBody;
if (SWIGTYPE_p_coin__UxBody->clientdata == 0) {
  SWIGTYPE_p_coin__UxBody->clientdata = &_exports_coin__UxBody_clientData;
}
/* Name: _exports_coin__UxOut, Type: p_coin__UxOut, Dtor: _wrap_delete_coin__UxOut */
v8::Handle<v8::FunctionTemplate> _exports_coin__UxOut_class = SWIGV8_CreateClassTemplate("_exports_coin__UxOut");
SWIGV8_SET_CLASS_TEMPL(_exports_coin__UxOut_clientData.class_templ, _exports_coin__UxOut_class);
_exports_coin__UxOut_clientData.dtor = _wrap_delete_coin__UxOut;
if (SWIGTYPE_p_coin__UxOut->clientdata == 0) {
  SWIGTYPE_p_coin__UxOut->clientdata = &_exports_coin__UxOut_clientData;
}
/* Name: _exports_httphelper__Address, Type: p_httphelper__Address, Dtor: _wrap_delete_httphelper__Address */
v8::Handle<v8::FunctionTemplate> _exports_httphelper__Address_class = SWIGV8_CreateClassTemplate("_exports_httphelper__Address");
SWIGV8_SET_CLASS_TEMPL(_exports_httphelper__Address_clientData.class_templ, _exports_httphelper__Address_class);
_exports_httphelper__Address_clientData.dtor = _wrap_delete_httphelper__Address;
if (SWIGTYPE_p_httphelper__Address->clientdata == 0) {
  SWIGTYPE_p_httphelper__Address->clientdata = &_exports_httphelper__Address_clientData;
}
/* Name: _exports_httphelper__SHA256, Type: p_httphelper__SHA256, Dtor: _wrap_delete_httphelper__SHA256 */
v8::Handle<v8::FunctionTemplate> _exports_httphelper__SHA256_class = SWIGV8_CreateClassTemplate("_exports_httphelper__SHA256");
SWIGV8_SET_CLASS_TEMPL(_exports_httphelper__SHA256_clientData.class_templ, _exports_httphelper__SHA256_class);
_exports_httphelper__SHA256_clientData.dtor = _wrap_delete_httphelper__SHA256;
if (SWIGTYPE_p_httphelper__SHA256->clientdata == 0) {
  SWIGTYPE_p_httphelper__SHA256->clientdata = &_exports_httphelper__SHA256_clientData;
}
/* Name: _exports_wallet__Balance, Type: p_wallet__Balance, Dtor: _wrap_delete_wallet__Balance */
v8::Handle<v8::FunctionTemplate> _exports_wallet__Balance_class = SWIGV8_CreateClassTemplate("_exports_wallet__Balance");
SWIGV8_SET_CLASS_TEMPL(_exports_wallet__Balance_clientData.class_templ, _exports_wallet__Balance_class);
_exports_wallet__Balance_clientData.dtor = _wrap_delete_wallet__Balance;
if (SWIGTYPE_p_wallet__Balance->clientdata == 0) {
  SWIGTYPE_p_wallet__Balance->clientdata = &_exports_wallet__Balance_clientData;
}
/* Name: _exports_wallet__BalancePair, Type: p_wallet__BalancePair, Dtor: _wrap_delete_wallet__BalancePair */
v8::Handle<v8::FunctionTemplate> _exports_wallet__BalancePair_class = SWIGV8_CreateClassTemplate("_exports_wallet__BalancePair");
SWIGV8_SET_CLASS_TEMPL(_exports_wallet__BalancePair_clientData.class_templ, _exports_wallet__BalancePair_class);
_exports_wallet__BalancePair_clientData.dtor = _wrap_delete_wallet__BalancePair;
if (SWIGTYPE_p_wallet__BalancePair->clientdata == 0) {
  SWIGTYPE_p_wallet__BalancePair->clientdata = &_exports_wallet__BalancePair_clientData;
}
/* Name: _exports_wallet__Entry, Type: p_wallet__Entry, Dtor: _wrap_delete_wallet__Entry */
v8::Handle<v8::FunctionTemplate> _exports_wallet__Entry_class = SWIGV8_CreateClassTemplate("_exports_wallet__Entry");
SWIGV8_SET_CLASS_TEMPL(_exports_wallet__Entry_clientData.class_templ, _exports_wallet__Entry_class);
_exports_wallet__Entry_clientData.dtor = _wrap_delete_wallet__Entry;
if (SWIGTYPE_p_wallet__Entry->clientdata == 0) {
  SWIGTYPE_p_wallet__Entry->clientdata = &_exports_wallet__Entry_clientData;
}
/* Name: _exports_wallet__Note, Type: p_wallet__Note, Dtor: _wrap_delete_wallet__Note */
v8::Handle<v8::FunctionTemplate> _exports_wallet__Note_class = SWIGV8_CreateClassTemplate("_exports_wallet__Note");
SWIGV8_SET_CLASS_TEMPL(_exports_wallet__Note_clientData.class_templ, _exports_wallet__Note_class);
_exports_wallet__Note_clientData.dtor = _wrap_delete_wallet__Note;
if (SWIGTYPE_p_wallet__Note->clientdata == 0) {
  SWIGTYPE_p_wallet__Note->clientdata = &_exports_wallet__Note_clientData;
}
/* Name: _exports_wallet__ReadableNote, Type: p_wallet__ReadableNote, Dtor: _wrap_delete_wallet__ReadableNote */
v8::Handle<v8::FunctionTemplate> _exports_wallet__ReadableNote_class = SWIGV8_CreateClassTemplate("_exports_wallet__ReadableNote");
SWIGV8_SET_CLASS_TEMPL(_exports_wallet__ReadableNote_clientData.class_templ, _exports_wallet__ReadableNote_class);
_exports_wallet__ReadableNote_clientData.dtor = _wrap_delete_wallet__ReadableNote;
if (SWIGTYPE_p_wallet__ReadableNote->clientdata == 0) {
  SWIGTYPE_p_wallet__ReadableNote->clientdata = &_exports_wallet__ReadableNote_clientData;
}
/* Name: _exports_transaction__UxBalance, Type: p_transaction__UxBalance, Dtor: _wrap_delete_transaction__UxBalance */
v8::Handle<v8::FunctionTemplate> _exports_transaction__UxBalance_class = SWIGV8_CreateClassTemplate("_exports_transaction__UxBalance");
SWIGV8_SET_CLASS_TEMPL(_exports_transaction__UxBalance_clientData.class_templ, _exports_transaction__UxBalance_class);
_exports_transaction__UxBalance_clientData.dtor = _wrap_delete_transaction__UxBalance;
if (SWIGTYPE_p_transaction__UxBalance->clientdata == 0) {
  SWIGTYPE_p_transaction__UxBalance->clientdata = &_exports_transaction__UxBalance_clientData;
}
/* Name: _exports_api__TransactionInput, Type: p_api__TransactionInput, Dtor: _wrap_delete_api__TransactionInput */
v8::Handle<v8::FunctionTemplate> _exports_api__TransactionInput_class = SWIGV8_CreateClassTemplate("_exports_api__TransactionInput");
SWIGV8_SET_CLASS_TEMPL(_exports_api__TransactionInput_clientData.class_templ, _exports_api__TransactionInput_class);
_exports_api__TransactionInput_clientData.dtor = _wrap_delete_api__TransactionInput;
if (SWIGTYPE_p_api__TransactionInput->clientdata == 0) {
  SWIGTYPE_p_api__TransactionInput->clientdata = &_exports_api__TransactionInput_clientData;
}
/* Name: _exports_GoComplex64_, Type: p_GoComplex64_, Dtor: _wrap_delete_GoComplex64_ */
v8::Handle<v8::FunctionTemplate> _exports_GoComplex64__class = SWIGV8_CreateClassTemplate("_exports_GoComplex64_");
SWIGV8_SET_CLASS_TEMPL(_exports_GoComplex64__clientData.class_templ, _exports_GoComplex64__class);
_exports_GoComplex64__clientData.dtor = _wrap_delete_GoComplex64_;
if (SWIGTYPE_p_GoComplex64_->clientdata == 0) {
  SWIGTYPE_p_GoComplex64_->clientdata = &_exports_GoComplex64__clientData;
}
/* Name: _exports_GoComplex128_, Type: p_GoComplex128_, Dtor: _wrap_delete_GoComplex128_ */
v8::Handle<v8::FunctionTemplate> _exports_GoComplex128__class = SWIGV8_CreateClassTemplate("_exports_GoComplex128_");
SWIGV8_SET_CLASS_TEMPL(_exports_GoComplex128__clientData.class_templ, _exports_GoComplex128__class);
_exports_GoComplex128__clientData.dtor = _wrap_delete_GoComplex128_;
if (SWIGTYPE_p_GoComplex128_->clientdata == 0) {
  SWIGTYPE_p_GoComplex128_->clientdata = &_exports_GoComplex128__clientData;
}
/* Name: _exports_GoString_, Type: p_GoString_, Dtor: _wrap_delete_GoString_ */
v8::Handle<v8::FunctionTemplate> _exports_GoString__class = SWIGV8_CreateClassTemplate("_exports_GoString_");
SWIGV8_SET_CLASS_TEMPL(_exports_GoString__clientData.class_templ, _exports_GoString__class);
_exports_GoString__clientData.dtor = _wrap_delete_GoString_;
if (SWIGTYPE_p_GoString_->clientdata == 0) {
  SWIGTYPE_p_GoString_->clientdata = &_exports_GoString__clientData;
}
/* Name: _exports_GoInterface_, Type: p_GoInterface_, Dtor: _wrap_delete_GoInterface_ */
v8::Handle<v8::FunctionTemplate> _exports_GoInterface__class = SWIGV8_CreateClassTemplate("_exports_GoInterface_");
SWIGV8_SET_CLASS_TEMPL(_exports_GoInterface__clientData.class_templ, _exports_GoInterface__class);
_exports_GoInterface__clientData.dtor = _wrap_delete_GoInterface_;
if (SWIGTYPE_p_GoInterface_->clientdata == 0) {
  SWIGTYPE_p_GoInterface_->clientdata = &_exports_GoInterface__clientData;
}
/* Name: _exports_GoSlice_, Type: p_GoSlice_, Dtor: _wrap_delete_GoSlice_ */
v8::Handle<v8::FunctionTemplate> _exports_GoSlice__class = SWIGV8_CreateClassTemplate("_exports_GoSlice_");
SWIGV8_SET_CLASS_TEMPL(_exports_GoSlice__clientData.class_templ, _exports_GoSlice__class);
_exports_GoSlice__clientData.dtor = _wrap_delete_GoSlice_;
if (SWIGTYPE_p_GoSlice_->clientdata == 0) {
  SWIGTYPE_p_GoSlice_->clientdata = &_exports_GoSlice__clientData;
}
/* Name: _exports_Number, Type: p_Number, Dtor: _wrap_delete_Number */
v8::Handle<v8::FunctionTemplate> _exports_Number_class = SWIGV8_CreateClassTemplate("_exports_Number");
SWIGV8_SET_CLASS_TEMPL(_exports_Number_clientData.class_templ, _exports_Number_class);
_exports_Number_clientData.dtor = _wrap_delete_Number;
if (SWIGTYPE_p_Number->clientdata == 0) {
  SWIGTYPE_p_Number->clientdata = &_exports_Number_clientData;
}
/* Name: _exports_Signature, Type: p_Signature, Dtor: _wrap_delete_Signature */
v8::Handle<v8::FunctionTemplate> _exports_Signature_class = SWIGV8_CreateClassTemplate("_exports_Signature");
SWIGV8_SET_CLASS_TEMPL(_exports_Signature_clientData.class_templ, _exports_Signature_class);
_exports_Signature_clientData.dtor = _wrap_delete_Signature;
if (SWIGTYPE_p_Signature->clientdata == 0) {
  SWIGTYPE_p_Signature->clientdata = &_exports_Signature_clientData;
}
/* Name: _exports_Wallet, Type: p_Wallet, Dtor: _wrap_delete_Wallet */
v8::Handle<v8::FunctionTemplate> _exports_Wallet_class = SWIGV8_CreateClassTemplate("_exports_Wallet");
SWIGV8_SET_CLASS_TEMPL(_exports_Wallet_clientData.class_templ, _exports_Wallet_class);
_exports_Wallet_clientData.dtor = _wrap_delete_Wallet;
if (SWIGTYPE_p_Wallet->clientdata == 0) {
  SWIGTYPE_p_Wallet->clientdata = &_exports_Wallet_clientData;
}
/* Name: _exports_FeeCalculator, Type: p_FeeCalculator, Dtor: _wrap_delete_FeeCalculator */
v8::Handle<v8::FunctionTemplate> _exports_FeeCalculator_class = SWIGV8_CreateClassTemplate("_exports_FeeCalculator");
SWIGV8_SET_CLASS_TEMPL(_exports_FeeCalculator_clientData.class_templ, _exports_FeeCalculator_class);
_exports_FeeCalculator_clientData.dtor = _wrap_delete_FeeCalculator;
if (SWIGTYPE_p_FeeCalculator->clientdata == 0) {
  SWIGTYPE_p_FeeCalculator->clientdata = &_exports_FeeCalculator_clientData;
}


  /* register wrapper functions */
  SWIGV8_AddMemberVariable(_exports_cipher_PubKey_class, "data", _wrap_cipher_PubKey_data_get, _wrap_cipher_PubKey_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_SecKey_class, "data", _wrap_cipher_SecKey_data_get, _wrap_cipher_SecKey_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_Ripemd160_class, "data", _wrap_cipher_Ripemd160_data_get, _wrap_cipher_Ripemd160_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_Sig_class, "data", _wrap_cipher_Sig_data_get, _wrap_cipher_Sig_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_SHA256_class, "data", _wrap_cipher_SHA256_data_get, _wrap_cipher_SHA256_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_Checksum_class, "data", _wrap_cipher_Checksum_data_get, _wrap_cipher_Checksum_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_SecKeys_class, "data", _wrap_cipher_SecKeys_data_get, _wrap_cipher_SecKeys_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_SecKeys_class, "count", _wrap_cipher_SecKeys_count_get, _wrap_cipher_SecKeys_count_set);
SWIGV8_AddMemberVariable(_exports_cipher_PubKeys_class, "data", _wrap_cipher_PubKeys_data_get, _wrap_cipher_PubKeys_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_PubKeys_class, "count", _wrap_cipher_PubKeys_count_get, _wrap_cipher_PubKeys_count_set);
SWIGV8_AddMemberVariable(_exports_cipher_SHA256s_class, "data", _wrap_cipher_SHA256s_data_get, _wrap_cipher_SHA256s_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_SHA256s_class, "count", _wrap_cipher_SHA256s_count_get, _wrap_cipher_SHA256s_count_set);
SWIGV8_AddMemberVariable(_exports_coin_UxOutArray_class, "data", _wrap_coin_UxOutArray_data_get, _wrap_coin_UxOutArray_data_set);
SWIGV8_AddMemberVariable(_exports_coin_UxOutArray_class, "count", _wrap_coin_UxOutArray_count_get, _wrap_coin_UxOutArray_count_set);
SWIGV8_AddMemberVariable(_exports_cipher_Addresses_class, "data", _wrap_cipher_Addresses_data_get, _wrap_cipher_Addresses_data_set);
SWIGV8_AddMemberVariable(_exports_cipher_Addresses_class, "count", _wrap_cipher_Addresses_count_get, _wrap_cipher_Addresses_count_set);
SWIGV8_AddMemberVariable(_exports_Fee_Calculator_class, "callback", _wrap_Fee_Calculator_callback_get, _wrap_Fee_Calculator_callback_set);
SWIGV8_AddMemberVariable(_exports_Fee_Calculator_class, "context", _wrap_Fee_Calculator_context_get, _wrap_Fee_Calculator_context_set);
SWIGV8_AddMemberFunction(_exports__GoString__class, "SetString", _wrap__GoString__SetString);
SWIGV8_AddMemberFunction(_exports__GoString__class, "getString", _wrap__GoString__getString);
SWIGV8_AddMemberFunction(_exports__GoString__class, "isEqual", _wrap__GoString__isEqual);
SWIGV8_AddMemberVariable(_exports__GoString__class, "p", _wrap__GoString__p_get, _wrap__GoString__p_set);
SWIGV8_AddMemberVariable(_exports__GoString__class, "n", _wrap__GoString__n_get, _wrap__GoString__n_set);
SWIGV8_AddMemberVariable(_exports_GoInterface_class, "t", _wrap_GoInterface_t_get, _wrap_GoInterface_t_set);
SWIGV8_AddMemberVariable(_exports_GoInterface_class, "v", _wrap_GoInterface_v_get, _wrap_GoInterface_v_set);
SWIGV8_AddMemberFunction(_exports_GoSlice_class, "isEqual", _wrap_GoSlice_isEqual);
SWIGV8_AddMemberFunction(_exports_GoSlice_class, "convertString", _wrap_GoSlice_convertString);
SWIGV8_AddMemberFunction(_exports_GoSlice_class, "setAtChar", _wrap_GoSlice_setAtChar);
SWIGV8_AddMemberFunction(_exports_GoSlice_class, "getString", _wrap_GoSlice_getString);
SWIGV8_AddMemberFunction(_exports_GoSlice_class, "getAtString", _wrap_GoSlice_getAtString);
SWIGV8_AddMemberVariable(_exports_GoSlice_class, "data", _wrap_GoSlice_data_get, _wrap_GoSlice_data_set);
SWIGV8_AddMemberVariable(_exports_GoSlice_class, "len", _wrap_GoSlice_len_get, _wrap_GoSlice_len_set);
SWIGV8_AddMemberVariable(_exports_GoSlice_class, "cap", _wrap_GoSlice_cap_get, _wrap_GoSlice_cap_set);
SWIGV8_AddMemberVariable(_exports_api__RichlistParams_class, "N", _wrap_api__RichlistParams_N_get, _wrap_api__RichlistParams_N_set);
SWIGV8_AddMemberVariable(_exports_api__RichlistParams_class, "IncludeDistribution", _wrap_api__RichlistParams_IncludeDistribution_get, _wrap_api__RichlistParams_IncludeDistribution_set);
SWIGV8_AddMemberVariable(_exports_api__NetworkConnectionsFilter_class, "States", _wrap_api__NetworkConnectionsFilter_States_get, _wrap_api__NetworkConnectionsFilter_States_set);
SWIGV8_AddMemberVariable(_exports_api__NetworkConnectionsFilter_class, "Direction", _wrap_api__NetworkConnectionsFilter_Direction_get, _wrap_api__NetworkConnectionsFilter_Direction_set);
SWIGV8_AddMemberVariable(_exports_cipher__Address_class, "Version", _wrap_cipher__Address_Version_get, _wrap_cipher__Address_Version_set);
SWIGV8_AddMemberVariable(_exports_cipher__Address_class, "Key", _wrap_cipher__Address_Key_get, _wrap_cipher__Address_Key_set);
SWIGV8_AddMemberVariable(_exports_cipher__BitcoinAddress_class, "Version", _wrap_cipher__BitcoinAddress_Version_get, _wrap_cipher__BitcoinAddress_Version_set);
SWIGV8_AddMemberVariable(_exports_cipher__BitcoinAddress_class, "Key", _wrap_cipher__BitcoinAddress_Key_get, _wrap_cipher__BitcoinAddress_Key_set);
SWIGV8_AddMemberVariable(_exports_encrypt__ScryptChacha20poly1305_class, "N", _wrap_encrypt__ScryptChacha20poly1305_N_get, _wrap_encrypt__ScryptChacha20poly1305_N_set);
SWIGV8_AddMemberVariable(_exports_encrypt__ScryptChacha20poly1305_class, "R", _wrap_encrypt__ScryptChacha20poly1305_R_get, _wrap_encrypt__ScryptChacha20poly1305_R_set);
SWIGV8_AddMemberVariable(_exports_encrypt__ScryptChacha20poly1305_class, "P", _wrap_encrypt__ScryptChacha20poly1305_P_get, _wrap_encrypt__ScryptChacha20poly1305_P_set);
SWIGV8_AddMemberVariable(_exports_encrypt__ScryptChacha20poly1305_class, "KeyLen", _wrap_encrypt__ScryptChacha20poly1305_KeyLen_get, _wrap_encrypt__ScryptChacha20poly1305_KeyLen_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__Field_class, "n", _wrap_secp256k1go__Field_n_get, _wrap_secp256k1go__Field_n_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__XY_class, "X", _wrap_secp256k1go__XY_X_get, _wrap_secp256k1go__XY_X_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__XY_class, "Y", _wrap_secp256k1go__XY_Y_get, _wrap_secp256k1go__XY_Y_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__XY_class, "Infinity", _wrap_secp256k1go__XY_Infinity_get, _wrap_secp256k1go__XY_Infinity_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__XYZ_class, "X", _wrap_secp256k1go__XYZ_X_get, _wrap_secp256k1go__XYZ_X_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__XYZ_class, "Y", _wrap_secp256k1go__XYZ_Y_get, _wrap_secp256k1go__XYZ_Y_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__XYZ_class, "Z", _wrap_secp256k1go__XYZ_Z_get, _wrap_secp256k1go__XYZ_Z_set);
SWIGV8_AddMemberVariable(_exports_secp256k1go__XYZ_class, "Infinity", _wrap_secp256k1go__XYZ_Infinity_get, _wrap_secp256k1go__XYZ_Infinity_set);
SWIGV8_AddMemberVariable(_exports_cli__SendAmount_class, "Addr", _wrap_cli__SendAmount_Addr_get, _wrap_cli__SendAmount_Addr_set);
SWIGV8_AddMemberVariable(_exports_cli__SendAmount_class, "Coins", _wrap_cli__SendAmount_Coins_get, _wrap_cli__SendAmount_Coins_set);
SWIGV8_AddMemberVariable(_exports_coin__Transaction_class, "Length", _wrap_coin__Transaction_Length_get, _wrap_coin__Transaction_Length_set);
SWIGV8_AddMemberVariable(_exports_coin__Transaction_class, "Type", _wrap_coin__Transaction_Type_get, _wrap_coin__Transaction_Type_set);
SWIGV8_AddMemberVariable(_exports_coin__Transaction_class, "InnerHash", _wrap_coin__Transaction_InnerHash_get, _wrap_coin__Transaction_InnerHash_set);
SWIGV8_AddMemberVariable(_exports_coin__Transaction_class, "Sigs", _wrap_coin__Transaction_Sigs_get, _wrap_coin__Transaction_Sigs_set);
SWIGV8_AddMemberVariable(_exports_coin__Transaction_class, "In", _wrap_coin__Transaction_In_get, _wrap_coin__Transaction_In_set);
SWIGV8_AddMemberVariable(_exports_coin__Transaction_class, "Out", _wrap_coin__Transaction_Out_get, _wrap_coin__Transaction_Out_set);
SWIGV8_AddMemberVariable(_exports_coin__TransactionOutput_class, "Address", _wrap_coin__TransactionOutput_Address_get, _wrap_coin__TransactionOutput_Address_set);
SWIGV8_AddMemberVariable(_exports_coin__TransactionOutput_class, "Coins", _wrap_coin__TransactionOutput_Coins_get, _wrap_coin__TransactionOutput_Coins_set);
SWIGV8_AddMemberVariable(_exports_coin__TransactionOutput_class, "Hours", _wrap_coin__TransactionOutput_Hours_get, _wrap_coin__TransactionOutput_Hours_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockHeader_class, "Version", _wrap_coin__BlockHeader_Version_get, _wrap_coin__BlockHeader_Version_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockHeader_class, "Time", _wrap_coin__BlockHeader_Time_get, _wrap_coin__BlockHeader_Time_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockHeader_class, "BkSeq", _wrap_coin__BlockHeader_BkSeq_get, _wrap_coin__BlockHeader_BkSeq_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockHeader_class, "Fee", _wrap_coin__BlockHeader_Fee_get, _wrap_coin__BlockHeader_Fee_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockHeader_class, "PrevHash", _wrap_coin__BlockHeader_PrevHash_get, _wrap_coin__BlockHeader_PrevHash_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockHeader_class, "BodyHash", _wrap_coin__BlockHeader_BodyHash_get, _wrap_coin__BlockHeader_BodyHash_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockHeader_class, "UxHash", _wrap_coin__BlockHeader_UxHash_get, _wrap_coin__BlockHeader_UxHash_set);
SWIGV8_AddMemberVariable(_exports_coin__BlockBody_class, "Transactions", _wrap_coin__BlockBody_Transactions_get, _wrap_coin__BlockBody_Transactions_set);
SWIGV8_AddMemberVariable(_exports_coin__Block_class, "Head", _wrap_coin__Block_Head_get, _wrap_coin__Block_Head_set);
SWIGV8_AddMemberVariable(_exports_coin__Block_class, "Body", _wrap_coin__Block_Body_get, _wrap_coin__Block_Body_set);
SWIGV8_AddMemberVariable(_exports_coin__SignedBlock_class, "_unnamed", _wrap_coin__SignedBlock__unnamed_get, _wrap_coin__SignedBlock__unnamed_set);
SWIGV8_AddMemberVariable(_exports_coin__SignedBlock_class, "Sig", _wrap_coin__SignedBlock_Sig_get, _wrap_coin__SignedBlock_Sig_set);
SWIGV8_AddMemberVariable(_exports_coin__UxHead_class, "Time", _wrap_coin__UxHead_Time_get, _wrap_coin__UxHead_Time_set);
SWIGV8_AddMemberVariable(_exports_coin__UxHead_class, "BkSeq", _wrap_coin__UxHead_BkSeq_get, _wrap_coin__UxHead_BkSeq_set);
SWIGV8_AddMemberVariable(_exports_coin__UxBody_class, "SrcTransaction", _wrap_coin__UxBody_SrcTransaction_get, _wrap_coin__UxBody_SrcTransaction_set);
SWIGV8_AddMemberVariable(_exports_coin__UxBody_class, "Address", _wrap_coin__UxBody_Address_get, _wrap_coin__UxBody_Address_set);
SWIGV8_AddMemberVariable(_exports_coin__UxBody_class, "Coins", _wrap_coin__UxBody_Coins_get, _wrap_coin__UxBody_Coins_set);
SWIGV8_AddMemberVariable(_exports_coin__UxBody_class, "Hours", _wrap_coin__UxBody_Hours_get, _wrap_coin__UxBody_Hours_set);
SWIGV8_AddMemberVariable(_exports_coin__UxOut_class, "Head", _wrap_coin__UxOut_Head_get, _wrap_coin__UxOut_Head_set);
SWIGV8_AddMemberVariable(_exports_coin__UxOut_class, "Body", _wrap_coin__UxOut_Body_get, _wrap_coin__UxOut_Body_set);
SWIGV8_AddMemberVariable(_exports_httphelper__Address_class, "_unnamed", _wrap_httphelper__Address__unnamed_get, _wrap_httphelper__Address__unnamed_set);
SWIGV8_AddMemberVariable(_exports_httphelper__SHA256_class, "_unnamed", _wrap_httphelper__SHA256__unnamed_get, _wrap_httphelper__SHA256__unnamed_set);
SWIGV8_AddMemberVariable(_exports_wallet__Balance_class, "Coins", _wrap_wallet__Balance_Coins_get, _wrap_wallet__Balance_Coins_set);
SWIGV8_AddMemberVariable(_exports_wallet__Balance_class, "Hours", _wrap_wallet__Balance_Hours_get, _wrap_wallet__Balance_Hours_set);
SWIGV8_AddMemberVariable(_exports_wallet__BalancePair_class, "Confirmed", _wrap_wallet__BalancePair_Confirmed_get, _wrap_wallet__BalancePair_Confirmed_set);
SWIGV8_AddMemberVariable(_exports_wallet__BalancePair_class, "Predicted", _wrap_wallet__BalancePair_Predicted_get, _wrap_wallet__BalancePair_Predicted_set);
SWIGV8_AddMemberVariable(_exports_wallet__Entry_class, "Address", _wrap_wallet__Entry_Address_get, _wrap_wallet__Entry_Address_set);
SWIGV8_AddMemberVariable(_exports_wallet__Entry_class, "Public", _wrap_wallet__Entry_Public_get, _wrap_wallet__Entry_Public_set);
SWIGV8_AddMemberVariable(_exports_wallet__Entry_class, "Secret", _wrap_wallet__Entry_Secret_get, _wrap_wallet__Entry_Secret_set);
SWIGV8_AddMemberVariable(_exports_wallet__Note_class, "TxID", _wrap_wallet__Note_TxID_get, _wrap_wallet__Note_TxID_set);
SWIGV8_AddMemberVariable(_exports_wallet__Note_class, "Value", _wrap_wallet__Note_Value_get, _wrap_wallet__Note_Value_set);
SWIGV8_AddMemberVariable(_exports_wallet__ReadableNote_class, "TransactionID", _wrap_wallet__ReadableNote_TransactionID_get, _wrap_wallet__ReadableNote_TransactionID_set);
SWIGV8_AddMemberVariable(_exports_wallet__ReadableNote_class, "ActualNote", _wrap_wallet__ReadableNote_ActualNote_get, _wrap_wallet__ReadableNote_ActualNote_set);
SWIGV8_AddMemberVariable(_exports_transaction__UxBalance_class, "Hash", _wrap_transaction__UxBalance_Hash_get, _wrap_transaction__UxBalance_Hash_set);
SWIGV8_AddMemberVariable(_exports_transaction__UxBalance_class, "BkSeq", _wrap_transaction__UxBalance_BkSeq_get, _wrap_transaction__UxBalance_BkSeq_set);
SWIGV8_AddMemberVariable(_exports_transaction__UxBalance_class, "Address", _wrap_transaction__UxBalance_Address_get, _wrap_transaction__UxBalance_Address_set);
SWIGV8_AddMemberVariable(_exports_transaction__UxBalance_class, "Coins", _wrap_transaction__UxBalance_Coins_get, _wrap_transaction__UxBalance_Coins_set);
SWIGV8_AddMemberVariable(_exports_transaction__UxBalance_class, "Hours", _wrap_transaction__UxBalance_Hours_get, _wrap_transaction__UxBalance_Hours_set);
SWIGV8_AddMemberVariable(_exports_transaction__UxBalance_class, "InitialHours", _wrap_transaction__UxBalance_InitialHours_get, _wrap_transaction__UxBalance_InitialHours_set);
SWIGV8_AddMemberVariable(_exports_transaction__UxBalance_class, "SrcTransaction", _wrap_transaction__UxBalance_SrcTransaction_get, _wrap_transaction__UxBalance_SrcTransaction_set);
SWIGV8_AddMemberVariable(_exports_api__TransactionInput_class, "UxOut", _wrap_api__TransactionInput_UxOut_get, _wrap_api__TransactionInput_UxOut_set);
SWIGV8_AddMemberVariable(_exports_api__TransactionInput_class, "CalculatedHours", _wrap_api__TransactionInput_CalculatedHours_get, _wrap_api__TransactionInput_CalculatedHours_set);
SWIGV8_AddStaticVariable(exports_obj, "SKY_OK", _wrap_SKY_OK, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ERROR", _wrap_SKY_ERROR, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_BAD_HANDLE", _wrap_SKY_BAD_HANDLE, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_INVALID_TIMESTRING", _wrap_SKY_INVALID_TIMESTRING, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_API", _wrap_SKY_PKG_API, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_CIPHER", _wrap_SKY_PKG_CIPHER, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_CLI", _wrap_SKY_PKG_CLI, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_COIN", _wrap_SKY_PKG_COIN, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_CONSENSUS", _wrap_SKY_PKG_CONSENSUS, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_DAEMON", _wrap_SKY_PKG_DAEMON, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_GUI", _wrap_SKY_PKG_GUI, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_SKYCOIN", _wrap_SKY_PKG_SKYCOIN, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_UTIL", _wrap_SKY_PKG_UTIL, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_VISOR", _wrap_SKY_PKG_VISOR, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_WALLET", _wrap_SKY_PKG_WALLET, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_PARAMS", _wrap_SKY_PKG_PARAMS, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_PKG_LIBCGO", _wrap_SKY_PKG_LIBCGO, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddressInvalidLength", _wrap_SKY_ErrAddressInvalidLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddressInvalidChecksum", _wrap_SKY_ErrAddressInvalidChecksum, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddressInvalidVersion", _wrap_SKY_ErrAddressInvalidVersion, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddressInvalidPubKey", _wrap_SKY_ErrAddressInvalidPubKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddressInvalidFirstByte", _wrap_SKY_ErrAddressInvalidFirstByte, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddressInvalidLastByte", _wrap_SKY_ErrAddressInvalidLastByte, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrBufferUnderflow", _wrap_SKY_ErrBufferUnderflow, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidOmitEmpty", _wrap_SKY_ErrInvalidOmitEmpty, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidLengthPubKey", _wrap_SKY_ErrInvalidLengthPubKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrPubKeyFromNullSecKey", _wrap_SKY_ErrPubKeyFromNullSecKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrPubKeyFromBadSecKey", _wrap_SKY_ErrPubKeyFromBadSecKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidLengthSecKey", _wrap_SKY_ErrInvalidLengthSecKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrECHDInvalidPubKey", _wrap_SKY_ErrECHDInvalidPubKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrECHDInvalidSecKey", _wrap_SKY_ErrECHDInvalidSecKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidLengthSig", _wrap_SKY_ErrInvalidLengthSig, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidLengthRipemd160", _wrap_SKY_ErrInvalidLengthRipemd160, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidLengthSHA256", _wrap_SKY_ErrInvalidLengthSHA256, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidBase58Char", _wrap_SKY_ErrInvalidBase58Char, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidBase58String", _wrap_SKY_ErrInvalidBase58String, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidBase58Length", _wrap_SKY_ErrInvalidBase58Length, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidHexLength", _wrap_SKY_ErrInvalidHexLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidBytesLength", _wrap_SKY_ErrInvalidBytesLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidPubKey", _wrap_SKY_ErrInvalidPubKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSecKey", _wrap_SKY_ErrInvalidSecKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSigPubKeyRecovery", _wrap_SKY_ErrInvalidSigPubKeyRecovery, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSecKeyHex", _wrap_SKY_ErrInvalidSecKeyHex, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidAddressForSig", _wrap_SKY_ErrInvalidAddressForSig, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidHashForSig", _wrap_SKY_ErrInvalidHashForSig, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrPubKeyRecoverMismatch", _wrap_SKY_ErrPubKeyRecoverMismatch, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSigInvalidPubKey", _wrap_SKY_ErrInvalidSigInvalidPubKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSigValidity", _wrap_SKY_ErrInvalidSigValidity, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSigForMessage", _wrap_SKY_ErrInvalidSigForMessage, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSecKyVerification", _wrap_SKY_ErrInvalidSecKyVerification, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNullPubKeyFromSecKey", _wrap_SKY_ErrNullPubKeyFromSecKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidDerivedPubKeyFromSecKey", _wrap_SKY_ErrInvalidDerivedPubKeyFromSecKey, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidPubKeyFromHash", _wrap_SKY_ErrInvalidPubKeyFromHash, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrPubKeyFromSecKeyMismatch", _wrap_SKY_ErrPubKeyFromSecKeyMismatch, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidLength", _wrap_SKY_ErrInvalidLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrBitcoinWIFInvalidFirstByte", _wrap_SKY_ErrBitcoinWIFInvalidFirstByte, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrBitcoinWIFInvalidSuffix", _wrap_SKY_ErrBitcoinWIFInvalidSuffix, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrBitcoinWIFInvalidChecksum", _wrap_SKY_ErrBitcoinWIFInvalidChecksum, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrEmptySeed", _wrap_SKY_ErrEmptySeed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidSig", _wrap_SKY_ErrInvalidSig, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingPassword", _wrap_SKY_ErrMissingPassword, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDataTooLarge", _wrap_SKY_ErrDataTooLarge, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidChecksumLength", _wrap_SKY_ErrInvalidChecksumLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidChecksum", _wrap_SKY_ErrInvalidChecksum, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidNonceLength", _wrap_SKY_ErrInvalidNonceLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidBlockSize", _wrap_SKY_ErrInvalidBlockSize, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrReadDataHashFailed", _wrap_SKY_ErrReadDataHashFailed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidPassword", _wrap_SKY_ErrInvalidPassword, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrReadDataLengthFailed", _wrap_SKY_ErrReadDataLengthFailed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidDataLength", _wrap_SKY_ErrInvalidDataLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTemporaryInsufficientBalance", _wrap_SKY_ErrTemporaryInsufficientBalance, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddress", _wrap_SKY_ErrAddress, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletName", _wrap_SKY_ErrWalletName, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrJSONMarshal", _wrap_SKY_ErrJSONMarshal, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_WalletLoadError", _wrap_SKY_WalletLoadError, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_WalletSaveError", _wrap_SKY_WalletSaveError, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrAddEarnedCoinHoursAdditionOverflow", _wrap_SKY_ErrAddEarnedCoinHoursAdditionOverflow, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUint64MultOverflow", _wrap_SKY_ErrUint64MultOverflow, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUint64AddOverflow", _wrap_SKY_ErrUint64AddOverflow, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUint32AddOverflow", _wrap_SKY_ErrUint32AddOverflow, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUint64OverflowsInt64", _wrap_SKY_ErrUint64OverflowsInt64, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInt64UnderflowsUint64", _wrap_SKY_ErrInt64UnderflowsUint64, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrIntUnderflowsUint32", _wrap_SKY_ErrIntUnderflowsUint32, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrIntOverflowsUint32", _wrap_SKY_ErrIntOverflowsUint32, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrPeerlistFull", _wrap_SKY_ErrPeerlistFull, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidAddress", _wrap_SKY_ErrInvalidAddress, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNoLocalhost", _wrap_SKY_ErrNoLocalhost, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNotExternalIP", _wrap_SKY_ErrNotExternalIP, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrPortTooLow", _wrap_SKY_ErrPortTooLow, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrBlacklistedAddress", _wrap_SKY_ErrBlacklistedAddress, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectWriteFailed", _wrap_SKY_ErrDisconnectWriteFailed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectSetReadDeadlineFailed", _wrap_SKY_ErrDisconnectSetReadDeadlineFailed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectInvalidMessageLength", _wrap_SKY_ErrDisconnectInvalidMessageLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectMalformedMessage", _wrap_SKY_ErrDisconnectMalformedMessage, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectUnknownMessage", _wrap_SKY_ErrDisconnectUnknownMessage, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrConnectionPoolClosed", _wrap_SKY_ErrConnectionPoolClosed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWriteQueueFull", _wrap_SKY_ErrWriteQueueFull, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNoReachableConnections", _wrap_SKY_ErrNoReachableConnections, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMaxDefaultConnectionsReached", _wrap_SKY_ErrMaxDefaultConnectionsReached, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectVersionNotSupported", _wrap_SKY_ErrDisconnectVersionNotSupported, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectIntroductionTimeout", _wrap_SKY_ErrDisconnectIntroductionTimeout, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectIsBlacklisted", _wrap_SKY_ErrDisconnectIsBlacklisted, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectSelf", _wrap_SKY_ErrDisconnectSelf, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectConnectedTwice", _wrap_SKY_ErrDisconnectConnectedTwice, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectIdle", _wrap_SKY_ErrDisconnectIdle, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectNoIntroduction", _wrap_SKY_ErrDisconnectNoIntroduction, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectIPLimitReached", _wrap_SKY_ErrDisconnectIPLimitReached, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectMaxDefaultConnectionReached", _wrap_SKY_ErrDisconnectMaxDefaultConnectionReached, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDisconnectMaxOutgoingConnectionsReached", _wrap_SKY_ErrDisconnectMaxOutgoingConnectionsReached, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ConnectionError", _wrap_SKY_ConnectionError, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTxnNoFee", _wrap_SKY_ErrTxnNoFee, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTxnInsufficientFee", _wrap_SKY_ErrTxnInsufficientFee, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTxnInsufficientCoinHours", _wrap_SKY_ErrTxnInsufficientCoinHours, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNegativeValue", _wrap_SKY_ErrNegativeValue, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTooManyDecimals", _wrap_SKY_ErrTooManyDecimals, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTooLarge", _wrap_SKY_ErrTooLarge, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrEmptyDirectoryName", _wrap_SKY_ErrEmptyDirectoryName, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDotDirectoryName", _wrap_SKY_ErrDotDirectoryName, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrHistoryDBCorrupted", _wrap_SKY_ErrHistoryDBCorrupted, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUxOutNotExist", _wrap_SKY_ErrUxOutNotExist, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNoHeadBlock", _wrap_SKY_ErrNoHeadBlock, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingSignature", _wrap_SKY_ErrMissingSignature, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUnspentNotExist", _wrap_SKY_ErrUnspentNotExist, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrVerifyStopped", _wrap_SKY_ErrVerifyStopped, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrCreateBucketFailed", _wrap_SKY_ErrCreateBucketFailed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrBucketNotExist", _wrap_SKY_ErrBucketNotExist, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTxnViolatesHardConstraint", _wrap_SKY_ErrTxnViolatesHardConstraint, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTxnViolatesSoftConstraint", _wrap_SKY_ErrTxnViolatesSoftConstraint, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrTxnViolatesUserConstraint", _wrap_SKY_ErrTxnViolatesUserConstraint, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInsufficientBalance", _wrap_SKY_ErrInsufficientBalance, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInsufficientHours", _wrap_SKY_ErrInsufficientHours, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrZeroSpend", _wrap_SKY_ErrZeroSpend, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrSpendingUnconfirmed", _wrap_SKY_ErrSpendingUnconfirmed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidEncryptedField", _wrap_SKY_ErrInvalidEncryptedField, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletEncrypted", _wrap_SKY_ErrWalletEncrypted, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletNotEncrypted", _wrap_SKY_ErrWalletNotEncrypted, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletMissingPassword", _wrap_SKY_ErrWalletMissingPassword, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingEncrypt", _wrap_SKY_ErrMissingEncrypt, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletInvalidPassword", _wrap_SKY_ErrWalletInvalidPassword, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingSeed", _wrap_SKY_ErrMissingSeed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingAuthenticated", _wrap_SKY_ErrMissingAuthenticated, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWrongCryptoType", _wrap_SKY_ErrWrongCryptoType, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletNotExist", _wrap_SKY_ErrWalletNotExist, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrSeedUsed", _wrap_SKY_ErrSeedUsed, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletAPIDisabled", _wrap_SKY_ErrWalletAPIDisabled, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrSeedAPIDisabled", _wrap_SKY_ErrSeedAPIDisabled, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletNameConflict", _wrap_SKY_ErrWalletNameConflict, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidHoursSelectionMode", _wrap_SKY_ErrInvalidHoursSelectionMode, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidHoursSelectionType", _wrap_SKY_ErrInvalidHoursSelectionType, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUnknownAddress", _wrap_SKY_ErrUnknownAddress, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUnknownUxOut", _wrap_SKY_ErrUnknownUxOut, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNoUnspents", _wrap_SKY_ErrNoUnspents, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNullChangeAddress", _wrap_SKY_ErrNullChangeAddress, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingTo", _wrap_SKY_ErrMissingTo, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrZeroCoinsTo", _wrap_SKY_ErrZeroCoinsTo, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrNullAddressTo", _wrap_SKY_ErrNullAddressTo, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDuplicateTo", _wrap_SKY_ErrDuplicateTo, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingWalletID", _wrap_SKY_ErrMissingWalletID, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrIncludesNullAddress", _wrap_SKY_ErrIncludesNullAddress, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDuplicateAddresses", _wrap_SKY_ErrDuplicateAddresses, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrZeroToHoursAuto", _wrap_SKY_ErrZeroToHoursAuto, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingModeAuto", _wrap_SKY_ErrMissingModeAuto, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidHoursSelMode", _wrap_SKY_ErrInvalidHoursSelMode, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidModeManual", _wrap_SKY_ErrInvalidModeManual, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidHoursSelType", _wrap_SKY_ErrInvalidHoursSelType, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrMissingShareFactor", _wrap_SKY_ErrMissingShareFactor, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidShareFactor", _wrap_SKY_ErrInvalidShareFactor, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrShareFactorOutOfRange", _wrap_SKY_ErrShareFactorOutOfRange, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrWalletConstraint", _wrap_SKY_ErrWalletConstraint, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrDuplicateUxOuts", _wrap_SKY_ErrDuplicateUxOuts, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrUnknownWalletID", _wrap_SKY_ErrUnknownWalletID, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrVerifySignatureInvalidInputsNils", _wrap_SKY_ErrVerifySignatureInvalidInputsNils, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrVerifySignatureInvalidSigLength", _wrap_SKY_ErrVerifySignatureInvalidSigLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrVerifySignatureInvalidPubkeysLength", _wrap_SKY_ErrVerifySignatureInvalidPubkeysLength, JS_veto_set_variable);
SWIGV8_AddStaticVariable(exports_obj, "SKY_ErrInvalidDecimals", _wrap_SKY_ErrInvalidDecimals, JS_veto_set_variable);
SWIGV8_AddMemberVariable(_exports_GoComplex64__class, "real", _wrap_GoComplex64__real_get, _wrap_GoComplex64__real_set);
SWIGV8_AddMemberVariable(_exports_GoComplex64__class, "imaginary", _wrap_GoComplex64__imaginary_get, _wrap_GoComplex64__imaginary_set);
SWIGV8_AddMemberVariable(_exports_GoComplex128__class, "real", _wrap_GoComplex128__real_get, _wrap_GoComplex128__real_set);
SWIGV8_AddMemberVariable(_exports_GoComplex128__class, "imaginary", _wrap_GoComplex128__imaginary_get, _wrap_GoComplex128__imaginary_set);
SWIGV8_AddMemberVariable(_exports_GoString__class, "p", _wrap_GoString__p_get, _wrap_GoString__p_set);
SWIGV8_AddMemberVariable(_exports_GoString__class, "n", _wrap_GoString__n_get, _wrap_GoString__n_set);
SWIGV8_AddMemberVariable(_exports_GoInterface__class, "t", _wrap_GoInterface__t_get, _wrap_GoInterface__t_set);
SWIGV8_AddMemberVariable(_exports_GoInterface__class, "v", _wrap_GoInterface__v_get, _wrap_GoInterface__v_set);
SWIGV8_AddMemberVariable(_exports_GoSlice__class, "data", _wrap_GoSlice__data_get, _wrap_GoSlice__data_set);
SWIGV8_AddMemberVariable(_exports_GoSlice__class, "len", _wrap_GoSlice__len_get, _wrap_GoSlice__len_set);
SWIGV8_AddMemberVariable(_exports_GoSlice__class, "cap", _wrap_GoSlice__cap_get, _wrap_GoSlice__cap_set);
SWIGV8_AddMemberVariable(_exports_Number_class, "neg", _wrap_Number_neg_get, _wrap_Number_neg_set);
SWIGV8_AddMemberVariable(_exports_Number_class, "nat", _wrap_Number_nat_get, _wrap_Number_nat_set);
SWIGV8_AddMemberVariable(_exports_Signature_class, "R", _wrap_Signature_R_get, _wrap_Signature_R_set);
SWIGV8_AddMemberVariable(_exports_Signature_class, "S", _wrap_Signature_S_get, _wrap_Signature_S_set);
SWIGV8_AddMemberVariable(_exports_Wallet_class, "Meta", _wrap_Wallet_Meta_get, _wrap_Wallet_Meta_set);
SWIGV8_AddMemberVariable(_exports_Wallet_class, "Entries", _wrap_Wallet_Entries_get, _wrap_Wallet_Entries_set);
SWIGV8_AddMemberVariable(_exports_FeeCalculator_class, "callback", _wrap_FeeCalculator_callback_get, _wrap_FeeCalculator_callback_set);
SWIGV8_AddMemberVariable(_exports_FeeCalculator_class, "context", _wrap_FeeCalculator_context_get, _wrap_FeeCalculator_context_set);


  /* setup inheritances */
  

  /* class instances */
  /* Class: cipher_PubKey (_exports_cipher_PubKey) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_PubKey_class_0 = SWIGV8_CreateClassTemplate("cipher_PubKey");
_exports_cipher_PubKey_class_0->SetCallHandler(_wrap_new_cipher_PubKey);
_exports_cipher_PubKey_class_0->Inherit(_exports_cipher_PubKey_class);
_exports_cipher_PubKey_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_PubKey_obj = _exports_cipher_PubKey_class_0->GetFunction();
/* Class: cipher_SecKey (_exports_cipher_SecKey) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SecKey_class_0 = SWIGV8_CreateClassTemplate("cipher_SecKey");
_exports_cipher_SecKey_class_0->SetCallHandler(_wrap_new_cipher_SecKey);
_exports_cipher_SecKey_class_0->Inherit(_exports_cipher_SecKey_class);
_exports_cipher_SecKey_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_SecKey_obj = _exports_cipher_SecKey_class_0->GetFunction();
/* Class: cipher_Ripemd160 (_exports_cipher_Ripemd160) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Ripemd160_class_0 = SWIGV8_CreateClassTemplate("cipher_Ripemd160");
_exports_cipher_Ripemd160_class_0->SetCallHandler(_wrap_new_cipher_Ripemd160);
_exports_cipher_Ripemd160_class_0->Inherit(_exports_cipher_Ripemd160_class);
_exports_cipher_Ripemd160_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_Ripemd160_obj = _exports_cipher_Ripemd160_class_0->GetFunction();
/* Class: cipher_Sig (_exports_cipher_Sig) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Sig_class_0 = SWIGV8_CreateClassTemplate("cipher_Sig");
_exports_cipher_Sig_class_0->SetCallHandler(_wrap_new_cipher_Sig);
_exports_cipher_Sig_class_0->Inherit(_exports_cipher_Sig_class);
_exports_cipher_Sig_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_Sig_obj = _exports_cipher_Sig_class_0->GetFunction();
/* Class: cipher_SHA256 (_exports_cipher_SHA256) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SHA256_class_0 = SWIGV8_CreateClassTemplate("cipher_SHA256");
_exports_cipher_SHA256_class_0->SetCallHandler(_wrap_new_cipher_SHA256);
_exports_cipher_SHA256_class_0->Inherit(_exports_cipher_SHA256_class);
_exports_cipher_SHA256_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_SHA256_obj = _exports_cipher_SHA256_class_0->GetFunction();
/* Class: cipher_Checksum (_exports_cipher_Checksum) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Checksum_class_0 = SWIGV8_CreateClassTemplate("cipher_Checksum");
_exports_cipher_Checksum_class_0->SetCallHandler(_wrap_new_cipher_Checksum);
_exports_cipher_Checksum_class_0->Inherit(_exports_cipher_Checksum_class);
_exports_cipher_Checksum_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_Checksum_obj = _exports_cipher_Checksum_class_0->GetFunction();
/* Class: cipher_SecKeys (_exports_cipher_SecKeys) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SecKeys_class_0 = SWIGV8_CreateClassTemplate("cipher_SecKeys");
_exports_cipher_SecKeys_class_0->SetCallHandler(_wrap_new_cipher_SecKeys);
_exports_cipher_SecKeys_class_0->Inherit(_exports_cipher_SecKeys_class);
_exports_cipher_SecKeys_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_SecKeys_obj = _exports_cipher_SecKeys_class_0->GetFunction();
/* Class: cipher_PubKeys (_exports_cipher_PubKeys) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_PubKeys_class_0 = SWIGV8_CreateClassTemplate("cipher_PubKeys");
_exports_cipher_PubKeys_class_0->SetCallHandler(_wrap_new_cipher_PubKeys);
_exports_cipher_PubKeys_class_0->Inherit(_exports_cipher_PubKeys_class);
_exports_cipher_PubKeys_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_PubKeys_obj = _exports_cipher_PubKeys_class_0->GetFunction();
/* Class: cipher_SHA256s (_exports_cipher_SHA256s) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_SHA256s_class_0 = SWIGV8_CreateClassTemplate("cipher_SHA256s");
_exports_cipher_SHA256s_class_0->SetCallHandler(_wrap_new_cipher_SHA256s);
_exports_cipher_SHA256s_class_0->Inherit(_exports_cipher_SHA256s_class);
_exports_cipher_SHA256s_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_SHA256s_obj = _exports_cipher_SHA256s_class_0->GetFunction();
/* Class: coin_UxOutArray (_exports_coin_UxOutArray) */
v8::Handle<v8::FunctionTemplate> _exports_coin_UxOutArray_class_0 = SWIGV8_CreateClassTemplate("coin_UxOutArray");
_exports_coin_UxOutArray_class_0->SetCallHandler(_wrap_new_coin_UxOutArray);
_exports_coin_UxOutArray_class_0->Inherit(_exports_coin_UxOutArray_class);
_exports_coin_UxOutArray_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin_UxOutArray_obj = _exports_coin_UxOutArray_class_0->GetFunction();
/* Class: cipher_Addresses (_exports_cipher_Addresses) */
v8::Handle<v8::FunctionTemplate> _exports_cipher_Addresses_class_0 = SWIGV8_CreateClassTemplate("cipher_Addresses");
_exports_cipher_Addresses_class_0->SetCallHandler(_wrap_new_cipher_Addresses);
_exports_cipher_Addresses_class_0->Inherit(_exports_cipher_Addresses_class);
_exports_cipher_Addresses_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher_Addresses_obj = _exports_cipher_Addresses_class_0->GetFunction();
/* Class: Fee_Calculator (_exports_Fee_Calculator) */
v8::Handle<v8::FunctionTemplate> _exports_Fee_Calculator_class_0 = SWIGV8_CreateClassTemplate("Fee_Calculator");
_exports_Fee_Calculator_class_0->SetCallHandler(_wrap_new_Fee_Calculator);
_exports_Fee_Calculator_class_0->Inherit(_exports_Fee_Calculator_class);
_exports_Fee_Calculator_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_Fee_Calculator_obj = _exports_Fee_Calculator_class_0->GetFunction();
/* Class: _GoString_ (_exports__GoString_) */
v8::Handle<v8::FunctionTemplate> _exports__GoString__class_0 = SWIGV8_CreateClassTemplate("_GoString_");
_exports__GoString__class_0->SetCallHandler(_wrap_new__GoString_);
_exports__GoString__class_0->Inherit(_exports__GoString__class);
_exports__GoString__class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports__GoString__obj = _exports__GoString__class_0->GetFunction();
/* Class: GoInterface (_exports_GoInterface) */
v8::Handle<v8::FunctionTemplate> _exports_GoInterface_class_0 = SWIGV8_CreateClassTemplate("GoInterface");
_exports_GoInterface_class_0->SetCallHandler(_wrap_new_GoInterface);
_exports_GoInterface_class_0->Inherit(_exports_GoInterface_class);
_exports_GoInterface_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_GoInterface_obj = _exports_GoInterface_class_0->GetFunction();
/* Class: GoSlice (_exports_GoSlice) */
v8::Handle<v8::FunctionTemplate> _exports_GoSlice_class_0 = SWIGV8_CreateClassTemplate("GoSlice");
_exports_GoSlice_class_0->SetCallHandler(_wrap_new_GoSlice);
_exports_GoSlice_class_0->Inherit(_exports_GoSlice_class);
_exports_GoSlice_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_GoSlice_obj = _exports_GoSlice_class_0->GetFunction();
/* Class: api__RichlistParams (_exports_api__RichlistParams) */
v8::Handle<v8::FunctionTemplate> _exports_api__RichlistParams_class_0 = SWIGV8_CreateClassTemplate("api__RichlistParams");
_exports_api__RichlistParams_class_0->SetCallHandler(_wrap_new_api__RichlistParams);
_exports_api__RichlistParams_class_0->Inherit(_exports_api__RichlistParams_class);
_exports_api__RichlistParams_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_api__RichlistParams_obj = _exports_api__RichlistParams_class_0->GetFunction();
/* Class: api__NetworkConnectionsFilter (_exports_api__NetworkConnectionsFilter) */
v8::Handle<v8::FunctionTemplate> _exports_api__NetworkConnectionsFilter_class_0 = SWIGV8_CreateClassTemplate("api__NetworkConnectionsFilter");
_exports_api__NetworkConnectionsFilter_class_0->SetCallHandler(_wrap_new_api__NetworkConnectionsFilter);
_exports_api__NetworkConnectionsFilter_class_0->Inherit(_exports_api__NetworkConnectionsFilter_class);
_exports_api__NetworkConnectionsFilter_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_api__NetworkConnectionsFilter_obj = _exports_api__NetworkConnectionsFilter_class_0->GetFunction();
/* Class: cipher__Address (_exports_cipher__Address) */
v8::Handle<v8::FunctionTemplate> _exports_cipher__Address_class_0 = SWIGV8_CreateClassTemplate("cipher__Address");
_exports_cipher__Address_class_0->SetCallHandler(_wrap_new_cipher__Address);
_exports_cipher__Address_class_0->Inherit(_exports_cipher__Address_class);
_exports_cipher__Address_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher__Address_obj = _exports_cipher__Address_class_0->GetFunction();
/* Class: cipher__BitcoinAddress (_exports_cipher__BitcoinAddress) */
v8::Handle<v8::FunctionTemplate> _exports_cipher__BitcoinAddress_class_0 = SWIGV8_CreateClassTemplate("cipher__BitcoinAddress");
_exports_cipher__BitcoinAddress_class_0->SetCallHandler(_wrap_new_cipher__BitcoinAddress);
_exports_cipher__BitcoinAddress_class_0->Inherit(_exports_cipher__BitcoinAddress_class);
_exports_cipher__BitcoinAddress_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cipher__BitcoinAddress_obj = _exports_cipher__BitcoinAddress_class_0->GetFunction();
/* Class: encrypt__ScryptChacha20poly1305 (_exports_encrypt__ScryptChacha20poly1305) */
v8::Handle<v8::FunctionTemplate> _exports_encrypt__ScryptChacha20poly1305_class_0 = SWIGV8_CreateClassTemplate("encrypt__ScryptChacha20poly1305");
_exports_encrypt__ScryptChacha20poly1305_class_0->SetCallHandler(_wrap_new_encrypt__ScryptChacha20poly1305);
_exports_encrypt__ScryptChacha20poly1305_class_0->Inherit(_exports_encrypt__ScryptChacha20poly1305_class);
_exports_encrypt__ScryptChacha20poly1305_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_encrypt__ScryptChacha20poly1305_obj = _exports_encrypt__ScryptChacha20poly1305_class_0->GetFunction();
/* Class: secp256k1go__Field (_exports_secp256k1go__Field) */
v8::Handle<v8::FunctionTemplate> _exports_secp256k1go__Field_class_0 = SWIGV8_CreateClassTemplate("secp256k1go__Field");
_exports_secp256k1go__Field_class_0->SetCallHandler(_wrap_new_secp256k1go__Field);
_exports_secp256k1go__Field_class_0->Inherit(_exports_secp256k1go__Field_class);
_exports_secp256k1go__Field_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_secp256k1go__Field_obj = _exports_secp256k1go__Field_class_0->GetFunction();
/* Class: secp256k1go__XY (_exports_secp256k1go__XY) */
v8::Handle<v8::FunctionTemplate> _exports_secp256k1go__XY_class_0 = SWIGV8_CreateClassTemplate("secp256k1go__XY");
_exports_secp256k1go__XY_class_0->SetCallHandler(_wrap_new_secp256k1go__XY);
_exports_secp256k1go__XY_class_0->Inherit(_exports_secp256k1go__XY_class);
_exports_secp256k1go__XY_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_secp256k1go__XY_obj = _exports_secp256k1go__XY_class_0->GetFunction();
/* Class: secp256k1go__XYZ (_exports_secp256k1go__XYZ) */
v8::Handle<v8::FunctionTemplate> _exports_secp256k1go__XYZ_class_0 = SWIGV8_CreateClassTemplate("secp256k1go__XYZ");
_exports_secp256k1go__XYZ_class_0->SetCallHandler(_wrap_new_secp256k1go__XYZ);
_exports_secp256k1go__XYZ_class_0->Inherit(_exports_secp256k1go__XYZ_class);
_exports_secp256k1go__XYZ_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_secp256k1go__XYZ_obj = _exports_secp256k1go__XYZ_class_0->GetFunction();
/* Class: cli__SendAmount (_exports_cli__SendAmount) */
v8::Handle<v8::FunctionTemplate> _exports_cli__SendAmount_class_0 = SWIGV8_CreateClassTemplate("cli__SendAmount");
_exports_cli__SendAmount_class_0->SetCallHandler(_wrap_new_cli__SendAmount);
_exports_cli__SendAmount_class_0->Inherit(_exports_cli__SendAmount_class);
_exports_cli__SendAmount_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_cli__SendAmount_obj = _exports_cli__SendAmount_class_0->GetFunction();
/* Class: coin__Transaction (_exports_coin__Transaction) */
v8::Handle<v8::FunctionTemplate> _exports_coin__Transaction_class_0 = SWIGV8_CreateClassTemplate("coin__Transaction");
_exports_coin__Transaction_class_0->SetCallHandler(_wrap_new_coin__Transaction);
_exports_coin__Transaction_class_0->Inherit(_exports_coin__Transaction_class);
_exports_coin__Transaction_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__Transaction_obj = _exports_coin__Transaction_class_0->GetFunction();
/* Class: coin__TransactionOutput (_exports_coin__TransactionOutput) */
v8::Handle<v8::FunctionTemplate> _exports_coin__TransactionOutput_class_0 = SWIGV8_CreateClassTemplate("coin__TransactionOutput");
_exports_coin__TransactionOutput_class_0->SetCallHandler(_wrap_new_coin__TransactionOutput);
_exports_coin__TransactionOutput_class_0->Inherit(_exports_coin__TransactionOutput_class);
_exports_coin__TransactionOutput_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__TransactionOutput_obj = _exports_coin__TransactionOutput_class_0->GetFunction();
/* Class: coin__BlockHeader (_exports_coin__BlockHeader) */
v8::Handle<v8::FunctionTemplate> _exports_coin__BlockHeader_class_0 = SWIGV8_CreateClassTemplate("coin__BlockHeader");
_exports_coin__BlockHeader_class_0->SetCallHandler(_wrap_new_coin__BlockHeader);
_exports_coin__BlockHeader_class_0->Inherit(_exports_coin__BlockHeader_class);
_exports_coin__BlockHeader_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__BlockHeader_obj = _exports_coin__BlockHeader_class_0->GetFunction();
/* Class: coin__BlockBody (_exports_coin__BlockBody) */
v8::Handle<v8::FunctionTemplate> _exports_coin__BlockBody_class_0 = SWIGV8_CreateClassTemplate("coin__BlockBody");
_exports_coin__BlockBody_class_0->SetCallHandler(_wrap_new_coin__BlockBody);
_exports_coin__BlockBody_class_0->Inherit(_exports_coin__BlockBody_class);
_exports_coin__BlockBody_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__BlockBody_obj = _exports_coin__BlockBody_class_0->GetFunction();
/* Class: coin__Block (_exports_coin__Block) */
v8::Handle<v8::FunctionTemplate> _exports_coin__Block_class_0 = SWIGV8_CreateClassTemplate("coin__Block");
_exports_coin__Block_class_0->SetCallHandler(_wrap_new_coin__Block);
_exports_coin__Block_class_0->Inherit(_exports_coin__Block_class);
_exports_coin__Block_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__Block_obj = _exports_coin__Block_class_0->GetFunction();
/* Class: coin__SignedBlock (_exports_coin__SignedBlock) */
v8::Handle<v8::FunctionTemplate> _exports_coin__SignedBlock_class_0 = SWIGV8_CreateClassTemplate("coin__SignedBlock");
_exports_coin__SignedBlock_class_0->SetCallHandler(_wrap_new_coin__SignedBlock);
_exports_coin__SignedBlock_class_0->Inherit(_exports_coin__SignedBlock_class);
_exports_coin__SignedBlock_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__SignedBlock_obj = _exports_coin__SignedBlock_class_0->GetFunction();
/* Class: coin__UxHead (_exports_coin__UxHead) */
v8::Handle<v8::FunctionTemplate> _exports_coin__UxHead_class_0 = SWIGV8_CreateClassTemplate("coin__UxHead");
_exports_coin__UxHead_class_0->SetCallHandler(_wrap_new_coin__UxHead);
_exports_coin__UxHead_class_0->Inherit(_exports_coin__UxHead_class);
_exports_coin__UxHead_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__UxHead_obj = _exports_coin__UxHead_class_0->GetFunction();
/* Class: coin__UxBody (_exports_coin__UxBody) */
v8::Handle<v8::FunctionTemplate> _exports_coin__UxBody_class_0 = SWIGV8_CreateClassTemplate("coin__UxBody");
_exports_coin__UxBody_class_0->SetCallHandler(_wrap_new_coin__UxBody);
_exports_coin__UxBody_class_0->Inherit(_exports_coin__UxBody_class);
_exports_coin__UxBody_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__UxBody_obj = _exports_coin__UxBody_class_0->GetFunction();
/* Class: coin__UxOut (_exports_coin__UxOut) */
v8::Handle<v8::FunctionTemplate> _exports_coin__UxOut_class_0 = SWIGV8_CreateClassTemplate("coin__UxOut");
_exports_coin__UxOut_class_0->SetCallHandler(_wrap_new_coin__UxOut);
_exports_coin__UxOut_class_0->Inherit(_exports_coin__UxOut_class);
_exports_coin__UxOut_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_coin__UxOut_obj = _exports_coin__UxOut_class_0->GetFunction();
/* Class: httphelper__Address (_exports_httphelper__Address) */
v8::Handle<v8::FunctionTemplate> _exports_httphelper__Address_class_0 = SWIGV8_CreateClassTemplate("httphelper__Address");
_exports_httphelper__Address_class_0->SetCallHandler(_wrap_new_httphelper__Address);
_exports_httphelper__Address_class_0->Inherit(_exports_httphelper__Address_class);
_exports_httphelper__Address_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_httphelper__Address_obj = _exports_httphelper__Address_class_0->GetFunction();
/* Class: httphelper__SHA256 (_exports_httphelper__SHA256) */
v8::Handle<v8::FunctionTemplate> _exports_httphelper__SHA256_class_0 = SWIGV8_CreateClassTemplate("httphelper__SHA256");
_exports_httphelper__SHA256_class_0->SetCallHandler(_wrap_new_httphelper__SHA256);
_exports_httphelper__SHA256_class_0->Inherit(_exports_httphelper__SHA256_class);
_exports_httphelper__SHA256_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_httphelper__SHA256_obj = _exports_httphelper__SHA256_class_0->GetFunction();
/* Class: wallet__Balance (_exports_wallet__Balance) */
v8::Handle<v8::FunctionTemplate> _exports_wallet__Balance_class_0 = SWIGV8_CreateClassTemplate("wallet__Balance");
_exports_wallet__Balance_class_0->SetCallHandler(_wrap_new_wallet__Balance);
_exports_wallet__Balance_class_0->Inherit(_exports_wallet__Balance_class);
_exports_wallet__Balance_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_wallet__Balance_obj = _exports_wallet__Balance_class_0->GetFunction();
/* Class: wallet__BalancePair (_exports_wallet__BalancePair) */
v8::Handle<v8::FunctionTemplate> _exports_wallet__BalancePair_class_0 = SWIGV8_CreateClassTemplate("wallet__BalancePair");
_exports_wallet__BalancePair_class_0->SetCallHandler(_wrap_new_wallet__BalancePair);
_exports_wallet__BalancePair_class_0->Inherit(_exports_wallet__BalancePair_class);
_exports_wallet__BalancePair_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_wallet__BalancePair_obj = _exports_wallet__BalancePair_class_0->GetFunction();
/* Class: wallet__Entry (_exports_wallet__Entry) */
v8::Handle<v8::FunctionTemplate> _exports_wallet__Entry_class_0 = SWIGV8_CreateClassTemplate("wallet__Entry");
_exports_wallet__Entry_class_0->SetCallHandler(_wrap_new_wallet__Entry);
_exports_wallet__Entry_class_0->Inherit(_exports_wallet__Entry_class);
_exports_wallet__Entry_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_wallet__Entry_obj = _exports_wallet__Entry_class_0->GetFunction();
/* Class: wallet__Note (_exports_wallet__Note) */
v8::Handle<v8::FunctionTemplate> _exports_wallet__Note_class_0 = SWIGV8_CreateClassTemplate("wallet__Note");
_exports_wallet__Note_class_0->SetCallHandler(_wrap_new_wallet__Note);
_exports_wallet__Note_class_0->Inherit(_exports_wallet__Note_class);
_exports_wallet__Note_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_wallet__Note_obj = _exports_wallet__Note_class_0->GetFunction();
/* Class: wallet__ReadableNote (_exports_wallet__ReadableNote) */
v8::Handle<v8::FunctionTemplate> _exports_wallet__ReadableNote_class_0 = SWIGV8_CreateClassTemplate("wallet__ReadableNote");
_exports_wallet__ReadableNote_class_0->SetCallHandler(_wrap_new_wallet__ReadableNote);
_exports_wallet__ReadableNote_class_0->Inherit(_exports_wallet__ReadableNote_class);
_exports_wallet__ReadableNote_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_wallet__ReadableNote_obj = _exports_wallet__ReadableNote_class_0->GetFunction();
/* Class: transaction__UxBalance (_exports_transaction__UxBalance) */
v8::Handle<v8::FunctionTemplate> _exports_transaction__UxBalance_class_0 = SWIGV8_CreateClassTemplate("transaction__UxBalance");
_exports_transaction__UxBalance_class_0->SetCallHandler(_wrap_new_transaction__UxBalance);
_exports_transaction__UxBalance_class_0->Inherit(_exports_transaction__UxBalance_class);
_exports_transaction__UxBalance_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_transaction__UxBalance_obj = _exports_transaction__UxBalance_class_0->GetFunction();
/* Class: api__TransactionInput (_exports_api__TransactionInput) */
v8::Handle<v8::FunctionTemplate> _exports_api__TransactionInput_class_0 = SWIGV8_CreateClassTemplate("api__TransactionInput");
_exports_api__TransactionInput_class_0->SetCallHandler(_wrap_new_api__TransactionInput);
_exports_api__TransactionInput_class_0->Inherit(_exports_api__TransactionInput_class);
_exports_api__TransactionInput_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_api__TransactionInput_obj = _exports_api__TransactionInput_class_0->GetFunction();
/* Class: GoComplex64_ (_exports_GoComplex64_) */
v8::Handle<v8::FunctionTemplate> _exports_GoComplex64__class_0 = SWIGV8_CreateClassTemplate("GoComplex64_");
_exports_GoComplex64__class_0->SetCallHandler(_wrap_new_GoComplex64_);
_exports_GoComplex64__class_0->Inherit(_exports_GoComplex64__class);
_exports_GoComplex64__class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_GoComplex64__obj = _exports_GoComplex64__class_0->GetFunction();
/* Class: GoComplex128_ (_exports_GoComplex128_) */
v8::Handle<v8::FunctionTemplate> _exports_GoComplex128__class_0 = SWIGV8_CreateClassTemplate("GoComplex128_");
_exports_GoComplex128__class_0->SetCallHandler(_wrap_new_GoComplex128_);
_exports_GoComplex128__class_0->Inherit(_exports_GoComplex128__class);
_exports_GoComplex128__class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_GoComplex128__obj = _exports_GoComplex128__class_0->GetFunction();
/* Class: GoString_ (_exports_GoString_) */
v8::Handle<v8::FunctionTemplate> _exports_GoString__class_0 = SWIGV8_CreateClassTemplate("GoString_");
_exports_GoString__class_0->SetCallHandler(_wrap_new_GoString_);
_exports_GoString__class_0->Inherit(_exports_GoString__class);
_exports_GoString__class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_GoString__obj = _exports_GoString__class_0->GetFunction();
/* Class: GoInterface_ (_exports_GoInterface_) */
v8::Handle<v8::FunctionTemplate> _exports_GoInterface__class_0 = SWIGV8_CreateClassTemplate("GoInterface_");
_exports_GoInterface__class_0->SetCallHandler(_wrap_new_GoInterface_);
_exports_GoInterface__class_0->Inherit(_exports_GoInterface__class);
_exports_GoInterface__class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_GoInterface__obj = _exports_GoInterface__class_0->GetFunction();
/* Class: GoSlice_ (_exports_GoSlice_) */
v8::Handle<v8::FunctionTemplate> _exports_GoSlice__class_0 = SWIGV8_CreateClassTemplate("GoSlice_");
_exports_GoSlice__class_0->SetCallHandler(_wrap_new_GoSlice_);
_exports_GoSlice__class_0->Inherit(_exports_GoSlice__class);
_exports_GoSlice__class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_GoSlice__obj = _exports_GoSlice__class_0->GetFunction();
/* Class: Number (_exports_Number) */
v8::Handle<v8::FunctionTemplate> _exports_Number_class_0 = SWIGV8_CreateClassTemplate("Number");
_exports_Number_class_0->SetCallHandler(_wrap_new_Number);
_exports_Number_class_0->Inherit(_exports_Number_class);
_exports_Number_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_Number_obj = _exports_Number_class_0->GetFunction();
/* Class: Signature (_exports_Signature) */
v8::Handle<v8::FunctionTemplate> _exports_Signature_class_0 = SWIGV8_CreateClassTemplate("Signature");
_exports_Signature_class_0->SetCallHandler(_wrap_new_Signature);
_exports_Signature_class_0->Inherit(_exports_Signature_class);
_exports_Signature_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_Signature_obj = _exports_Signature_class_0->GetFunction();
/* Class: Wallet (_exports_Wallet) */
v8::Handle<v8::FunctionTemplate> _exports_Wallet_class_0 = SWIGV8_CreateClassTemplate("Wallet");
_exports_Wallet_class_0->SetCallHandler(_wrap_new_Wallet);
_exports_Wallet_class_0->Inherit(_exports_Wallet_class);
_exports_Wallet_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_Wallet_obj = _exports_Wallet_class_0->GetFunction();
/* Class: FeeCalculator (_exports_FeeCalculator) */
v8::Handle<v8::FunctionTemplate> _exports_FeeCalculator_class_0 = SWIGV8_CreateClassTemplate("FeeCalculator");
_exports_FeeCalculator_class_0->SetCallHandler(_wrap_new_FeeCalculator);
_exports_FeeCalculator_class_0->Inherit(_exports_FeeCalculator_class);
_exports_FeeCalculator_class_0->SetHiddenPrototype(true);
v8::Handle<v8::Object> _exports_FeeCalculator_obj = _exports_FeeCalculator_class_0->GetFunction();


  /* add static class functions and variables */
  SWIGV8_AddStaticFunction(exports_obj, "equalSlices", _wrap_equalSlices);
SWIGV8_AddStaticFunction(exports_obj, "equalTransactions", _wrap_equalTransactions);
SWIGV8_AddStaticFunction(exports_obj, "equalTransactionsArrays", _wrap_equalTransactionsArrays);
SWIGV8_AddStaticFunction(exports_obj, "equalBlockHeaders", _wrap_equalBlockHeaders);
SWIGV8_AddStaticFunction(exports_obj, "new_GoSlicePtr", _wrap_new_GoSlicePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_GoSlicePtr", _wrap_copy_GoSlicePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_GoSlicePtr", _wrap_delete_GoSlicePtr);
SWIGV8_AddStaticFunction(exports_obj, "GoSlicePtr_assign", _wrap_GoSlicePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "GoSlicePtr_value", _wrap_GoSlicePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_GoUint8Ptr", _wrap_new_GoUint8Ptr);
SWIGV8_AddStaticFunction(exports_obj, "copy_GoUint8Ptr", _wrap_copy_GoUint8Ptr);
SWIGV8_AddStaticFunction(exports_obj, "delete_GoUint8Ptr", _wrap_delete_GoUint8Ptr);
SWIGV8_AddStaticFunction(exports_obj, "GoUint8Ptr_assign", _wrap_GoUint8Ptr_assign);
SWIGV8_AddStaticFunction(exports_obj, "GoUint8Ptr_value", _wrap_GoUint8Ptr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_GoStringPtr", _wrap_new_GoStringPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_GoStringPtr", _wrap_copy_GoStringPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_GoStringPtr", _wrap_delete_GoStringPtr);
SWIGV8_AddStaticFunction(exports_obj, "GoStringPtr_assign", _wrap_GoStringPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "GoStringPtr_value", _wrap_GoStringPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_IntPtr", _wrap_new_IntPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_IntPtr", _wrap_copy_IntPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_IntPtr", _wrap_delete_IntPtr);
SWIGV8_AddStaticFunction(exports_obj, "IntPtr_assign", _wrap_IntPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "IntPtr_value", _wrap_IntPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_coin__TransactionPtr", _wrap_new_coin__TransactionPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_coin__TransactionPtr", _wrap_copy_coin__TransactionPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_coin__TransactionPtr", _wrap_delete_coin__TransactionPtr);
SWIGV8_AddStaticFunction(exports_obj, "coin__TransactionPtr_assign", _wrap_coin__TransactionPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "coin__TransactionPtr_value", _wrap_coin__TransactionPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_AddressUxOuts__HandlePtr", _wrap_new_AddressUxOuts__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_AddressUxOuts__HandlePtr", _wrap_copy_AddressUxOuts__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_AddressUxOuts__HandlePtr", _wrap_delete_AddressUxOuts__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "AddressUxOuts__HandlePtr_assign", _wrap_AddressUxOuts__HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "AddressUxOuts__HandlePtr_value", _wrap_AddressUxOuts__HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_GoUint64Ptr", _wrap_new_GoUint64Ptr);
SWIGV8_AddStaticFunction(exports_obj, "copy_GoUint64Ptr", _wrap_copy_GoUint64Ptr);
SWIGV8_AddStaticFunction(exports_obj, "delete_GoUint64Ptr", _wrap_delete_GoUint64Ptr);
SWIGV8_AddStaticFunction(exports_obj, "GoUint64Ptr_assign", _wrap_GoUint64Ptr_assign);
SWIGV8_AddStaticFunction(exports_obj, "GoUint64Ptr_value", _wrap_GoUint64Ptr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_GointPtr", _wrap_new_GointPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_GointPtr", _wrap_copy_GointPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_GointPtr", _wrap_delete_GointPtr);
SWIGV8_AddStaticFunction(exports_obj, "GointPtr_assign", _wrap_GointPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "GointPtr_value", _wrap_GointPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_GoUint16Ptr", _wrap_new_GoUint16Ptr);
SWIGV8_AddStaticFunction(exports_obj, "copy_GoUint16Ptr", _wrap_copy_GoUint16Ptr);
SWIGV8_AddStaticFunction(exports_obj, "delete_GoUint16Ptr", _wrap_delete_GoUint16Ptr);
SWIGV8_AddStaticFunction(exports_obj, "GoUint16Ptr_assign", _wrap_GoUint16Ptr_assign);
SWIGV8_AddStaticFunction(exports_obj, "GoUint16Ptr_value", _wrap_GoUint16Ptr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_GoUint32Ptr", _wrap_new_GoUint32Ptr);
SWIGV8_AddStaticFunction(exports_obj, "copy_GoUint32Ptr", _wrap_copy_GoUint32Ptr);
SWIGV8_AddStaticFunction(exports_obj, "delete_GoUint32Ptr", _wrap_delete_GoUint32Ptr);
SWIGV8_AddStaticFunction(exports_obj, "GoUint32Ptr_assign", _wrap_GoUint32Ptr_assign);
SWIGV8_AddStaticFunction(exports_obj, "GoUint32Ptr_value", _wrap_GoUint32Ptr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_cipher__AddressPtr", _wrap_new_cipher__AddressPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_cipher__AddressPtr", _wrap_copy_cipher__AddressPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_cipher__AddressPtr", _wrap_delete_cipher__AddressPtr);
SWIGV8_AddStaticFunction(exports_obj, "cipher__AddressPtr_assign", _wrap_cipher__AddressPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "cipher__AddressPtr_value", _wrap_cipher__AddressPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_Transactions__HandlePtr", _wrap_new_Transactions__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_Transactions__HandlePtr", _wrap_copy_Transactions__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_Transactions__HandlePtr", _wrap_delete_Transactions__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "Transactions__HandlePtr_assign", _wrap_Transactions__HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "Transactions__HandlePtr_value", _wrap_Transactions__HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_Transaction__HandlePtr", _wrap_new_Transaction__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_Transaction__HandlePtr", _wrap_copy_Transaction__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_Transaction__HandlePtr", _wrap_delete_Transaction__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "Transaction__HandlePtr_assign", _wrap_Transaction__HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "Transaction__HandlePtr_value", _wrap_Transaction__HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_Block__HandlePtr", _wrap_new_Block__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_Block__HandlePtr", _wrap_copy_Block__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_Block__HandlePtr", _wrap_delete_Block__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "Block__HandlePtr_assign", _wrap_Block__HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "Block__HandlePtr_value", _wrap_Block__HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_BlockHeader__HandlePtr", _wrap_new_BlockHeader__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_BlockHeader__HandlePtr", _wrap_copy_BlockHeader__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_BlockHeader__HandlePtr", _wrap_delete_BlockHeader__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "BlockHeader__HandlePtr_assign", _wrap_BlockHeader__HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "BlockHeader__HandlePtr_value", _wrap_BlockHeader__HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_BlockBody__HandlePtr", _wrap_new_BlockBody__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_BlockBody__HandlePtr", _wrap_copy_BlockBody__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_BlockBody__HandlePtr", _wrap_delete_BlockBody__HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "BlockBody__HandlePtr_assign", _wrap_BlockBody__HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "BlockBody__HandlePtr_value", _wrap_BlockBody__HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_Signature_HandlePtr", _wrap_new_Signature_HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_Signature_HandlePtr", _wrap_copy_Signature_HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_Signature_HandlePtr", _wrap_delete_Signature_HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "Signature_HandlePtr_assign", _wrap_Signature_HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "Signature_HandlePtr_value", _wrap_Signature_HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_Number_HandlePtr", _wrap_new_Number_HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_Number_HandlePtr", _wrap_copy_Number_HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_Number_HandlePtr", _wrap_delete_Number_HandlePtr);
SWIGV8_AddStaticFunction(exports_obj, "Number_HandlePtr_assign", _wrap_Number_HandlePtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "Number_HandlePtr_value", _wrap_Number_HandlePtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_CharPtr", _wrap_new_CharPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_CharPtr", _wrap_copy_CharPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_CharPtr", _wrap_delete_CharPtr);
SWIGV8_AddStaticFunction(exports_obj, "CharPtr_assign", _wrap_CharPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "CharPtr_value", _wrap_CharPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_FeeCalculatorPtr", _wrap_new_FeeCalculatorPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_FeeCalculatorPtr", _wrap_copy_FeeCalculatorPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_FeeCalculatorPtr", _wrap_delete_FeeCalculatorPtr);
SWIGV8_AddStaticFunction(exports_obj, "FeeCalculatorPtr_assign", _wrap_FeeCalculatorPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "FeeCalculatorPtr_value", _wrap_FeeCalculatorPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_FeeCalcFuncPtr", _wrap_new_FeeCalcFuncPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_FeeCalcFuncPtr", _wrap_copy_FeeCalcFuncPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_FeeCalcFuncPtr", _wrap_delete_FeeCalcFuncPtr);
SWIGV8_AddStaticFunction(exports_obj, "FeeCalcFuncPtr_assign", _wrap_FeeCalcFuncPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "FeeCalcFuncPtr_value", _wrap_FeeCalcFuncPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "new_coin__BlockPtr", _wrap_new_coin__BlockPtr);
SWIGV8_AddStaticFunction(exports_obj, "copy_coin__BlockPtr", _wrap_copy_coin__BlockPtr);
SWIGV8_AddStaticFunction(exports_obj, "delete_coin__BlockPtr", _wrap_delete_coin__BlockPtr);
SWIGV8_AddStaticFunction(exports_obj, "coin__BlockPtr_assign", _wrap_coin__BlockPtr_assign);
SWIGV8_AddStaticFunction(exports_obj, "coin__BlockPtr_value", _wrap_coin__BlockPtr_value);
SWIGV8_AddStaticFunction(exports_obj, "SKY_fee_VerifyTransactionFee", _wrap_SKY_fee_VerifyTransactionFee);
SWIGV8_AddStaticFunction(exports_obj, "SKY_fee_VerifyTransactionFeeForHours", _wrap_SKY_fee_VerifyTransactionFeeForHours);
SWIGV8_AddStaticFunction(exports_obj, "SKY_fee_RequiredFee", _wrap_SKY_fee_RequiredFee);
SWIGV8_AddStaticFunction(exports_obj, "SKY_fee_RemainingHours", _wrap_SKY_fee_RemainingHours);
SWIGV8_AddStaticFunction(exports_obj, "SKY_fee_TransactionFee", _wrap_SKY_fee_TransactionFee);
SWIGV8_AddStaticFunction(exports_obj, "SKY_JsonEncode_Handle", _wrap_SKY_JsonEncode_Handle);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Progress_GetCurrent", _wrap_SKY_Handle_Progress_GetCurrent);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Block_GetHeadSeq", _wrap_SKY_Handle_Block_GetHeadSeq);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Block_GetHeadHash", _wrap_SKY_Handle_Block_GetHeadHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Block_GetPreviousBlockHash", _wrap_SKY_Handle_Block_GetPreviousBlockHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Blocks_GetAt", _wrap_SKY_Handle_Blocks_GetAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Blocks_GetCount", _wrap_SKY_Handle_Blocks_GetCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Connections_GetCount", _wrap_SKY_Handle_Connections_GetCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Strings_GetCount", _wrap_SKY_Handle_Strings_GetCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Strings_Sort", _wrap_SKY_Handle_Strings_Sort);
SWIGV8_AddStaticFunction(exports_obj, "SKY_Handle_Strings_GetAt", _wrap_SKY_Handle_Strings_GetAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_Client_GetWalletDir", _wrap_SKY_api_Handle_Client_GetWalletDir);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_Client_GetWalletFileName", _wrap_SKY_api_Handle_Client_GetWalletFileName);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_Client_GetWalletLabel", _wrap_SKY_api_Handle_Client_GetWalletLabel);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_Client_GetWalletFullPath", _wrap_SKY_api_Handle_Client_GetWalletFullPath);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_GetWalletMeta", _wrap_SKY_api_Handle_GetWalletMeta);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_GetWalletEntriesCount", _wrap_SKY_api_Handle_GetWalletEntriesCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_Client_GetWalletResponseEntriesCount", _wrap_SKY_api_Handle_Client_GetWalletResponseEntriesCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_WalletGetEntry", _wrap_SKY_api_Handle_WalletGetEntry);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_WalletResponseGetEntry", _wrap_SKY_api_Handle_WalletResponseGetEntry);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_WalletResponseIsEncrypted", _wrap_SKY_api_Handle_WalletResponseIsEncrypted);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_WalletResponseGetCryptoType", _wrap_SKY_api_Handle_WalletResponseGetCryptoType);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_WalletsResponseGetCount", _wrap_SKY_api_Handle_WalletsResponseGetCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_WalletsResponseGetAt", _wrap_SKY_api_Handle_WalletsResponseGetAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_GetWalletFolderAddress", _wrap_SKY_api_Handle_GetWalletFolderAddress);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_GetWalletSeed", _wrap_SKY_api_Handle_GetWalletSeed);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_GetWalletLastSeed", _wrap_SKY_api_Handle_GetWalletLastSeed);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Handle_GetBuildInfoData", _wrap_SKY_api_Handle_GetBuildInfoData);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Address_UnmarshalJSON", _wrap_SKY_httphelper_Address_UnmarshalJSON);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Address_MarshalJSON", _wrap_SKY_httphelper_Address_MarshalJSON);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Coins_UnmarshalJSON", _wrap_SKY_httphelper_Coins_UnmarshalJSON);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Coins_MarshalJSON", _wrap_SKY_httphelper_Coins_MarshalJSON);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Coins_Value", _wrap_SKY_httphelper_Coins_Value);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Hours_UnmarshalJSON", _wrap_SKY_httphelper_Hours_UnmarshalJSON);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Hours_MarshalJSON", _wrap_SKY_httphelper_Hours_MarshalJSON);
SWIGV8_AddStaticFunction(exports_obj, "SKY_httphelper_Hours_Value", _wrap_SKY_httphelper_Hours_Value);
SWIGV8_AddStaticFunction(exports_obj, "SKY_util_AddUint64", _wrap_SKY_util_AddUint64);
SWIGV8_AddStaticFunction(exports_obj, "SKY_util_Uint64ToInt64", _wrap_SKY_util_Uint64ToInt64);
SWIGV8_AddStaticFunction(exports_obj, "SKY_util_Int64ToUint64", _wrap_SKY_util_Int64ToUint64);
SWIGV8_AddStaticFunction(exports_obj, "SKY_util_IntToUint32", _wrap_SKY_util_IntToUint32);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_AddPrivateKey", _wrap_SKY_cli_AddPrivateKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_AddPrivateKeyToFile", _wrap_SKY_cli_AddPrivateKeyToFile);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_CreateOptionsHandle", _wrap_SKY_wallet_CreateOptionsHandle);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Entry_Verify", _wrap_SKY_wallet_Entry_Verify);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Entry_VerifyPublic", _wrap_SKY_wallet_Entry_VerifyPublic);
SWIGV8_AddStaticFunction(exports_obj, "SKY_logging_EnableColors", _wrap_SKY_logging_EnableColors);
SWIGV8_AddStaticFunction(exports_obj, "SKY_logging_DisableColors", _wrap_SKY_logging_DisableColors);
SWIGV8_AddStaticFunction(exports_obj, "SKY_logging_Disable", _wrap_SKY_logging_Disable);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_CLI_Run", _wrap_SKY_cli_CLI_Run);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_Config_GetCoin", _wrap_SKY_cli_Config_GetCoin);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_Config_GetRPCAddress", _wrap_SKY_cli_Config_GetRPCAddress);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_Getenv", _wrap_SKY_cli_Getenv);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_Setenv", _wrap_SKY_cli_Setenv);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_NewBalance", _wrap_SKY_wallet_NewBalance);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_NewBalanceFromUxOut", _wrap_SKY_wallet_NewBalanceFromUxOut);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Balance_Add", _wrap_SKY_wallet_Balance_Add);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Balance_Sub", _wrap_SKY_wallet_Balance_Sub);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Balance_Equals", _wrap_SKY_wallet_Balance_Equals);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Balance_IsZero", _wrap_SKY_wallet_Balance_IsZero);
SWIGV8_AddStaticFunction(exports_obj, "SKY_certutil_NewTLSCertPair", _wrap_SKY_certutil_NewTLSCertPair);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_DecodeBase58BitcoinAddress", _wrap_SKY_cipher_DecodeBase58BitcoinAddress);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddressFromPubKey", _wrap_SKY_cipher_BitcoinAddressFromPubKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddressFromSecKey", _wrap_SKY_cipher_BitcoinAddressFromSecKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinWalletImportFormatFromSeckey", _wrap_SKY_cipher_BitcoinWalletImportFormatFromSeckey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddressFromBytes", _wrap_SKY_cipher_BitcoinAddressFromBytes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SecKeyFromBitcoinWalletImportFormat", _wrap_SKY_cipher_SecKeyFromBitcoinWalletImportFormat);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddress_Null", _wrap_SKY_cipher_BitcoinAddress_Null);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddress_Bytes", _wrap_SKY_cipher_BitcoinAddress_Bytes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddress_Verify", _wrap_SKY_cipher_BitcoinAddress_Verify);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddress_String", _wrap_SKY_cipher_BitcoinAddress_String);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_BitcoinAddress_Checksum", _wrap_SKY_cipher_BitcoinAddress_Checksum);
SWIGV8_AddStaticFunction(exports_obj, "SKY_transaction_ChooseSpendsMaximizeUxOuts", _wrap_SKY_transaction_ChooseSpendsMaximizeUxOuts);
SWIGV8_AddStaticFunction(exports_obj, "SKY_transaction_ChooseSpendsMinimizeUxOuts", _wrap_SKY_transaction_ChooseSpendsMinimizeUxOuts);
SWIGV8_AddStaticFunction(exports_obj, "SKY_transaction_NewUxBalance", _wrap_SKY_transaction_NewUxBalance);
SWIGV8_AddStaticFunction(exports_obj, "SKY_transaction_NewUxBalances", _wrap_SKY_transaction_NewUxBalances);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_GenerateWallet", _wrap_SKY_cli_GenerateWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_MakeAlphanumericSeed", _wrap_SKY_cli_MakeAlphanumericSeed);
SWIGV8_AddStaticFunction(exports_obj, "SKY_testutil_MakeAddress", _wrap_SKY_testutil_MakeAddress);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_LoadConfig", _wrap_SKY_cli_LoadConfig);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_Config_FullWalletPath", _wrap_SKY_cli_Config_FullWalletPath);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_Config_FullDBPath", _wrap_SKY_cli_Config_FullDBPath);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_NewCLI", _wrap_SKY_cli_NewCLI);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_NewPasswordReader", _wrap_SKY_cli_NewPasswordReader);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_PasswordFromBytes_Password", _wrap_SKY_cli_PasswordFromBytes_Password);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_PasswordFromTerm_Password", _wrap_SKY_cli_PasswordFromTerm_Password);
SWIGV8_AddStaticFunction(exports_obj, "SKY_apputil_CatchInterruptPanic", _wrap_SKY_apputil_CatchInterruptPanic);
SWIGV8_AddStaticFunction(exports_obj, "SKY_apputil_CatchDebug", _wrap_SKY_apputil_CatchDebug);
SWIGV8_AddStaticFunction(exports_obj, "SKY_apputil_PrintProgramStatus", _wrap_SKY_apputil_PrintProgramStatus);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_RandByte", _wrap_SKY_cipher_RandByte);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_NewPubKey", _wrap_SKY_cipher_NewPubKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_PubKeyFromHex", _wrap_SKY_cipher_PubKeyFromHex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_PubKeyFromSecKey", _wrap_SKY_cipher_PubKeyFromSecKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_PubKeyFromSig", _wrap_SKY_cipher_PubKeyFromSig);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_PubKey_Verify", _wrap_SKY_cipher_PubKey_Verify);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_PubKey_Hex", _wrap_SKY_cipher_PubKey_Hex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_PubKeyRipemd160", _wrap_SKY_cipher_PubKeyRipemd160);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_NewSecKey", _wrap_SKY_cipher_NewSecKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SecKeyFromHex", _wrap_SKY_cipher_SecKeyFromHex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SecKey_Verify", _wrap_SKY_cipher_SecKey_Verify);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SecKey_Hex", _wrap_SKY_cipher_SecKey_Hex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_ECDH", _wrap_SKY_cipher_ECDH);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_NewSig", _wrap_SKY_cipher_NewSig);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SigFromHex", _wrap_SKY_cipher_SigFromHex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Sig_Hex", _wrap_SKY_cipher_Sig_Hex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SignHash", _wrap_SKY_cipher_SignHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_VerifyAddressSignedHash", _wrap_SKY_cipher_VerifyAddressSignedHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_VerifyPubKeySignedHash", _wrap_SKY_cipher_VerifyPubKeySignedHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_GenerateKeyPair", _wrap_SKY_cipher_GenerateKeyPair);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_GenerateDeterministicKeyPair", _wrap_SKY_cipher_GenerateDeterministicKeyPair);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_DeterministicKeyPairIterator", _wrap_SKY_cipher_DeterministicKeyPairIterator);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_GenerateDeterministicKeyPairs", _wrap_SKY_cipher_GenerateDeterministicKeyPairs);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_GenerateDeterministicKeyPairsSeed", _wrap_SKY_cipher_GenerateDeterministicKeyPairsSeed);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_CheckSecKey", _wrap_SKY_cipher_CheckSecKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_CheckSecKeyHash", _wrap_SKY_cipher_CheckSecKeyHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_secp256k1_PubkeyFromSeckey", _wrap_SKY_secp256k1_PubkeyFromSeckey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_secp256k1_VerifyPubkey", _wrap_SKY_secp256k1_VerifyPubkey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_secp256k1_VerifySecKey", _wrap_SKY_secp256k1_VerifySecKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_secp256k1_ECDH", _wrap_SKY_secp256k1_ECDH);
SWIGV8_AddStaticFunction(exports_obj, "SKY_file_InitDataDir", _wrap_SKY_file_InitDataDir);
SWIGV8_AddStaticFunction(exports_obj, "SKY_file_UserHome", _wrap_SKY_file_UserHome);
SWIGV8_AddStaticFunction(exports_obj, "SKY_file_ResolveResourceDirectory", _wrap_SKY_file_ResolveResourceDirectory);
SWIGV8_AddStaticFunction(exports_obj, "SKY_file_DetermineResourcePath", _wrap_SKY_file_DetermineResourcePath);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_NewWalletResponse", _wrap_SKY_api_NewWalletResponse);
SWIGV8_AddStaticFunction(exports_obj, "SKY_map_Get", _wrap_SKY_map_Get);
SWIGV8_AddStaticFunction(exports_obj, "SKY_map_HasKey", _wrap_SKY_map_HasKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_map_Close", _wrap_SKY_map_Close);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_NewBlock", _wrap_SKY_coin_NewBlock);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_SignedBlock_VerifySignature", _wrap_SKY_coin_SignedBlock_VerifySignature);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_NewGenesisBlock", _wrap_SKY_coin_NewGenesisBlock);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Block_HashHeader", _wrap_SKY_coin_Block_HashHeader);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Block_Time", _wrap_SKY_coin_Block_Time);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Block_Seq", _wrap_SKY_coin_Block_Seq);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Block_HashBody", _wrap_SKY_coin_Block_HashBody);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Block_Size", _wrap_SKY_coin_Block_Size);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_NewBlockHeader", _wrap_SKY_coin_NewBlockHeader);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_Hash", _wrap_SKY_coin_BlockHeader_Hash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_Bytes", _wrap_SKY_coin_BlockHeader_Bytes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockBody_Hash", _wrap_SKY_coin_BlockBody_Hash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockBody_Size", _wrap_SKY_coin_BlockBody_Size);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockBody_Bytes", _wrap_SKY_coin_BlockBody_Bytes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_CreateUnspents", _wrap_SKY_coin_CreateUnspents);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_CreateUnspent", _wrap_SKY_coin_CreateUnspent);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_GetBlockObject", _wrap_SKY_coin_GetBlockObject);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_GetBlockBody", _wrap_SKY_coin_GetBlockBody);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_NewEmptyBlock", _wrap_SKY_coin_NewEmptyBlock);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Block_GetBlockHeader", _wrap_SKY_coin_Block_GetBlockHeader);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_GetBlockHeaderObject", _wrap_SKY_coin_GetBlockHeaderObject);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_Time", _wrap_SKY_coin_BlockHeader_Time);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_BkSeq", _wrap_SKY_coin_BlockHeader_BkSeq);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_UxHash", _wrap_SKY_coin_BlockHeader_UxHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_Fee", _wrap_SKY_coin_BlockHeader_Fee);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockBody_Transactions", _wrap_SKY_coin_BlockBody_Transactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_SetTime", _wrap_SKY_coin_BlockHeader_SetTime);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_SetBkSeq", _wrap_SKY_coin_BlockHeader_SetBkSeq);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_SetFee", _wrap_SKY_coin_BlockHeader_SetFee);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_SetVersion", _wrap_SKY_coin_BlockHeader_SetVersion);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_Version", _wrap_SKY_coin_BlockHeader_Version);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_BlockHeader_PrevHash", _wrap_SKY_coin_BlockHeader_PrevHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_droplet_FromString", _wrap_SKY_droplet_FromString);
SWIGV8_AddStaticFunction(exports_obj, "SKY_droplet_ToString", _wrap_SKY_droplet_ToString);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_CryptoTypeFromString", _wrap_SKY_wallet_CryptoTypeFromString);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_DecodeBase58Address", _wrap_SKY_cipher_DecodeBase58Address);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_AddressFromBytes", _wrap_SKY_cipher_AddressFromBytes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_AddressFromPubKey", _wrap_SKY_cipher_AddressFromPubKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_AddressFromSecKey", _wrap_SKY_cipher_AddressFromSecKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Address_Null", _wrap_SKY_cipher_Address_Null);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Address_Bytes", _wrap_SKY_cipher_Address_Bytes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Address_Verify", _wrap_SKY_cipher_Address_Verify);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Address_String", _wrap_SKY_cipher_Address_String);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Address_Checksum", _wrap_SKY_cipher_Address_Checksum);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Ripemd160_Set", _wrap_SKY_cipher_Ripemd160_Set);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_HashRipemd160", _wrap_SKY_cipher_HashRipemd160);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SHA256_Set", _wrap_SKY_cipher_SHA256_Set);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SHA256_Hex", _wrap_SKY_cipher_SHA256_Hex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SHA256_Xor", _wrap_SKY_cipher_SHA256_Xor);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SumSHA256", _wrap_SKY_cipher_SumSHA256);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SHA256FromHex", _wrap_SKY_cipher_SHA256FromHex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_DoubleSHA256", _wrap_SKY_cipher_DoubleSHA256);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_AddSHA256", _wrap_SKY_cipher_AddSHA256);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_Merkle", _wrap_SKY_cipher_Merkle);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cipher_SHA256_Null", _wrap_SKY_cipher_SHA256_Null);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_NewError", _wrap_SKY_wallet_NewError);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_NewWallet", _wrap_SKY_wallet_NewWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Lock", _wrap_SKY_wallet_Wallet_Lock);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Unlock", _wrap_SKY_wallet_Wallet_Unlock);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Load", _wrap_SKY_wallet_Load);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Save", _wrap_SKY_wallet_Wallet_Save);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Validate", _wrap_SKY_wallet_Wallet_Validate);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Type", _wrap_SKY_wallet_Wallet_Type);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Version", _wrap_SKY_wallet_Wallet_Version);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Filename", _wrap_SKY_wallet_Wallet_Filename);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_Label", _wrap_SKY_wallet_Wallet_Label);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_IsEncrypted", _wrap_SKY_wallet_Wallet_IsEncrypted);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_GenerateAddresses", _wrap_SKY_wallet_Wallet_GenerateAddresses);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_GetAddresses", _wrap_SKY_wallet_Wallet_GetAddresses);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_GetEntry", _wrap_SKY_wallet_Wallet_GetEntry);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_Wallet_AddEntry", _wrap_SKY_wallet_Wallet_AddEntry);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_NewCreateTransactionResponse", _wrap_SKY_api_NewCreateTransactionResponse);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_NewCreatedTransaction", _wrap_SKY_api_NewCreatedTransaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_CreatedTransaction_ToTransaction", _wrap_SKY_api_CreatedTransaction_ToTransaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_NewCreatedTransactionOutput", _wrap_SKY_api_NewCreatedTransactionOutput);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_NewCreatedTransactionInput", _wrap_SKY_api_NewCreatedTransactionInput);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_NewReadableEntry", _wrap_SKY_wallet_NewReadableEntry);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_LoadReadableWallet", _wrap_SKY_wallet_LoadReadableWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_ReadableWallet_Save", _wrap_SKY_wallet_ReadableWallet_Save);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_ReadableWallet_Load", _wrap_SKY_wallet_ReadableWallet_Load);
SWIGV8_AddStaticFunction(exports_obj, "SKY_wallet_ReadableWallet_Erase", _wrap_SKY_wallet_ReadableWallet_Erase);
SWIGV8_AddStaticFunction(exports_obj, "SKY_encrypt_ScryptChacha20poly1305_Encrypt", _wrap_SKY_encrypt_ScryptChacha20poly1305_Encrypt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_encrypt_ScryptChacha20poly1305_Decrypt", _wrap_SKY_encrypt_ScryptChacha20poly1305_Decrypt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_GenerateAddressesInFile", _wrap_SKY_cli_GenerateAddressesInFile);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_FormatAddressesAsJSON", _wrap_SKY_cli_FormatAddressesAsJSON);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_FormatAddressesAsJoinedArray", _wrap_SKY_cli_FormatAddressesAsJoinedArray);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_AddressesToStrings", _wrap_SKY_cli_AddressesToStrings);
SWIGV8_AddStaticFunction(exports_obj, "SKY_handle_close", _wrap_SKY_handle_close);
SWIGV8_AddStaticFunction(exports_obj, "SKY_handle_copy", _wrap_SKY_handle_copy);
SWIGV8_AddStaticFunction(exports_obj, "SKY_iputil_LocalhostIP", _wrap_SKY_iputil_LocalhostIP);
SWIGV8_AddStaticFunction(exports_obj, "SKY_iputil_IsLocalhost", _wrap_SKY_iputil_IsLocalhost);
SWIGV8_AddStaticFunction(exports_obj, "SKY_iputil_SplitAddr", _wrap_SKY_iputil_SplitAddr);
SWIGV8_AddStaticFunction(exports_obj, "SKY_cli_NewTransaction", _wrap_SKY_cli_NewTransaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_transaction_DistributeCoinHoursProportional", _wrap_SKY_transaction_DistributeCoinHoursProportional);
SWIGV8_AddStaticFunction(exports_obj, "SKY_transaction_DistributeSpendHours", _wrap_SKY_transaction_DistributeSpendHours);
SWIGV8_AddStaticFunction(exports_obj, "SKY_base58_Hex2Base58", _wrap_SKY_base58_Hex2Base58);
SWIGV8_AddStaticFunction(exports_obj, "SKY_base58_Encode", _wrap_SKY_base58_Encode);
SWIGV8_AddStaticFunction(exports_obj, "SKY_base58_Decode", _wrap_SKY_base58_Decode);
SWIGV8_AddStaticFunction(exports_obj, "SKY_base58_String2Hex", _wrap_SKY_base58_String2Hex);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_NewClient", _wrap_SKY_api_NewClient);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_CSRF", _wrap_SKY_api_Client_CSRF);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Version", _wrap_SKY_api_Client_Version);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Outputs", _wrap_SKY_api_Client_Outputs);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_OutputsForAddresses", _wrap_SKY_api_Client_OutputsForAddresses);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_OutputsForHashes", _wrap_SKY_api_Client_OutputsForHashes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_CoinSupply", _wrap_SKY_api_Client_CoinSupply);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_BlockByHash", _wrap_SKY_api_Client_BlockByHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_BlockBySeq", _wrap_SKY_api_Client_BlockBySeq);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Blocks", _wrap_SKY_api_Client_Blocks);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_LastBlocks", _wrap_SKY_api_Client_LastBlocks);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_BlockchainMetadata", _wrap_SKY_api_Client_BlockchainMetadata);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_BlockchainProgress", _wrap_SKY_api_Client_BlockchainProgress);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Balance", _wrap_SKY_api_Client_Balance);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_UxOut", _wrap_SKY_api_Client_UxOut);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_AddressUxOuts", _wrap_SKY_api_Client_AddressUxOuts);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Wallet", _wrap_SKY_api_Client_Wallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Wallets", _wrap_SKY_api_Client_Wallets);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_CreateUnencryptedWallet", _wrap_SKY_api_Client_CreateUnencryptedWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_CreateEncryptedWallet", _wrap_SKY_api_Client_CreateEncryptedWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_NewWalletAddress", _wrap_SKY_api_Client_NewWalletAddress);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_WalletBalance", _wrap_SKY_api_Client_WalletBalance);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_CreateTransaction", _wrap_SKY_api_Client_CreateTransaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_UpdateWallet", _wrap_SKY_api_Client_UpdateWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_WalletFolderName", _wrap_SKY_api_Client_WalletFolderName);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_NewSeed", _wrap_SKY_api_Client_NewSeed);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_WalletSeed", _wrap_SKY_api_Client_WalletSeed);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_NetworkConnection", _wrap_SKY_api_Client_NetworkConnection);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_NetworkConnections", _wrap_SKY_api_Client_NetworkConnections);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_NetworkDefaultPeers", _wrap_SKY_api_Client_NetworkDefaultPeers);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_NetworkTrustedPeers", _wrap_SKY_api_Client_NetworkTrustedPeers);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_NetworkExchangedPeers", _wrap_SKY_api_Client_NetworkExchangedPeers);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_PendingTransactions", _wrap_SKY_api_Client_PendingTransactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Transaction", _wrap_SKY_api_Client_Transaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Transactions", _wrap_SKY_api_Client_Transactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_ConfirmedTransactions", _wrap_SKY_api_Client_ConfirmedTransactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_UnconfirmedTransactions", _wrap_SKY_api_Client_UnconfirmedTransactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_InjectTransaction", _wrap_SKY_api_Client_InjectTransaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_ResendUnconfirmedTransactions", _wrap_SKY_api_Client_ResendUnconfirmedTransactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_RawTransaction", _wrap_SKY_api_Client_RawTransaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Richlist", _wrap_SKY_api_Client_Richlist);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_AddressCount", _wrap_SKY_api_Client_AddressCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_UnloadWallet", _wrap_SKY_api_Client_UnloadWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_Health", _wrap_SKY_api_Client_Health);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_EncryptWallet", _wrap_SKY_api_Client_EncryptWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_api_Client_DecryptWallet", _wrap_SKY_api_Client_DecryptWallet);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Create_Transaction", _wrap_SKY_coin_Create_Transaction);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_Copy", _wrap_SKY_coin_Transaction_Copy);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_GetTransactionObject", _wrap_SKY_coin_GetTransactionObject);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_ResetInputs", _wrap_SKY_coin_Transaction_ResetInputs);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_GetInputsCount", _wrap_SKY_coin_Transaction_GetInputsCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_GetInputAt", _wrap_SKY_coin_Transaction_GetInputAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_SetInputAt", _wrap_SKY_coin_Transaction_SetInputAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_GetOutputsCount", _wrap_SKY_coin_Transaction_GetOutputsCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_GetOutputAt", _wrap_SKY_coin_Transaction_GetOutputAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_SetOutputAt", _wrap_SKY_coin_Transaction_SetOutputAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_GetSignaturesCount", _wrap_SKY_coin_Transaction_GetSignaturesCount);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_GetSignatureAt", _wrap_SKY_coin_Transaction_GetSignatureAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_SetSignatureAt", _wrap_SKY_coin_Transaction_SetSignatureAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_PushSignature", _wrap_SKY_coin_Transaction_PushSignature);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_ResetOutputs", _wrap_SKY_coin_Transaction_ResetOutputs);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_ResetSignatures", _wrap_SKY_coin_Transaction_ResetSignatures);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_Verify", _wrap_SKY_coin_Transaction_Verify);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_PushInput", _wrap_SKY_coin_Transaction_PushInput);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_TransactionOutput_UxID", _wrap_SKY_coin_TransactionOutput_UxID);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_PushOutput", _wrap_SKY_coin_Transaction_PushOutput);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_SignInputs", _wrap_SKY_coin_Transaction_SignInputs);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_Size", _wrap_SKY_coin_Transaction_Size);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_Hash", _wrap_SKY_coin_Transaction_Hash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_SizeHash", _wrap_SKY_coin_Transaction_SizeHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_UpdateHeader", _wrap_SKY_coin_Transaction_UpdateHeader);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_HashInner", _wrap_SKY_coin_Transaction_HashInner);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_Serialize", _wrap_SKY_coin_Transaction_Serialize);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_TransactionDeserialize", _wrap_SKY_coin_TransactionDeserialize);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transaction_OutputHours", _wrap_SKY_coin_Transaction_OutputHours);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Create_Transactions", _wrap_SKY_coin_Create_Transactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_GetTransactionsObject", _wrap_SKY_coin_GetTransactionsObject);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transactions_Length", _wrap_SKY_coin_Transactions_Length);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transactions_Add", _wrap_SKY_coin_Transactions_Add);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transactions_Fees", _wrap_SKY_coin_Transactions_Fees);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transactions_GetAt", _wrap_SKY_coin_Transactions_GetAt);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transactions_Hashes", _wrap_SKY_coin_Transactions_Hashes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transactions_Size", _wrap_SKY_coin_Transactions_Size);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_Transactions_TruncateBytesTo", _wrap_SKY_coin_Transactions_TruncateBytesTo);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_SortTransactions", _wrap_SKY_coin_SortTransactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_NewSortableTransactions", _wrap_SKY_coin_NewSortableTransactions);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_SortableTransactions_Sort", _wrap_SKY_coin_SortableTransactions_Sort);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_SortableTransactions_Len", _wrap_SKY_coin_SortableTransactions_Len);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_SortableTransactions_Less", _wrap_SKY_coin_SortableTransactions_Less);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_SortableTransactions_Swap", _wrap_SKY_coin_SortableTransactions_Swap);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_VerifyTransactionCoinsSpending", _wrap_SKY_coin_VerifyTransactionCoinsSpending);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_VerifyTransactionHoursSpending", _wrap_SKY_coin_VerifyTransactionHoursSpending);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_VerifyInputSignatures", _wrap_SKY_coin_VerifyInputSignatures);
SWIGV8_AddStaticFunction(exports_obj, "SKY_params_GetDistributionAddresses", _wrap_SKY_params_GetDistributionAddresses);
SWIGV8_AddStaticFunction(exports_obj, "SKY_params_GetUnlockedDistributionAddresses", _wrap_SKY_params_GetUnlockedDistributionAddresses);
SWIGV8_AddStaticFunction(exports_obj, "SKY_params_GetLockedDistributionAddresses", _wrap_SKY_params_GetLockedDistributionAddresses);
SWIGV8_AddStaticFunction(exports_obj, "SKY_bip39_NewDefaultMnemomic", _wrap_SKY_bip39_NewDefaultMnemomic);
SWIGV8_AddStaticFunction(exports_obj, "SKY_bip39_NewEntropy", _wrap_SKY_bip39_NewEntropy);
SWIGV8_AddStaticFunction(exports_obj, "SKY_bip39_NewMnemonic", _wrap_SKY_bip39_NewMnemonic);
SWIGV8_AddStaticFunction(exports_obj, "SKY_bip39_ValidateMnemonic", _wrap_SKY_bip39_ValidateMnemonic);
SWIGV8_AddStaticFunction(exports_obj, "SKY_bip39_NewSeed", _wrap_SKY_bip39_NewSeed);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxOut_Hash", _wrap_SKY_coin_UxOut_Hash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxOut_SnapshotHash", _wrap_SKY_coin_UxOut_SnapshotHash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxBody_Hash", _wrap_SKY_coin_UxBody_Hash);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxOut_CoinHours", _wrap_SKY_coin_UxOut_CoinHours);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Hashes", _wrap_SKY_coin_UxArray_Hashes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_HasDupes", _wrap_SKY_coin_UxArray_HasDupes);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Sort", _wrap_SKY_coin_UxArray_Sort);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Len", _wrap_SKY_coin_UxArray_Len);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Less", _wrap_SKY_coin_UxArray_Less);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Swap", _wrap_SKY_coin_UxArray_Swap);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Coins", _wrap_SKY_coin_UxArray_Coins);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_CoinHours", _wrap_SKY_coin_UxArray_CoinHours);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Sub", _wrap_SKY_coin_UxArray_Sub);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_UxArray_Add", _wrap_SKY_coin_UxArray_Add);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_NewAddressUxOuts", _wrap_SKY_coin_NewAddressUxOuts);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_Keys", _wrap_SKY_coin_AddressUxOuts_Keys);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_Flatten", _wrap_SKY_coin_AddressUxOuts_Flatten);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_Sub", _wrap_SKY_coin_AddressUxOuts_Sub);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_Add", _wrap_SKY_coin_AddressUxOuts_Add);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_Get", _wrap_SKY_coin_AddressUxOuts_Get);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_HasKey", _wrap_SKY_coin_AddressUxOuts_HasKey);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_GetOutputLength", _wrap_SKY_coin_AddressUxOuts_GetOutputLength);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_Length", _wrap_SKY_coin_AddressUxOuts_Length);
SWIGV8_AddStaticFunction(exports_obj, "SKY_coin_AddressUxOuts_Set", _wrap_SKY_coin_AddressUxOuts_Set);
SWIGV8_AddStaticFunction(exports_obj, "SKY_params_DropletPrecisionToDivisor", _wrap_SKY_params_DropletPrecisionToDivisor);
SWIGV8_AddStaticFunction(exports_obj, "SKY_params_DropletPrecisionCheck", _wrap_SKY_params_DropletPrecisionCheck);


  /* register classes */
  exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_PubKey"), _exports_cipher_PubKey_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_SecKey"), _exports_cipher_SecKey_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_Ripemd160"), _exports_cipher_Ripemd160_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_Sig"), _exports_cipher_Sig_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_SHA256"), _exports_cipher_SHA256_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_Checksum"), _exports_cipher_Checksum_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_SecKeys"), _exports_cipher_SecKeys_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_PubKeys"), _exports_cipher_PubKeys_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_SHA256s"), _exports_cipher_SHA256s_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin_UxOutArray"), _exports_coin_UxOutArray_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher_Addresses"), _exports_cipher_Addresses_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("Fee_Calculator"), _exports_Fee_Calculator_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("_GoString_"), _exports__GoString__obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("GoInterface"), _exports_GoInterface_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("GoSlice"), _exports_GoSlice_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("api__RichlistParams"), _exports_api__RichlistParams_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("api__NetworkConnectionsFilter"), _exports_api__NetworkConnectionsFilter_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher__Address"), _exports_cipher__Address_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cipher__BitcoinAddress"), _exports_cipher__BitcoinAddress_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("encrypt__ScryptChacha20poly1305"), _exports_encrypt__ScryptChacha20poly1305_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("secp256k1go__Field"), _exports_secp256k1go__Field_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("secp256k1go__XY"), _exports_secp256k1go__XY_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("secp256k1go__XYZ"), _exports_secp256k1go__XYZ_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("cli__SendAmount"), _exports_cli__SendAmount_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__Transaction"), _exports_coin__Transaction_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__TransactionOutput"), _exports_coin__TransactionOutput_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__BlockHeader"), _exports_coin__BlockHeader_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__BlockBody"), _exports_coin__BlockBody_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__Block"), _exports_coin__Block_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__SignedBlock"), _exports_coin__SignedBlock_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__UxHead"), _exports_coin__UxHead_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__UxBody"), _exports_coin__UxBody_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("coin__UxOut"), _exports_coin__UxOut_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("httphelper__Address"), _exports_httphelper__Address_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("httphelper__SHA256"), _exports_httphelper__SHA256_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("wallet__Balance"), _exports_wallet__Balance_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("wallet__BalancePair"), _exports_wallet__BalancePair_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("wallet__Entry"), _exports_wallet__Entry_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("wallet__Note"), _exports_wallet__Note_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("wallet__ReadableNote"), _exports_wallet__ReadableNote_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("transaction__UxBalance"), _exports_transaction__UxBalance_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("api__TransactionInput"), _exports_api__TransactionInput_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("GoComplex64_"), _exports_GoComplex64__obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("GoComplex128_"), _exports_GoComplex128__obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("GoString_"), _exports_GoString__obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("GoInterface_"), _exports_GoInterface__obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("GoSlice_"), _exports_GoSlice__obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("Number"), _exports_Number_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("Signature"), _exports_Signature_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("Wallet"), _exports_Wallet_obj);
exports_obj->Set(SWIGV8_SYMBOL_NEW("FeeCalculator"), _exports_FeeCalculator_obj);


  /* create and register namespace objects */
  
}

#if defined(BUILDING_NODE_EXTENSION)
NODE_MODULE(skycoin, skycoin_initialize)
#endif
